/**
 * Generated by @openapi-codegen
 *
 * @version 4.6.0
 */
import * as reactQuery from "@tanstack/react-query";
import {
  useHyperionContext,
  HyperionContext,
  queryKeyFn,
} from "./hyperionContext";
import { deepMerge } from "./hyperionUtils";
import type * as Fetcher from "./hyperionFetcher";
import { hyperionFetch } from "./hyperionFetcher";
import type * as Schemas from "./hyperionSchemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type GetSeedLibrarySpeciesError = Fetcher.ErrorWrapper<undefined>;

export type GetSeedLibrarySpeciesResponse = Schemas.SpeciesComplete[];

export type GetSeedLibrarySpeciesVariables = HyperionContext["fetcherOptions"];

/**
 * Return all species from database as a list of SpeciesComplete schemas
 */
export const fetchGetSeedLibrarySpecies = (
  variables: GetSeedLibrarySpeciesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetSeedLibrarySpeciesResponse,
    GetSeedLibrarySpeciesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/seed_library/species/", method: "get", ...variables, signal });

/**
 * Return all species from database as a list of SpeciesComplete schemas
 */
export function getSeedLibrarySpeciesQuery(
  variables: GetSeedLibrarySpeciesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetSeedLibrarySpeciesResponse>;
};

export function getSeedLibrarySpeciesQuery(
  variables: GetSeedLibrarySpeciesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetSeedLibrarySpeciesResponse>)
    | reactQuery.SkipToken;
};

export function getSeedLibrarySpeciesQuery(
  variables: GetSeedLibrarySpeciesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/species/",
      operationId: "getSeedLibrarySpecies",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibrarySpecies(variables, signal),
  };
}

/**
 * Return all species from database as a list of SpeciesComplete schemas
 */
export const useSuspenseGetSeedLibrarySpecies = <
  TData = GetSeedLibrarySpeciesResponse,
>(
  variables: GetSeedLibrarySpeciesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibrarySpeciesResponse,
      GetSeedLibrarySpeciesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetSeedLibrarySpeciesResponse,
    GetSeedLibrarySpeciesError,
    TData
  >({
    ...getSeedLibrarySpeciesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all species from database as a list of SpeciesComplete schemas
 */
export const useGetSeedLibrarySpecies = <
  TData = GetSeedLibrarySpeciesResponse,
>(
  variables: GetSeedLibrarySpeciesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibrarySpeciesResponse,
      GetSeedLibrarySpeciesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetSeedLibrarySpeciesResponse,
    GetSeedLibrarySpeciesError,
    TData
  >({
    ...getSeedLibrarySpeciesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostSeedLibrarySpeciesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostSeedLibrarySpeciesVariables = {
  body: Schemas.SpeciesBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new Species by giving an SpeciesBase scheme
 * **This endpoint is only usable by seed_library **
 */
export const fetchPostSeedLibrarySpecies = (
  variables: PostSeedLibrarySpeciesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SpeciesComplete,
    PostSeedLibrarySpeciesError,
    Schemas.SpeciesBase,
    {},
    {},
    {}
  >({ url: "/seed_library/species/", method: "post", ...variables, signal });

/**
 * Create a new Species by giving an SpeciesBase scheme
 * **This endpoint is only usable by seed_library **
 */
export const usePostSeedLibrarySpecies = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SpeciesComplete,
      PostSeedLibrarySpeciesError,
      PostSeedLibrarySpeciesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SpeciesComplete,
    PostSeedLibrarySpeciesError,
    PostSeedLibrarySpeciesVariables
  >({
    mutationFn: (variables: PostSeedLibrarySpeciesVariables) =>
      fetchPostSeedLibrarySpecies(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetSeedLibrarySpeciesTypesError = Fetcher.ErrorWrapper<undefined>;

export type GetSeedLibrarySpeciesTypesVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all available types of species from SpeciesType enum.
 */
export const fetchGetSeedLibrarySpeciesTypes = (
  variables: GetSeedLibrarySpeciesTypesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SpeciesTypesReturn,
    GetSeedLibrarySpeciesTypesError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/seed_library/species/types",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all available types of species from SpeciesType enum.
 */
export function getSeedLibrarySpeciesTypesQuery(
  variables: GetSeedLibrarySpeciesTypesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.SpeciesTypesReturn>;
};

export function getSeedLibrarySpeciesTypesQuery(
  variables: GetSeedLibrarySpeciesTypesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.SpeciesTypesReturn>)
    | reactQuery.SkipToken;
};

export function getSeedLibrarySpeciesTypesQuery(
  variables: GetSeedLibrarySpeciesTypesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/species/types",
      operationId: "getSeedLibrarySpeciesTypes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibrarySpeciesTypes(variables, signal),
  };
}

/**
 * Return all available types of species from SpeciesType enum.
 */
export const useSuspenseGetSeedLibrarySpeciesTypes = <
  TData = Schemas.SpeciesTypesReturn,
>(
  variables: GetSeedLibrarySpeciesTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SpeciesTypesReturn,
      GetSeedLibrarySpeciesTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SpeciesTypesReturn,
    GetSeedLibrarySpeciesTypesError,
    TData
  >({
    ...getSeedLibrarySpeciesTypesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all available types of species from SpeciesType enum.
 */
export const useGetSeedLibrarySpeciesTypes = <
  TData = Schemas.SpeciesTypesReturn,
>(
  variables: GetSeedLibrarySpeciesTypesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SpeciesTypesReturn,
      GetSeedLibrarySpeciesTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.SpeciesTypesReturn,
    GetSeedLibrarySpeciesTypesError,
    TData
  >({
    ...getSeedLibrarySpeciesTypesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchSeedLibrarySpeciesSpeciesIdPathParams = {
  /**
   * @format uuid
   */
  speciesId: string;
};

export type PatchSeedLibrarySpeciesSpeciesIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchSeedLibrarySpeciesSpeciesIdVariables = {
  body?: Schemas.SpeciesEdit;
  pathParams: PatchSeedLibrarySpeciesSpeciesIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a Species
 * **This endpoint is only usable by seed_library**
 */
export const fetchPatchSeedLibrarySpeciesSpeciesId = (
  variables: PatchSeedLibrarySpeciesSpeciesIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchSeedLibrarySpeciesSpeciesIdError,
    Schemas.SpeciesEdit,
    {},
    {},
    PatchSeedLibrarySpeciesSpeciesIdPathParams
  >({
    url: "/seed_library/species/{speciesId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a Species
 * **This endpoint is only usable by seed_library**
 */
export const usePatchSeedLibrarySpeciesSpeciesId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchSeedLibrarySpeciesSpeciesIdError,
      PatchSeedLibrarySpeciesSpeciesIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchSeedLibrarySpeciesSpeciesIdError,
    PatchSeedLibrarySpeciesSpeciesIdVariables
  >({
    mutationFn: (variables: PatchSeedLibrarySpeciesSpeciesIdVariables) =>
      fetchPatchSeedLibrarySpeciesSpeciesId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteSeedLibrarySpeciesSpeciesIdPathParams = {
  /**
   * @format uuid
   */
  speciesId: string;
};

export type DeleteSeedLibrarySpeciesSpeciesIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteSeedLibrarySpeciesSpeciesIdVariables = {
  pathParams: DeleteSeedLibrarySpeciesSpeciesIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a Species
 * **This endpoint is only usable by seed_library**
 */
export const fetchDeleteSeedLibrarySpeciesSpeciesId = (
  variables: DeleteSeedLibrarySpeciesSpeciesIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteSeedLibrarySpeciesSpeciesIdError,
    undefined,
    {},
    {},
    DeleteSeedLibrarySpeciesSpeciesIdPathParams
  >({
    url: "/seed_library/species/{speciesId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a Species
 * **This endpoint is only usable by seed_library**
 */
export const useDeleteSeedLibrarySpeciesSpeciesId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteSeedLibrarySpeciesSpeciesIdError,
      DeleteSeedLibrarySpeciesSpeciesIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteSeedLibrarySpeciesSpeciesIdError,
    DeleteSeedLibrarySpeciesSpeciesIdVariables
  >({
    mutationFn: (variables: DeleteSeedLibrarySpeciesSpeciesIdVariables) =>
      fetchDeleteSeedLibrarySpeciesSpeciesId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetSeedLibraryPlantsWaitingError = Fetcher.ErrorWrapper<undefined>;

export type GetSeedLibraryPlantsWaitingResponse = Schemas.PlantSimple[];

export type GetSeedLibraryPlantsWaitingVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all plants where state=waiting from database as a list of PlantsComplete schemas
 */
export const fetchGetSeedLibraryPlantsWaiting = (
  variables: GetSeedLibraryPlantsWaitingVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetSeedLibraryPlantsWaitingResponse,
    GetSeedLibraryPlantsWaitingError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/seed_library/plants/waiting",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all plants where state=waiting from database as a list of PlantsComplete schemas
 */
export function getSeedLibraryPlantsWaitingQuery(
  variables: GetSeedLibraryPlantsWaitingVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetSeedLibraryPlantsWaitingResponse>;
};

export function getSeedLibraryPlantsWaitingQuery(
  variables: GetSeedLibraryPlantsWaitingVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetSeedLibraryPlantsWaitingResponse>)
    | reactQuery.SkipToken;
};

export function getSeedLibraryPlantsWaitingQuery(
  variables: GetSeedLibraryPlantsWaitingVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/plants/waiting",
      operationId: "getSeedLibraryPlantsWaiting",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibraryPlantsWaiting(variables, signal),
  };
}

/**
 * Return all plants where state=waiting from database as a list of PlantsComplete schemas
 */
export const useSuspenseGetSeedLibraryPlantsWaiting = <
  TData = GetSeedLibraryPlantsWaitingResponse,
>(
  variables: GetSeedLibraryPlantsWaitingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibraryPlantsWaitingResponse,
      GetSeedLibraryPlantsWaitingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetSeedLibraryPlantsWaitingResponse,
    GetSeedLibraryPlantsWaitingError,
    TData
  >({
    ...getSeedLibraryPlantsWaitingQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all plants where state=waiting from database as a list of PlantsComplete schemas
 */
export const useGetSeedLibraryPlantsWaiting = <
  TData = GetSeedLibraryPlantsWaitingResponse,
>(
  variables: GetSeedLibraryPlantsWaitingVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibraryPlantsWaitingResponse,
      GetSeedLibraryPlantsWaitingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetSeedLibraryPlantsWaitingResponse,
    GetSeedLibraryPlantsWaitingError,
    TData
  >({
    ...getSeedLibraryPlantsWaitingQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetSeedLibraryPlantsUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetSeedLibraryPlantsUsersMeResponse = Schemas.PlantSimple[];

export type GetSeedLibraryPlantsUsersMeVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all plants where user ={user_id} from database as a list of PlantsComplete schemas
 */
export const fetchGetSeedLibraryPlantsUsersMe = (
  variables: GetSeedLibraryPlantsUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetSeedLibraryPlantsUsersMeResponse,
    GetSeedLibraryPlantsUsersMeError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/seed_library/plants/users/me",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all plants where user ={user_id} from database as a list of PlantsComplete schemas
 */
export function getSeedLibraryPlantsUsersMeQuery(
  variables: GetSeedLibraryPlantsUsersMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetSeedLibraryPlantsUsersMeResponse>;
};

export function getSeedLibraryPlantsUsersMeQuery(
  variables: GetSeedLibraryPlantsUsersMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetSeedLibraryPlantsUsersMeResponse>)
    | reactQuery.SkipToken;
};

export function getSeedLibraryPlantsUsersMeQuery(
  variables: GetSeedLibraryPlantsUsersMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/plants/users/me",
      operationId: "getSeedLibraryPlantsUsersMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibraryPlantsUsersMe(variables, signal),
  };
}

/**
 * Return all plants where user ={user_id} from database as a list of PlantsComplete schemas
 */
export const useSuspenseGetSeedLibraryPlantsUsersMe = <
  TData = GetSeedLibraryPlantsUsersMeResponse,
>(
  variables: GetSeedLibraryPlantsUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibraryPlantsUsersMeResponse,
      GetSeedLibraryPlantsUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetSeedLibraryPlantsUsersMeResponse,
    GetSeedLibraryPlantsUsersMeError,
    TData
  >({
    ...getSeedLibraryPlantsUsersMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all plants where user ={user_id} from database as a list of PlantsComplete schemas
 */
export const useGetSeedLibraryPlantsUsersMe = <
  TData = GetSeedLibraryPlantsUsersMeResponse,
>(
  variables: GetSeedLibraryPlantsUsersMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibraryPlantsUsersMeResponse,
      GetSeedLibraryPlantsUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetSeedLibraryPlantsUsersMeResponse,
    GetSeedLibraryPlantsUsersMeError,
    TData
  >({
    ...getSeedLibraryPlantsUsersMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetSeedLibraryPlantsUsersUserIdPathParams = {
  userId: string;
};

export type GetSeedLibraryPlantsUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetSeedLibraryPlantsUsersUserIdResponse = Schemas.PlantSimple[];

export type GetSeedLibraryPlantsUsersUserIdVariables = {
  pathParams: GetSeedLibraryPlantsUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all plants where borrower_id = {user_id} from database as a list of PlantsComplete schemas
 */
export const fetchGetSeedLibraryPlantsUsersUserId = (
  variables: GetSeedLibraryPlantsUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetSeedLibraryPlantsUsersUserIdResponse,
    GetSeedLibraryPlantsUsersUserIdError,
    undefined,
    {},
    {},
    GetSeedLibraryPlantsUsersUserIdPathParams
  >({
    url: "/seed_library/plants/users/{userId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all plants where borrower_id = {user_id} from database as a list of PlantsComplete schemas
 */
export function getSeedLibraryPlantsUsersUserIdQuery(
  variables: GetSeedLibraryPlantsUsersUserIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetSeedLibraryPlantsUsersUserIdResponse>;
};

export function getSeedLibraryPlantsUsersUserIdQuery(
  variables: GetSeedLibraryPlantsUsersUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetSeedLibraryPlantsUsersUserIdResponse>)
    | reactQuery.SkipToken;
};

export function getSeedLibraryPlantsUsersUserIdQuery(
  variables: GetSeedLibraryPlantsUsersUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/plants/users/{userId}",
      operationId: "getSeedLibraryPlantsUsersUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibraryPlantsUsersUserId(variables, signal),
  };
}

/**
 * Return all plants where borrower_id = {user_id} from database as a list of PlantsComplete schemas
 */
export const useSuspenseGetSeedLibraryPlantsUsersUserId = <
  TData = GetSeedLibraryPlantsUsersUserIdResponse,
>(
  variables: GetSeedLibraryPlantsUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibraryPlantsUsersUserIdResponse,
      GetSeedLibraryPlantsUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetSeedLibraryPlantsUsersUserIdResponse,
    GetSeedLibraryPlantsUsersUserIdError,
    TData
  >({
    ...getSeedLibraryPlantsUsersUserIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all plants where borrower_id = {user_id} from database as a list of PlantsComplete schemas
 */
export const useGetSeedLibraryPlantsUsersUserId = <
  TData = GetSeedLibraryPlantsUsersUserIdResponse,
>(
  variables: GetSeedLibraryPlantsUsersUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetSeedLibraryPlantsUsersUserIdResponse,
      GetSeedLibraryPlantsUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetSeedLibraryPlantsUsersUserIdResponse,
    GetSeedLibraryPlantsUsersUserIdError,
    TData
  >({
    ...getSeedLibraryPlantsUsersUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetSeedLibraryPlantsPlantIdPathParams = {
  /**
   * @format uuid
   */
  plantId: string;
};

export type GetSeedLibraryPlantsPlantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetSeedLibraryPlantsPlantIdVariables = {
  pathParams: GetSeedLibraryPlantsPlantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the plants where plant ={plant_id} from database as a PlantsComplete schemas
 */
export const fetchGetSeedLibraryPlantsPlantId = (
  variables: GetSeedLibraryPlantsPlantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PlantComplete,
    GetSeedLibraryPlantsPlantIdError,
    undefined,
    {},
    {},
    GetSeedLibraryPlantsPlantIdPathParams
  >({
    url: "/seed_library/plants/{plantId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the plants where plant ={plant_id} from database as a PlantsComplete schemas
 */
export function getSeedLibraryPlantsPlantIdQuery(
  variables: GetSeedLibraryPlantsPlantIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.PlantComplete>;
};

export function getSeedLibraryPlantsPlantIdQuery(
  variables: GetSeedLibraryPlantsPlantIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.PlantComplete>)
    | reactQuery.SkipToken;
};

export function getSeedLibraryPlantsPlantIdQuery(
  variables: GetSeedLibraryPlantsPlantIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/plants/{plantId}",
      operationId: "getSeedLibraryPlantsPlantId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibraryPlantsPlantId(variables, signal),
  };
}

/**
 * Return the plants where plant ={plant_id} from database as a PlantsComplete schemas
 */
export const useSuspenseGetSeedLibraryPlantsPlantId = <
  TData = Schemas.PlantComplete,
>(
  variables: GetSeedLibraryPlantsPlantIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PlantComplete,
      GetSeedLibraryPlantsPlantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.PlantComplete,
    GetSeedLibraryPlantsPlantIdError,
    TData
  >({
    ...getSeedLibraryPlantsPlantIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the plants where plant ={plant_id} from database as a PlantsComplete schemas
 */
export const useGetSeedLibraryPlantsPlantId = <TData = Schemas.PlantComplete,>(
  variables: GetSeedLibraryPlantsPlantIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PlantComplete,
      GetSeedLibraryPlantsPlantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.PlantComplete,
    GetSeedLibraryPlantsPlantIdError,
    TData
  >({
    ...getSeedLibraryPlantsPlantIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchSeedLibraryPlantsPlantIdPathParams = {
  /**
   * @format uuid
   */
  plantId: string;
};

export type PatchSeedLibraryPlantsPlantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchSeedLibraryPlantsPlantIdVariables = {
  body?: Schemas.PlantEdit;
  pathParams: PatchSeedLibraryPlantsPlantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a Plant
 * **This endpoint is only usable by the owner of the plant**
 */
export const fetchPatchSeedLibraryPlantsPlantId = (
  variables: PatchSeedLibraryPlantsPlantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchSeedLibraryPlantsPlantIdError,
    Schemas.PlantEdit,
    {},
    {},
    PatchSeedLibraryPlantsPlantIdPathParams
  >({
    url: "/seed_library/plants/{plantId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a Plant
 * **This endpoint is only usable by the owner of the plant**
 */
export const usePatchSeedLibraryPlantsPlantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchSeedLibraryPlantsPlantIdError,
      PatchSeedLibraryPlantsPlantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchSeedLibraryPlantsPlantIdError,
    PatchSeedLibraryPlantsPlantIdVariables
  >({
    mutationFn: (variables: PatchSeedLibraryPlantsPlantIdVariables) =>
      fetchPatchSeedLibraryPlantsPlantId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteSeedLibraryPlantsPlantIdPathParams = {
  /**
   * @format uuid
   */
  plantId: string;
};

export type DeleteSeedLibraryPlantsPlantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteSeedLibraryPlantsPlantIdVariables = {
  pathParams: DeleteSeedLibraryPlantsPlantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a Plant
 * **This endpoint is only usable by seed_library**
 */
export const fetchDeleteSeedLibraryPlantsPlantId = (
  variables: DeleteSeedLibraryPlantsPlantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteSeedLibraryPlantsPlantIdError,
    undefined,
    {},
    {},
    DeleteSeedLibraryPlantsPlantIdPathParams
  >({
    url: "/seed_library/plants/{plantId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a Plant
 * **This endpoint is only usable by seed_library**
 */
export const useDeleteSeedLibraryPlantsPlantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteSeedLibraryPlantsPlantIdError,
      DeleteSeedLibraryPlantsPlantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteSeedLibraryPlantsPlantIdError,
    DeleteSeedLibraryPlantsPlantIdVariables
  >({
    mutationFn: (variables: DeleteSeedLibraryPlantsPlantIdVariables) =>
      fetchDeleteSeedLibraryPlantsPlantId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostSeedLibraryPlantsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostSeedLibraryPlantsVariables = {
  body: Schemas.PlantCreation;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new Plant by giving an PlantCreation scheme
 * **This endpoint is only usable if the plant has an ancestor_id or by seed_library **
 */
export const fetchPostSeedLibraryPlants = (
  variables: PostSeedLibraryPlantsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PlantComplete,
    PostSeedLibraryPlantsError,
    Schemas.PlantCreation,
    {},
    {},
    {}
  >({ url: "/seed_library/plants/", method: "post", ...variables, signal });

/**
 * Create a new Plant by giving an PlantCreation scheme
 * **This endpoint is only usable if the plant has an ancestor_id or by seed_library **
 */
export const usePostSeedLibraryPlants = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PlantComplete,
      PostSeedLibraryPlantsError,
      PostSeedLibraryPlantsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PlantComplete,
    PostSeedLibraryPlantsError,
    PostSeedLibraryPlantsVariables
  >({
    mutationFn: (variables: PostSeedLibraryPlantsVariables) =>
      fetchPostSeedLibraryPlants(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchSeedLibraryPlantsPlantIdAdminPathParams = {
  /**
   * @format uuid
   */
  plantId: string;
};

export type PatchSeedLibraryPlantsPlantIdAdminError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchSeedLibraryPlantsPlantIdAdminVariables = {
  body?: Schemas.PlantEdit;
  pathParams: PatchSeedLibraryPlantsPlantIdAdminPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a Plant
 * **This endpoint is only usable by seed_library**
 */
export const fetchPatchSeedLibraryPlantsPlantIdAdmin = (
  variables: PatchSeedLibraryPlantsPlantIdAdminVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchSeedLibraryPlantsPlantIdAdminError,
    Schemas.PlantEdit,
    {},
    {},
    PatchSeedLibraryPlantsPlantIdAdminPathParams
  >({
    url: "/seed_library/plants/{plantId}/admin",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a Plant
 * **This endpoint is only usable by seed_library**
 */
export const usePatchSeedLibraryPlantsPlantIdAdmin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchSeedLibraryPlantsPlantIdAdminError,
      PatchSeedLibraryPlantsPlantIdAdminVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchSeedLibraryPlantsPlantIdAdminError,
    PatchSeedLibraryPlantsPlantIdAdminVariables
  >({
    mutationFn: (variables: PatchSeedLibraryPlantsPlantIdAdminVariables) =>
      fetchPatchSeedLibraryPlantsPlantIdAdmin(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchSeedLibraryPlantsPlantIdBorrowPathParams = {
  /**
   * @format uuid
   */
  plantId: string;
};

export type PatchSeedLibraryPlantsPlantIdBorrowError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchSeedLibraryPlantsPlantIdBorrowVariables = {
  pathParams: PatchSeedLibraryPlantsPlantIdBorrowPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Plant borrowed by the user (modify borrowing date, borrower and state)
 */
export const fetchPatchSeedLibraryPlantsPlantIdBorrow = (
  variables: PatchSeedLibraryPlantsPlantIdBorrowVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchSeedLibraryPlantsPlantIdBorrowError,
    undefined,
    {},
    {},
    PatchSeedLibraryPlantsPlantIdBorrowPathParams
  >({
    url: "/seed_library/plants/{plantId}/borrow",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Plant borrowed by the user (modify borrowing date, borrower and state)
 */
export const usePatchSeedLibraryPlantsPlantIdBorrow = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchSeedLibraryPlantsPlantIdBorrowError,
      PatchSeedLibraryPlantsPlantIdBorrowVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchSeedLibraryPlantsPlantIdBorrowError,
    PatchSeedLibraryPlantsPlantIdBorrowVariables
  >({
    mutationFn: (variables: PatchSeedLibraryPlantsPlantIdBorrowVariables) =>
      fetchPatchSeedLibraryPlantsPlantIdBorrow(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetSeedLibraryInformationError = Fetcher.ErrorWrapper<undefined>;

export type GetSeedLibraryInformationVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetSeedLibraryInformation = (
  variables: GetSeedLibraryInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SeedLibraryInformation,
    GetSeedLibraryInformationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/seed_library/information", method: "get", ...variables, signal });

export function getSeedLibraryInformationQuery(
  variables: GetSeedLibraryInformationVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.SeedLibraryInformation>;
};

export function getSeedLibraryInformationQuery(
  variables: GetSeedLibraryInformationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.SeedLibraryInformation>)
    | reactQuery.SkipToken;
};

export function getSeedLibraryInformationQuery(
  variables: GetSeedLibraryInformationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/seed_library/information",
      operationId: "getSeedLibraryInformation",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSeedLibraryInformation(variables, signal),
  };
}

export const useSuspenseGetSeedLibraryInformation = <
  TData = Schemas.SeedLibraryInformation,
>(
  variables: GetSeedLibraryInformationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SeedLibraryInformation,
      GetSeedLibraryInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SeedLibraryInformation,
    GetSeedLibraryInformationError,
    TData
  >({
    ...getSeedLibraryInformationQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetSeedLibraryInformation = <
  TData = Schemas.SeedLibraryInformation,
>(
  variables: GetSeedLibraryInformationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SeedLibraryInformation,
      GetSeedLibraryInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.SeedLibraryInformation,
    GetSeedLibraryInformationError,
    TData
  >({
    ...getSeedLibraryInformationQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchSeedLibraryInformationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchSeedLibraryInformationVariables = {
  body?: Schemas.SeedLibraryInformation;
} & HyperionContext["fetcherOptions"];

export const fetchPatchSeedLibraryInformation = (
  variables: PatchSeedLibraryInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchSeedLibraryInformationError,
    Schemas.SeedLibraryInformation,
    {},
    {},
    {}
  >({
    url: "/seed_library/information",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchSeedLibraryInformation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchSeedLibraryInformationError,
      PatchSeedLibraryInformationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchSeedLibraryInformationError,
    PatchSeedLibraryInformationVariables
  >({
    mutationFn: (variables: PatchSeedLibraryInformationVariables) =>
      fetchPatchSeedLibraryInformation(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAmapProductsError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapProductsResponse =
  Schemas.AppModulesAmapSchemasAmapProductComplete[];

export type GetAmapProductsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapProducts = (
  variables: GetAmapProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapProductsResponse,
    GetAmapProductsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/products", method: "get", ...variables, signal });

/**
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export function getAmapProductsQuery(variables: GetAmapProductsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAmapProductsResponse>;
};

export function getAmapProductsQuery(
  variables: GetAmapProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAmapProductsResponse>)
    | reactQuery.SkipToken;
};

export function getAmapProductsQuery(
  variables: GetAmapProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/products",
      operationId: "getAmapProducts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapProducts(variables, signal),
  };
}

/**
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useSuspenseGetAmapProducts = <TData = GetAmapProductsResponse,>(
  variables: GetAmapProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapProductsResponse,
      GetAmapProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAmapProductsResponse,
    GetAmapProductsError,
    TData
  >({
    ...getAmapProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all products
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapProducts = <TData = GetAmapProductsResponse,>(
  variables: GetAmapProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapProductsResponse,
      GetAmapProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapProductsResponse,
    GetAmapProductsError,
    TData
  >({
    ...getAmapProductsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAmapProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapProductsVariables = {
  body: Schemas.ProductSimple;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapProducts = (
  variables: PostAmapProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    PostAmapProductsError,
    Schemas.ProductSimple,
    {},
    {},
    {}
  >({ url: "/amap/products", method: "post", ...variables, signal });

/**
 * Create a new product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesAmapSchemasAmapProductComplete,
      PostAmapProductsError,
      PostAmapProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    PostAmapProductsError,
    PostAmapProductsVariables
  >({
    mutationFn: (variables: PostAmapProductsVariables) =>
      fetchPostAmapProducts(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAmapProductsProductIdPathParams = {
  productId: string;
};

export type GetAmapProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapProductsProductIdVariables = {
  pathParams: GetAmapProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a specific product
 */
export const fetchGetAmapProductsProductId = (
  variables: GetAmapProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    GetAmapProductsProductIdError,
    undefined,
    {},
    {},
    GetAmapProductsProductIdPathParams
  >({ url: "/amap/products/{productId}", method: "get", ...variables, signal });

/**
 * Get a specific product
 */
export function getAmapProductsProductIdQuery(
  variables: GetAmapProductsProductIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.AppModulesAmapSchemasAmapProductComplete>;
};

export function getAmapProductsProductIdQuery(
  variables: GetAmapProductsProductIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.AppModulesAmapSchemasAmapProductComplete>)
    | reactQuery.SkipToken;
};

export function getAmapProductsProductIdQuery(
  variables: GetAmapProductsProductIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/products/{productId}",
      operationId: "getAmapProductsProductId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapProductsProductId(variables, signal),
  };
}

/**
 * Get a specific product
 */
export const useSuspenseGetAmapProductsProductId = <
  TData = Schemas.AppModulesAmapSchemasAmapProductComplete,
>(
  variables: GetAmapProductsProductIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AppModulesAmapSchemasAmapProductComplete,
      GetAmapProductsProductIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    GetAmapProductsProductIdError,
    TData
  >({
    ...getAmapProductsProductIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a specific product
 */
export const useGetAmapProductsProductId = <
  TData = Schemas.AppModulesAmapSchemasAmapProductComplete,
>(
  variables: GetAmapProductsProductIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AppModulesAmapSchemasAmapProductComplete,
      GetAmapProductsProductIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.AppModulesAmapSchemasAmapProductComplete,
    GetAmapProductsProductIdError,
    TData
  >({
    ...getAmapProductsProductIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchAmapProductsProductIdPathParams = {
  productId: string;
};

export type PatchAmapProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapProductsProductIdVariables = {
  body?: Schemas.AppModulesAmapSchemasAmapProductEdit;
  pathParams: PatchAmapProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapProductsProductId = (
  variables: PatchAmapProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapProductsProductIdError,
    Schemas.AppModulesAmapSchemasAmapProductEdit,
    {},
    {},
    PatchAmapProductsProductIdPathParams
  >({
    url: "/amap/products/{productId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a product
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapProductsProductIdError,
      PatchAmapProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapProductsProductIdError,
    PatchAmapProductsProductIdVariables
  >({
    mutationFn: (variables: PatchAmapProductsProductIdVariables) =>
      fetchPatchAmapProductsProductId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteAmapProductsProductIdPathParams = {
  productId: string;
};

export type DeleteAmapProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapProductsProductIdVariables = {
  pathParams: DeleteAmapProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a product. A product can not be deleted if it is already used in a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchDeleteAmapProductsProductId = (
  variables: DeleteAmapProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapProductsProductIdError,
    undefined,
    {},
    {},
    DeleteAmapProductsProductIdPathParams
  >({
    url: "/amap/products/{productId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a product. A product can not be deleted if it is already used in a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useDeleteAmapProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapProductsProductIdError,
      DeleteAmapProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapProductsProductIdError,
    DeleteAmapProductsProductIdVariables
  >({
    mutationFn: (variables: DeleteAmapProductsProductIdVariables) =>
      fetchDeleteAmapProductsProductId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAmapDeliveriesError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapDeliveriesResponse = Schemas.DeliveryReturn[];

export type GetAmapDeliveriesVariables = HyperionContext["fetcherOptions"];

/**
 * Get all deliveries.
 */
export const fetchGetAmapDeliveries = (
  variables: GetAmapDeliveriesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapDeliveriesResponse,
    GetAmapDeliveriesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/deliveries", method: "get", ...variables, signal });

/**
 * Get all deliveries.
 */
export function getAmapDeliveriesQuery(variables: GetAmapDeliveriesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAmapDeliveriesResponse>;
};

export function getAmapDeliveriesQuery(
  variables: GetAmapDeliveriesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAmapDeliveriesResponse>)
    | reactQuery.SkipToken;
};

export function getAmapDeliveriesQuery(
  variables: GetAmapDeliveriesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/deliveries",
      operationId: "getAmapDeliveries",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapDeliveries(variables, signal),
  };
}

/**
 * Get all deliveries.
 */
export const useSuspenseGetAmapDeliveries = <
  TData = GetAmapDeliveriesResponse,
>(
  variables: GetAmapDeliveriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapDeliveriesResponse,
      GetAmapDeliveriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAmapDeliveriesResponse,
    GetAmapDeliveriesError,
    TData
  >({
    ...getAmapDeliveriesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all deliveries.
 */
export const useGetAmapDeliveries = <TData = GetAmapDeliveriesResponse,>(
  variables: GetAmapDeliveriesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapDeliveriesResponse,
      GetAmapDeliveriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapDeliveriesResponse,
    GetAmapDeliveriesError,
    TData
  >({
    ...getAmapDeliveriesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAmapDeliveriesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesVariables = {
  body: Schemas.DeliveryBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapDeliveries = (
  variables: PostAmapDeliveriesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.DeliveryReturn,
    PostAmapDeliveriesError,
    Schemas.DeliveryBase,
    {},
    {},
    {}
  >({ url: "/amap/deliveries", method: "post", ...variables, signal });

/**
 * Create a new delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapDeliveries = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DeliveryReturn,
      PostAmapDeliveriesError,
      PostAmapDeliveriesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.DeliveryReturn,
    PostAmapDeliveriesError,
    PostAmapDeliveriesVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesVariables) =>
      fetchPostAmapDeliveries(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteAmapDeliveriesDeliveryIdPathParams = {
  deliveryId: string;
};

export type DeleteAmapDeliveriesDeliveryIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapDeliveriesDeliveryIdVariables = {
  pathParams: DeleteAmapDeliveriesDeliveryIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchDeleteAmapDeliveriesDeliveryId = (
  variables: DeleteAmapDeliveriesDeliveryIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapDeliveriesDeliveryIdError,
    undefined,
    {},
    {},
    DeleteAmapDeliveriesDeliveryIdPathParams
  >({
    url: "/amap/deliveries/{deliveryId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useDeleteAmapDeliveriesDeliveryId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapDeliveriesDeliveryIdError,
      DeleteAmapDeliveriesDeliveryIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapDeliveriesDeliveryIdError,
    DeleteAmapDeliveriesDeliveryIdVariables
  >({
    mutationFn: (variables: DeleteAmapDeliveriesDeliveryIdVariables) =>
      fetchDeleteAmapDeliveriesDeliveryId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchAmapDeliveriesDeliveryIdPathParams = {
  deliveryId: string;
};

export type PatchAmapDeliveriesDeliveryIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapDeliveriesDeliveryIdVariables = {
  body?: Schemas.DeliveryUpdate;
  pathParams: PatchAmapDeliveriesDeliveryIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapDeliveriesDeliveryId = (
  variables: PatchAmapDeliveriesDeliveryIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapDeliveriesDeliveryIdError,
    Schemas.DeliveryUpdate,
    {},
    {},
    PatchAmapDeliveriesDeliveryIdPathParams
  >({
    url: "/amap/deliveries/{deliveryId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapDeliveriesDeliveryId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapDeliveriesDeliveryIdError,
      PatchAmapDeliveriesDeliveryIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapDeliveriesDeliveryIdError,
    PatchAmapDeliveriesDeliveryIdVariables
  >({
    mutationFn: (variables: PatchAmapDeliveriesDeliveryIdVariables) =>
      fetchPatchAmapDeliveriesDeliveryId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdProductsPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdProductsVariables = {
  body: Schemas.DeliveryProductsUpdate;
  pathParams: PostAmapDeliveriesDeliveryIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Add `product_id` product to `delivery_id` delivery. This endpoint will only add a membership between the two objects.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapDeliveriesDeliveryIdProducts = (
  variables: PostAmapDeliveriesDeliveryIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostAmapDeliveriesDeliveryIdProductsError,
    Schemas.DeliveryProductsUpdate,
    {},
    {},
    PostAmapDeliveriesDeliveryIdProductsPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/products",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add `product_id` product to `delivery_id` delivery. This endpoint will only add a membership between the two objects.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapDeliveriesDeliveryIdProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostAmapDeliveriesDeliveryIdProductsError,
      PostAmapDeliveriesDeliveryIdProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostAmapDeliveriesDeliveryIdProductsError,
    PostAmapDeliveriesDeliveryIdProductsVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdProductsVariables) =>
      fetchPostAmapDeliveriesDeliveryIdProducts(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteAmapDeliveriesDeliveryIdProductsPathParams = {
  deliveryId: string;
};

export type DeleteAmapDeliveriesDeliveryIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapDeliveriesDeliveryIdProductsVariables = {
  body: Schemas.DeliveryProductsUpdate;
  pathParams: DeleteAmapDeliveriesDeliveryIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a given product from a delivery. This won't delete the product nor the delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchDeleteAmapDeliveriesDeliveryIdProducts = (
  variables: DeleteAmapDeliveriesDeliveryIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapDeliveriesDeliveryIdProductsError,
    Schemas.DeliveryProductsUpdate,
    {},
    {},
    DeleteAmapDeliveriesDeliveryIdProductsPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/products",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a given product from a delivery. This won't delete the product nor the delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useDeleteAmapDeliveriesDeliveryIdProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapDeliveriesDeliveryIdProductsError,
      DeleteAmapDeliveriesDeliveryIdProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapDeliveriesDeliveryIdProductsError,
    DeleteAmapDeliveriesDeliveryIdProductsVariables
  >({
    mutationFn: (variables: DeleteAmapDeliveriesDeliveryIdProductsVariables) =>
      fetchDeleteAmapDeliveriesDeliveryIdProducts(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetAmapDeliveriesDeliveryIdOrdersPathParams = {
  deliveryId: string;
};

export type GetAmapDeliveriesDeliveryIdOrdersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapDeliveriesDeliveryIdOrdersResponse = Schemas.OrderReturn[];

export type GetAmapDeliveriesDeliveryIdOrdersVariables = {
  pathParams: GetAmapDeliveriesDeliveryIdOrdersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapDeliveriesDeliveryIdOrders = (
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapDeliveriesDeliveryIdOrdersResponse,
    GetAmapDeliveriesDeliveryIdOrdersError,
    undefined,
    {},
    {},
    GetAmapDeliveriesDeliveryIdOrdersPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/orders",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export function getAmapDeliveriesDeliveryIdOrdersQuery(
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetAmapDeliveriesDeliveryIdOrdersResponse>;
};

export function getAmapDeliveriesDeliveryIdOrdersQuery(
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetAmapDeliveriesDeliveryIdOrdersResponse>)
    | reactQuery.SkipToken;
};

export function getAmapDeliveriesDeliveryIdOrdersQuery(
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/deliveries/{deliveryId}/orders",
      operationId: "getAmapDeliveriesDeliveryIdOrders",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapDeliveriesDeliveryIdOrders(variables, signal),
  };
}

/**
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useSuspenseGetAmapDeliveriesDeliveryIdOrders = <
  TData = GetAmapDeliveriesDeliveryIdOrdersResponse,
>(
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapDeliveriesDeliveryIdOrdersResponse,
      GetAmapDeliveriesDeliveryIdOrdersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAmapDeliveriesDeliveryIdOrdersResponse,
    GetAmapDeliveriesDeliveryIdOrdersError,
    TData
  >({
    ...getAmapDeliveriesDeliveryIdOrdersQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get orders from a delivery.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapDeliveriesDeliveryIdOrders = <
  TData = GetAmapDeliveriesDeliveryIdOrdersResponse,
>(
  variables: GetAmapDeliveriesDeliveryIdOrdersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapDeliveriesDeliveryIdOrdersResponse,
      GetAmapDeliveriesDeliveryIdOrdersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapDeliveriesDeliveryIdOrdersResponse,
    GetAmapDeliveriesDeliveryIdOrdersError,
    TData
  >({
    ...getAmapDeliveriesDeliveryIdOrdersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAmapOrdersOrderIdPathParams = {
  orderId: string;
};

export type GetAmapOrdersOrderIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapOrdersOrderIdVariables = {
  pathParams: GetAmapOrdersOrderIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapOrdersOrderId = (
  variables: GetAmapOrdersOrderIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.OrderReturn,
    GetAmapOrdersOrderIdError,
    undefined,
    {},
    {},
    GetAmapOrdersOrderIdPathParams
  >({ url: "/amap/orders/{orderId}", method: "get", ...variables, signal });

/**
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export function getAmapOrdersOrderIdQuery(
  variables: GetAmapOrdersOrderIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.OrderReturn>;
};

export function getAmapOrdersOrderIdQuery(
  variables: GetAmapOrdersOrderIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.OrderReturn>)
    | reactQuery.SkipToken;
};

export function getAmapOrdersOrderIdQuery(
  variables: GetAmapOrdersOrderIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/orders/{orderId}",
      operationId: "getAmapOrdersOrderId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapOrdersOrderId(variables, signal),
  };
}

/**
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useSuspenseGetAmapOrdersOrderId = <TData = Schemas.OrderReturn,>(
  variables: GetAmapOrdersOrderIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrderReturn,
      GetAmapOrdersOrderIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.OrderReturn,
    GetAmapOrdersOrderIdError,
    TData
  >({
    ...getAmapOrdersOrderIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get content of an order.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapOrdersOrderId = <TData = Schemas.OrderReturn,>(
  variables: GetAmapOrdersOrderIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.OrderReturn,
      GetAmapOrdersOrderIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.OrderReturn,
    GetAmapOrdersOrderIdError,
    TData
  >({
    ...getAmapOrdersOrderIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchAmapOrdersOrderIdPathParams = {
  orderId: string;
};

export type PatchAmapOrdersOrderIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapOrdersOrderIdVariables = {
  body?: Schemas.OrderEdit;
  pathParams: PatchAmapOrdersOrderIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit an order.
 *
 * **A member of the group AMAP can edit orders of other users**
 */
export const fetchPatchAmapOrdersOrderId = (
  variables: PatchAmapOrdersOrderIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapOrdersOrderIdError,
    Schemas.OrderEdit,
    {},
    {},
    PatchAmapOrdersOrderIdPathParams
  >({ url: "/amap/orders/{orderId}", method: "patch", ...variables, signal });

/**
 * Edit an order.
 *
 * **A member of the group AMAP can edit orders of other users**
 */
export const usePatchAmapOrdersOrderId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapOrdersOrderIdError,
      PatchAmapOrdersOrderIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapOrdersOrderIdError,
    PatchAmapOrdersOrderIdVariables
  >({
    mutationFn: (variables: PatchAmapOrdersOrderIdVariables) =>
      fetchPatchAmapOrdersOrderId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteAmapOrdersOrderIdPathParams = {
  orderId: string;
};

export type DeleteAmapOrdersOrderIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAmapOrdersOrderIdVariables = {
  pathParams: DeleteAmapOrdersOrderIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an order.
 *
 * **A member of the group AMAP can delete orders of other users**
 */
export const fetchDeleteAmapOrdersOrderId = (
  variables: DeleteAmapOrdersOrderIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAmapOrdersOrderIdError,
    undefined,
    {},
    {},
    DeleteAmapOrdersOrderIdPathParams
  >({ url: "/amap/orders/{orderId}", method: "delete", ...variables, signal });

/**
 * Delete an order.
 *
 * **A member of the group AMAP can delete orders of other users**
 */
export const useDeleteAmapOrdersOrderId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAmapOrdersOrderIdError,
      DeleteAmapOrdersOrderIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAmapOrdersOrderIdError,
    DeleteAmapOrdersOrderIdVariables
  >({
    mutationFn: (variables: DeleteAmapOrdersOrderIdVariables) =>
      fetchDeleteAmapOrdersOrderId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostAmapOrdersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapOrdersVariables = {
  body: Schemas.OrderBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add an order to a delivery.
 *
 * **A member of the group AMAP can create an order for every user**
 */
export const fetchPostAmapOrders = (
  variables: PostAmapOrdersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.OrderReturn,
    PostAmapOrdersError,
    Schemas.OrderBase,
    {},
    {},
    {}
  >({ url: "/amap/orders", method: "post", ...variables, signal });

/**
 * Add an order to a delivery.
 *
 * **A member of the group AMAP can create an order for every user**
 */
export const usePostAmapOrders = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.OrderReturn,
      PostAmapOrdersError,
      PostAmapOrdersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.OrderReturn,
    PostAmapOrdersError,
    PostAmapOrdersVariables
  >({
    mutationFn: (variables: PostAmapOrdersVariables) =>
      fetchPostAmapOrders(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdOpenorderingPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdOpenorderingError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostAmapDeliveriesDeliveryIdOpenorderingVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdOpenorderingPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdOpenordering = (
  variables: PostAmapDeliveriesDeliveryIdOpenorderingVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdOpenorderingError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdOpenorderingPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/openordering",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdOpenordering = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdOpenorderingError,
      PostAmapDeliveriesDeliveryIdOpenorderingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdOpenorderingError,
    PostAmapDeliveriesDeliveryIdOpenorderingVariables
  >({
    mutationFn: (
      variables: PostAmapDeliveriesDeliveryIdOpenorderingVariables,
    ) =>
      fetchPostAmapDeliveriesDeliveryIdOpenordering(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdLockPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdLockError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdLockVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdLockPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdLock = (
  variables: PostAmapDeliveriesDeliveryIdLockVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdLockError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdLockPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/lock",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdLock = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdLockError,
      PostAmapDeliveriesDeliveryIdLockVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdLockError,
    PostAmapDeliveriesDeliveryIdLockVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdLockVariables) =>
      fetchPostAmapDeliveriesDeliveryIdLock(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdDeliveredPathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdDeliveredError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdDeliveredVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdDeliveredPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdDelivered = (
  variables: PostAmapDeliveriesDeliveryIdDeliveredVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdDeliveredError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdDeliveredPathParams
  >({
    url: "/amap/deliveries/{deliveryId}/delivered",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdDelivered = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdDeliveredError,
      PostAmapDeliveriesDeliveryIdDeliveredVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdDeliveredError,
    PostAmapDeliveriesDeliveryIdDeliveredVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdDeliveredVariables) =>
      fetchPostAmapDeliveriesDeliveryIdDelivered(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostAmapDeliveriesDeliveryIdArchivePathParams = {
  deliveryId: string;
};

export type PostAmapDeliveriesDeliveryIdArchiveError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapDeliveriesDeliveryIdArchiveVariables = {
  pathParams: PostAmapDeliveriesDeliveryIdArchivePathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostAmapDeliveriesDeliveryIdArchive = (
  variables: PostAmapDeliveriesDeliveryIdArchiveVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAmapDeliveriesDeliveryIdArchiveError,
    undefined,
    {},
    {},
    PostAmapDeliveriesDeliveryIdArchivePathParams
  >({
    url: "/amap/deliveries/{deliveryId}/archive",
    method: "post",
    ...variables,
    signal,
  });

export const usePostAmapDeliveriesDeliveryIdArchive = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAmapDeliveriesDeliveryIdArchiveError,
      PostAmapDeliveriesDeliveryIdArchiveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAmapDeliveriesDeliveryIdArchiveError,
    PostAmapDeliveriesDeliveryIdArchiveVariables
  >({
    mutationFn: (variables: PostAmapDeliveriesDeliveryIdArchiveVariables) =>
      fetchPostAmapDeliveriesDeliveryIdArchive(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetAmapUsersCashError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapUsersCashResponse = Schemas.CashComplete[];

export type GetAmapUsersCashVariables = HyperionContext["fetcherOptions"];

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchGetAmapUsersCash = (
  variables: GetAmapUsersCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapUsersCashResponse,
    GetAmapUsersCashError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/users/cash", method: "get", ...variables, signal });

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export function getAmapUsersCashQuery(variables: GetAmapUsersCashVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAmapUsersCashResponse>;
};

export function getAmapUsersCashQuery(
  variables: GetAmapUsersCashVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAmapUsersCashResponse>)
    | reactQuery.SkipToken;
};

export function getAmapUsersCashQuery(
  variables: GetAmapUsersCashVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/users/cash",
      operationId: "getAmapUsersCash",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapUsersCash(variables, signal),
  };
}

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useSuspenseGetAmapUsersCash = <TData = GetAmapUsersCashResponse,>(
  variables: GetAmapUsersCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapUsersCashResponse,
      GetAmapUsersCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAmapUsersCashResponse,
    GetAmapUsersCashError,
    TData
  >({
    ...getAmapUsersCashQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const useGetAmapUsersCash = <TData = GetAmapUsersCashResponse,>(
  variables: GetAmapUsersCashVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapUsersCashResponse,
      GetAmapUsersCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapUsersCashResponse,
    GetAmapUsersCashError,
    TData
  >({
    ...getAmapUsersCashQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAmapUsersUserIdCashPathParams = {
  userId: string;
};

export type GetAmapUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapUsersUserIdCashVariables = {
  pathParams: GetAmapUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const fetchGetAmapUsersUserIdCash = (
  variables: GetAmapUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    GetAmapUsersUserIdCashError,
    undefined,
    {},
    {},
    GetAmapUsersUserIdCashPathParams
  >({ url: "/amap/users/{userId}/cash", method: "get", ...variables, signal });

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export function getAmapUsersUserIdCashQuery(
  variables: GetAmapUsersUserIdCashVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CashComplete>;
};

export function getAmapUsersUserIdCashQuery(
  variables: GetAmapUsersUserIdCashVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CashComplete>)
    | reactQuery.SkipToken;
};

export function getAmapUsersUserIdCashQuery(
  variables: GetAmapUsersUserIdCashVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/users/{userId}/cash",
      operationId: "getAmapUsersUserIdCash",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapUsersUserIdCash(variables, signal),
  };
}

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useSuspenseGetAmapUsersUserIdCash = <
  TData = Schemas.CashComplete,
>(
  variables: GetAmapUsersUserIdCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CashComplete,
      GetAmapUsersUserIdCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CashComplete,
    GetAmapUsersUserIdCashError,
    TData
  >({
    ...getAmapUsersUserIdCashQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useGetAmapUsersUserIdCash = <TData = Schemas.CashComplete,>(
  variables: GetAmapUsersUserIdCashVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CashComplete,
      GetAmapUsersUserIdCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CashComplete,
    GetAmapUsersUserIdCashError,
    TData
  >({
    ...getAmapUsersUserIdCashQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAmapUsersUserIdCashPathParams = {
  userId: string;
};

export type PostAmapUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAmapUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PostAmapUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create cash for an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPostAmapUsersUserIdCash = (
  variables: PostAmapUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    PostAmapUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PostAmapUsersUserIdCashPathParams
  >({ url: "/amap/users/{userId}/cash", method: "post", ...variables, signal });

/**
 * Create cash for an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePostAmapUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CashComplete,
      PostAmapUsersUserIdCashError,
      PostAmapUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CashComplete,
    PostAmapUsersUserIdCashError,
    PostAmapUsersUserIdCashVariables
  >({
    mutationFn: (variables: PostAmapUsersUserIdCashVariables) =>
      fetchPostAmapUsersUserIdCash(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchAmapUsersUserIdCashPathParams = {
  userId: string;
};

export type PatchAmapUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PatchAmapUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapUsersUserIdCash = (
  variables: PatchAmapUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PatchAmapUsersUserIdCashPathParams
  >({
    url: "/amap/users/{userId}/cash",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapUsersUserIdCashError,
      PatchAmapUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapUsersUserIdCashError,
    PatchAmapUsersUserIdCashVariables
  >({
    mutationFn: (variables: PatchAmapUsersUserIdCashVariables) =>
      fetchPatchAmapUsersUserIdCash(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAmapUsersUserIdOrdersPathParams = {
  userId: string;
};

export type GetAmapUsersUserIdOrdersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAmapUsersUserIdOrdersResponse = Schemas.OrderReturn[];

export type GetAmapUsersUserIdOrdersVariables = {
  pathParams: GetAmapUsersUserIdOrdersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const fetchGetAmapUsersUserIdOrders = (
  variables: GetAmapUsersUserIdOrdersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAmapUsersUserIdOrdersResponse,
    GetAmapUsersUserIdOrdersError,
    undefined,
    {},
    {},
    GetAmapUsersUserIdOrdersPathParams
  >({
    url: "/amap/users/{userId}/orders",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export function getAmapUsersUserIdOrdersQuery(
  variables: GetAmapUsersUserIdOrdersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetAmapUsersUserIdOrdersResponse>;
};

export function getAmapUsersUserIdOrdersQuery(
  variables: GetAmapUsersUserIdOrdersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAmapUsersUserIdOrdersResponse>)
    | reactQuery.SkipToken;
};

export function getAmapUsersUserIdOrdersQuery(
  variables: GetAmapUsersUserIdOrdersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/users/{userId}/orders",
      operationId: "getAmapUsersUserIdOrders",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapUsersUserIdOrders(variables, signal),
  };
}

/**
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useSuspenseGetAmapUsersUserIdOrders = <
  TData = GetAmapUsersUserIdOrdersResponse,
>(
  variables: GetAmapUsersUserIdOrdersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapUsersUserIdOrdersResponse,
      GetAmapUsersUserIdOrdersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAmapUsersUserIdOrdersResponse,
    GetAmapUsersUserIdOrdersError,
    TData
  >({
    ...getAmapUsersUserIdOrdersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get orders from an user.
 *
 * **The user must be a member of the group AMAP to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useGetAmapUsersUserIdOrders = <
  TData = GetAmapUsersUserIdOrdersResponse,
>(
  variables: GetAmapUsersUserIdOrdersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAmapUsersUserIdOrdersResponse,
      GetAmapUsersUserIdOrdersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAmapUsersUserIdOrdersResponse,
    GetAmapUsersUserIdOrdersError,
    TData
  >({
    ...getAmapUsersUserIdOrdersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAmapInformationError = Fetcher.ErrorWrapper<undefined>;

export type GetAmapInformationVariables = HyperionContext["fetcherOptions"];

/**
 * Return all information
 */
export const fetchGetAmapInformation = (
  variables: GetAmapInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Information,
    GetAmapInformationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/amap/information", method: "get", ...variables, signal });

/**
 * Return all information
 */
export function getAmapInformationQuery(
  variables: GetAmapInformationVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Information>;
};

export function getAmapInformationQuery(
  variables: GetAmapInformationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Information>)
    | reactQuery.SkipToken;
};

export function getAmapInformationQuery(
  variables: GetAmapInformationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/amap/information",
      operationId: "getAmapInformation",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAmapInformation(variables, signal),
  };
}

/**
 * Return all information
 */
export const useSuspenseGetAmapInformation = <TData = Schemas.Information,>(
  variables: GetAmapInformationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Information,
      GetAmapInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.Information,
    GetAmapInformationError,
    TData
  >({
    ...getAmapInformationQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all information
 */
export const useGetAmapInformation = <TData = Schemas.Information,>(
  variables: GetAmapInformationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Information,
      GetAmapInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.Information,
    GetAmapInformationError,
    TData
  >({
    ...getAmapInformationQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchAmapInformationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAmapInformationVariables = {
  body?: Schemas.InformationEdit;
} & HyperionContext["fetcherOptions"];

/**
 * Update information
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const fetchPatchAmapInformation = (
  variables: PatchAmapInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAmapInformationError,
    Schemas.InformationEdit,
    {},
    {},
    {}
  >({ url: "/amap/information", method: "patch", ...variables, signal });

/**
 * Update information
 *
 * **The user must be a member of the group AMAP to use this endpoint**
 */
export const usePatchAmapInformation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAmapInformationError,
      PatchAmapInformationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAmapInformationError,
    PatchAmapInformationVariables
  >({
    mutationFn: (variables: PatchAmapInformationVariables) =>
      fetchPatchAmapInformation(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetBookingManagersError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingManagersResponse = Schemas.Manager[];

export type GetBookingManagersVariables = HyperionContext["fetcherOptions"];

/**
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetBookingManagers = (
  variables: GetBookingManagersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingManagersResponse,
    GetBookingManagersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/managers", method: "get", ...variables, signal });

/**
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export function getBookingManagersQuery(
  variables: GetBookingManagersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetBookingManagersResponse>;
};

export function getBookingManagersQuery(
  variables: GetBookingManagersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetBookingManagersResponse>)
    | reactQuery.SkipToken;
};

export function getBookingManagersQuery(
  variables: GetBookingManagersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/managers",
      operationId: "getBookingManagers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingManagers(variables, signal),
  };
}

/**
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetBookingManagers = <
  TData = GetBookingManagersResponse,
>(
  variables: GetBookingManagersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingManagersResponse,
      GetBookingManagersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingManagersResponse,
    GetBookingManagersError,
    TData
  >({
    ...getBookingManagersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get existing managers.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetBookingManagers = <TData = GetBookingManagersResponse,>(
  variables: GetBookingManagersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingManagersResponse,
      GetBookingManagersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingManagersResponse,
    GetBookingManagersError,
    TData
  >({
    ...getBookingManagersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostBookingManagersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostBookingManagersVariables = {
  body: Schemas.ManagerBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a manager.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostBookingManagers = (
  variables: PostBookingManagersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Manager,
    PostBookingManagersError,
    Schemas.ManagerBase,
    {},
    {},
    {}
  >({ url: "/booking/managers", method: "post", ...variables, signal });

/**
 * Create a manager.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostBookingManagers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Manager,
      PostBookingManagersError,
      PostBookingManagersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Manager,
    PostBookingManagersError,
    PostBookingManagersVariables
  >({
    mutationFn: (variables: PostBookingManagersVariables) =>
      fetchPostBookingManagers(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchBookingManagersManagerIdPathParams = {
  managerId: string;
};

export type PatchBookingManagersManagerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchBookingManagersManagerIdVariables = {
  body?: Schemas.ManagerUpdate;
  pathParams: PatchBookingManagersManagerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a manager, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchBookingManagersManagerId = (
  variables: PatchBookingManagersManagerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingManagersManagerIdError,
    Schemas.ManagerUpdate,
    {},
    {},
    PatchBookingManagersManagerIdPathParams
  >({
    url: "/booking/managers/{managerId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a manager, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchBookingManagersManagerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingManagersManagerIdError,
      PatchBookingManagersManagerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingManagersManagerIdError,
    PatchBookingManagersManagerIdVariables
  >({
    mutationFn: (variables: PatchBookingManagersManagerIdVariables) =>
      fetchPatchBookingManagersManagerId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteBookingManagersManagerIdPathParams = {
  managerId: string;
};

export type DeleteBookingManagersManagerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteBookingManagersManagerIdVariables = {
  pathParams: DeleteBookingManagersManagerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a manager only if the manager is not linked to any room
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteBookingManagersManagerId = (
  variables: DeleteBookingManagersManagerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteBookingManagersManagerIdError,
    undefined,
    {},
    {},
    DeleteBookingManagersManagerIdPathParams
  >({
    url: "/booking/managers/{managerId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a manager only if the manager is not linked to any room
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteBookingManagersManagerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteBookingManagersManagerIdError,
      DeleteBookingManagersManagerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteBookingManagersManagerIdError,
    DeleteBookingManagersManagerIdVariables
  >({
    mutationFn: (variables: DeleteBookingManagersManagerIdVariables) =>
      fetchDeleteBookingManagersManagerId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetBookingManagersUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingManagersUsersMeResponse = Schemas.Manager[];

export type GetBookingManagersUsersMeVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingManagersUsersMe = (
  variables: GetBookingManagersUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingManagersUsersMeResponse,
    GetBookingManagersUsersMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/managers/users/me", method: "get", ...variables, signal });

/**
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getBookingManagersUsersMeQuery(
  variables: GetBookingManagersUsersMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetBookingManagersUsersMeResponse>;
};

export function getBookingManagersUsersMeQuery(
  variables: GetBookingManagersUsersMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetBookingManagersUsersMeResponse>)
    | reactQuery.SkipToken;
};

export function getBookingManagersUsersMeQuery(
  variables: GetBookingManagersUsersMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/managers/users/me",
      operationId: "getBookingManagersUsersMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingManagersUsersMe(variables, signal),
  };
}

/**
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetBookingManagersUsersMe = <
  TData = GetBookingManagersUsersMeResponse,
>(
  variables: GetBookingManagersUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingManagersUsersMeResponse,
      GetBookingManagersUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingManagersUsersMeResponse,
    GetBookingManagersUsersMeError,
    TData
  >({
    ...getBookingManagersUsersMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all managers the current user is a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingManagersUsersMe = <
  TData = GetBookingManagersUsersMeResponse,
>(
  variables: GetBookingManagersUsersMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingManagersUsersMeResponse,
      GetBookingManagersUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingManagersUsersMeResponse,
    GetBookingManagersUsersMeError,
    TData
  >({
    ...getBookingManagersUsersMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsUsersMeManageError =
  Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsUsersMeManageResponse =
  Schemas.BookingReturnApplicant[];

export type GetBookingBookingsUsersMeManageVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingBookingsUsersMeManage = (
  variables: GetBookingBookingsUsersMeManageVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsUsersMeManageResponse,
    GetBookingBookingsUsersMeManageError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/booking/bookings/users/me/manage",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getBookingBookingsUsersMeManageQuery(
  variables: GetBookingBookingsUsersMeManageVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetBookingBookingsUsersMeManageResponse>;
};

export function getBookingBookingsUsersMeManageQuery(
  variables: GetBookingBookingsUsersMeManageVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetBookingBookingsUsersMeManageResponse>)
    | reactQuery.SkipToken;
};

export function getBookingBookingsUsersMeManageQuery(
  variables: GetBookingBookingsUsersMeManageVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/bookings/users/me/manage",
      operationId: "getBookingBookingsUsersMeManage",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingBookingsUsersMeManage(variables, signal),
  };
}

/**
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetBookingBookingsUsersMeManage = <
  TData = GetBookingBookingsUsersMeManageResponse,
>(
  variables: GetBookingBookingsUsersMeManageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsUsersMeManageResponse,
      GetBookingBookingsUsersMeManageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingBookingsUsersMeManageResponse,
    GetBookingBookingsUsersMeManageError,
    TData
  >({
    ...getBookingBookingsUsersMeManageQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all bookings a user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingBookingsUsersMeManage = <
  TData = GetBookingBookingsUsersMeManageResponse,
>(
  variables: GetBookingBookingsUsersMeManageVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsUsersMeManageResponse,
      GetBookingBookingsUsersMeManageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsUsersMeManageResponse,
    GetBookingBookingsUsersMeManageError,
    TData
  >({
    ...getBookingBookingsUsersMeManageQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsConfirmedUsersMeManageError =
  Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsConfirmedUsersMeManageResponse =
  Schemas.BookingReturnApplicant[];

export type GetBookingBookingsConfirmedUsersMeManageVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingBookingsConfirmedUsersMeManage = (
  variables: GetBookingBookingsConfirmedUsersMeManageVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsConfirmedUsersMeManageResponse,
    GetBookingBookingsConfirmedUsersMeManageError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/booking/bookings/confirmed/users/me/manage",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export function getBookingBookingsConfirmedUsersMeManageQuery(
  variables: GetBookingBookingsConfirmedUsersMeManageVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetBookingBookingsConfirmedUsersMeManageResponse>;
};

export function getBookingBookingsConfirmedUsersMeManageQuery(
  variables:
    | GetBookingBookingsConfirmedUsersMeManageVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetBookingBookingsConfirmedUsersMeManageResponse>)
    | reactQuery.SkipToken;
};

export function getBookingBookingsConfirmedUsersMeManageQuery(
  variables:
    | GetBookingBookingsConfirmedUsersMeManageVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/bookings/confirmed/users/me/manage",
      operationId: "getBookingBookingsConfirmedUsersMeManage",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingBookingsConfirmedUsersMeManage(variables, signal),
  };
}

/**
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetBookingBookingsConfirmedUsersMeManage = <
  TData = GetBookingBookingsConfirmedUsersMeManageResponse,
>(
  variables: GetBookingBookingsConfirmedUsersMeManageVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsConfirmedUsersMeManageResponse,
      GetBookingBookingsConfirmedUsersMeManageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingBookingsConfirmedUsersMeManageResponse,
    GetBookingBookingsConfirmedUsersMeManageError,
    TData
  >({
    ...getBookingBookingsConfirmedUsersMeManageQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all confirmed bookings a user can manage.
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingBookingsConfirmedUsersMeManage = <
  TData = GetBookingBookingsConfirmedUsersMeManageResponse,
>(
  variables:
    | GetBookingBookingsConfirmedUsersMeManageVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsConfirmedUsersMeManageResponse,
      GetBookingBookingsConfirmedUsersMeManageError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsConfirmedUsersMeManageResponse,
    GetBookingBookingsConfirmedUsersMeManageError,
    TData
  >({
    ...getBookingBookingsConfirmedUsersMeManageQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsConfirmedError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsConfirmedResponse =
  Schemas.BookingReturnSimpleApplicant[];

export type GetBookingBookingsConfirmedVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingBookingsConfirmed = (
  variables: GetBookingBookingsConfirmedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsConfirmedResponse,
    GetBookingBookingsConfirmedError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/booking/bookings/confirmed",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getBookingBookingsConfirmedQuery(
  variables: GetBookingBookingsConfirmedVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetBookingBookingsConfirmedResponse>;
};

export function getBookingBookingsConfirmedQuery(
  variables: GetBookingBookingsConfirmedVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetBookingBookingsConfirmedResponse>)
    | reactQuery.SkipToken;
};

export function getBookingBookingsConfirmedQuery(
  variables: GetBookingBookingsConfirmedVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/bookings/confirmed",
      operationId: "getBookingBookingsConfirmed",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingBookingsConfirmed(variables, signal),
  };
}

/**
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetBookingBookingsConfirmed = <
  TData = GetBookingBookingsConfirmedResponse,
>(
  variables: GetBookingBookingsConfirmedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsConfirmedResponse,
      GetBookingBookingsConfirmedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingBookingsConfirmedResponse,
    GetBookingBookingsConfirmedError,
    TData
  >({
    ...getBookingBookingsConfirmedQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all confirmed bookings.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingBookingsConfirmed = <
  TData = GetBookingBookingsConfirmedResponse,
>(
  variables: GetBookingBookingsConfirmedVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsConfirmedResponse,
      GetBookingBookingsConfirmedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsConfirmedResponse,
    GetBookingBookingsConfirmedError,
    TData
  >({
    ...getBookingBookingsConfirmedQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetBookingBookingsUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingBookingsUsersMeResponse = Schemas.BookingReturn[];

export type GetBookingBookingsUsersMeVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export const fetchGetBookingBookingsUsersMe = (
  variables: GetBookingBookingsUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingBookingsUsersMeResponse,
    GetBookingBookingsUsersMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/bookings/users/me", method: "get", ...variables, signal });

/**
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export function getBookingBookingsUsersMeQuery(
  variables: GetBookingBookingsUsersMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetBookingBookingsUsersMeResponse>;
};

export function getBookingBookingsUsersMeQuery(
  variables: GetBookingBookingsUsersMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetBookingBookingsUsersMeResponse>)
    | reactQuery.SkipToken;
};

export function getBookingBookingsUsersMeQuery(
  variables: GetBookingBookingsUsersMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/bookings/users/me",
      operationId: "getBookingBookingsUsersMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingBookingsUsersMe(variables, signal),
  };
}

/**
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export const useSuspenseGetBookingBookingsUsersMe = <
  TData = GetBookingBookingsUsersMeResponse,
>(
  variables: GetBookingBookingsUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsUsersMeResponse,
      GetBookingBookingsUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingBookingsUsersMeResponse,
    GetBookingBookingsUsersMeError,
    TData
  >({
    ...getBookingBookingsUsersMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the user bookings.
 *
 * **Only usable by the user**
 */
export const useGetBookingBookingsUsersMe = <
  TData = GetBookingBookingsUsersMeResponse,
>(
  variables: GetBookingBookingsUsersMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingBookingsUsersMeResponse,
      GetBookingBookingsUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingBookingsUsersMeResponse,
    GetBookingBookingsUsersMeError,
    TData
  >({
    ...getBookingBookingsUsersMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostBookingBookingsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostBookingBookingsVariables = {
  body: Schemas.BookingBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a booking.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostBookingBookings = (
  variables: PostBookingBookingsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.BookingReturn,
    PostBookingBookingsError,
    Schemas.BookingBase,
    {},
    {},
    {}
  >({ url: "/booking/bookings", method: "post", ...variables, signal });

/**
 * Create a booking.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostBookingBookings = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BookingReturn,
      PostBookingBookingsError,
      PostBookingBookingsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.BookingReturn,
    PostBookingBookingsError,
    PostBookingBookingsVariables
  >({
    mutationFn: (variables: PostBookingBookingsVariables) =>
      fetchPostBookingBookings(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchBookingBookingsBookingIdPathParams = {
  bookingId: string;
};

export type PatchBookingBookingsBookingIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchBookingBookingsBookingIdVariables = {
  body?: Schemas.BookingEdit;
  pathParams: PatchBookingBookingsBookingIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a booking.
 *
 * **Only usable by a user in the manager group of the booking or applicant before decision**
 */
export const fetchPatchBookingBookingsBookingId = (
  variables: PatchBookingBookingsBookingIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingBookingsBookingIdError,
    Schemas.BookingEdit,
    {},
    {},
    PatchBookingBookingsBookingIdPathParams
  >({
    url: "/booking/bookings/{bookingId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a booking.
 *
 * **Only usable by a user in the manager group of the booking or applicant before decision**
 */
export const usePatchBookingBookingsBookingId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingBookingsBookingIdError,
      PatchBookingBookingsBookingIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingBookingsBookingIdError,
    PatchBookingBookingsBookingIdVariables
  >({
    mutationFn: (variables: PatchBookingBookingsBookingIdVariables) =>
      fetchPatchBookingBookingsBookingId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteBookingBookingsBookingIdPathParams = {
  bookingId: string;
};

export type DeleteBookingBookingsBookingIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteBookingBookingsBookingIdVariables = {
  pathParams: DeleteBookingBookingsBookingIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a booking.
 *
 * **Only usable by the applicant before decision**
 */
export const fetchDeleteBookingBookingsBookingId = (
  variables: DeleteBookingBookingsBookingIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteBookingBookingsBookingIdError,
    undefined,
    {},
    {},
    DeleteBookingBookingsBookingIdPathParams
  >({
    url: "/booking/bookings/{bookingId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a booking.
 *
 * **Only usable by the applicant before decision**
 */
export const useDeleteBookingBookingsBookingId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteBookingBookingsBookingIdError,
      DeleteBookingBookingsBookingIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteBookingBookingsBookingIdError,
    DeleteBookingBookingsBookingIdVariables
  >({
    mutationFn: (variables: DeleteBookingBookingsBookingIdVariables) =>
      fetchDeleteBookingBookingsBookingId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchBookingBookingsBookingIdReplyDecisionPathParams = {
  bookingId: string;
  decision: Schemas.Decision;
};

export type PatchBookingBookingsBookingIdReplyDecisionError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchBookingBookingsBookingIdReplyDecisionVariables = {
  pathParams: PatchBookingBookingsBookingIdReplyDecisionPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Give a decision to a booking.
 *
 * **Only usable by a user in the manager group of the booking**
 */
export const fetchPatchBookingBookingsBookingIdReplyDecision = (
  variables: PatchBookingBookingsBookingIdReplyDecisionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingBookingsBookingIdReplyDecisionError,
    undefined,
    {},
    {},
    PatchBookingBookingsBookingIdReplyDecisionPathParams
  >({
    url: "/booking/bookings/{bookingId}/reply/{decision}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Give a decision to a booking.
 *
 * **Only usable by a user in the manager group of the booking**
 */
export const usePatchBookingBookingsBookingIdReplyDecision = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingBookingsBookingIdReplyDecisionError,
      PatchBookingBookingsBookingIdReplyDecisionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingBookingsBookingIdReplyDecisionError,
    PatchBookingBookingsBookingIdReplyDecisionVariables
  >({
    mutationFn: (
      variables: PatchBookingBookingsBookingIdReplyDecisionVariables,
    ) =>
      fetchPatchBookingBookingsBookingIdReplyDecision(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetBookingRoomsError = Fetcher.ErrorWrapper<undefined>;

export type GetBookingRoomsResponse = Schemas.RoomComplete[];

export type GetBookingRoomsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetBookingRooms = (
  variables: GetBookingRoomsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetBookingRoomsResponse,
    GetBookingRoomsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/booking/rooms", method: "get", ...variables, signal });

/**
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getBookingRoomsQuery(variables: GetBookingRoomsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetBookingRoomsResponse>;
};

export function getBookingRoomsQuery(
  variables: GetBookingRoomsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetBookingRoomsResponse>)
    | reactQuery.SkipToken;
};

export function getBookingRoomsQuery(
  variables: GetBookingRoomsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/booking/rooms",
      operationId: "getBookingRooms",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetBookingRooms(variables, signal),
  };
}

/**
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetBookingRooms = <TData = GetBookingRoomsResponse,>(
  variables: GetBookingRoomsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingRoomsResponse,
      GetBookingRoomsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetBookingRoomsResponse,
    GetBookingRoomsError,
    TData
  >({
    ...getBookingRoomsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all rooms.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetBookingRooms = <TData = GetBookingRoomsResponse,>(
  variables: GetBookingRoomsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetBookingRoomsResponse,
      GetBookingRoomsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetBookingRoomsResponse,
    GetBookingRoomsError,
    TData
  >({
    ...getBookingRoomsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostBookingRoomsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostBookingRoomsVariables = {
  body: Schemas.RoomBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new room in database.
 *
 * **This endpoint is only usable by admins**
 */
export const fetchPostBookingRooms = (
  variables: PostBookingRoomsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RoomComplete,
    PostBookingRoomsError,
    Schemas.RoomBase,
    {},
    {},
    {}
  >({ url: "/booking/rooms", method: "post", ...variables, signal });

/**
 * Create a new room in database.
 *
 * **This endpoint is only usable by admins**
 */
export const usePostBookingRooms = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RoomComplete,
      PostBookingRoomsError,
      PostBookingRoomsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RoomComplete,
    PostBookingRoomsError,
    PostBookingRoomsVariables
  >({
    mutationFn: (variables: PostBookingRoomsVariables) =>
      fetchPostBookingRooms(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchBookingRoomsRoomIdPathParams = {
  roomId: string;
};

export type PatchBookingRoomsRoomIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchBookingRoomsRoomIdVariables = {
  body: Schemas.RoomBase;
  pathParams: PatchBookingRoomsRoomIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a room.
 *
 * **This endpoint is only usable by admins**
 */
export const fetchPatchBookingRoomsRoomId = (
  variables: PatchBookingRoomsRoomIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchBookingRoomsRoomIdError,
    Schemas.RoomBase,
    {},
    {},
    PatchBookingRoomsRoomIdPathParams
  >({ url: "/booking/rooms/{roomId}", method: "patch", ...variables, signal });

/**
 * Edit a room.
 *
 * **This endpoint is only usable by admins**
 */
export const usePatchBookingRoomsRoomId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchBookingRoomsRoomIdError,
      PatchBookingRoomsRoomIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchBookingRoomsRoomIdError,
    PatchBookingRoomsRoomIdVariables
  >({
    mutationFn: (variables: PatchBookingRoomsRoomIdVariables) =>
      fetchPatchBookingRoomsRoomId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteBookingRoomsRoomIdPathParams = {
  roomId: string;
};

export type DeleteBookingRoomsRoomIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteBookingRoomsRoomIdVariables = {
  pathParams: DeleteBookingRoomsRoomIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a room only if there are not future or ongoing bookings of this room
 *
 * **This endpoint is only usable by admins**
 */
export const fetchDeleteBookingRoomsRoomId = (
  variables: DeleteBookingRoomsRoomIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteBookingRoomsRoomIdError,
    undefined,
    {},
    {},
    DeleteBookingRoomsRoomIdPathParams
  >({ url: "/booking/rooms/{roomId}", method: "delete", ...variables, signal });

/**
 * Delete a room only if there are not future or ongoing bookings of this room
 *
 * **This endpoint is only usable by admins**
 */
export const useDeleteBookingRoomsRoomId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteBookingRoomsRoomIdError,
      DeleteBookingRoomsRoomIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteBookingRoomsRoomIdError,
    DeleteBookingRoomsRoomIdVariables
  >({
    mutationFn: (variables: DeleteBookingRoomsRoomIdVariables) =>
      fetchDeleteBookingRoomsRoomId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCampaignSectionsError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignSectionsResponse = Schemas.SectionComplete[];

export type GetCampaignSectionsVariables = HyperionContext["fetcherOptions"];

/**
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignSections = (
  variables: GetCampaignSectionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignSectionsResponse,
    GetCampaignSectionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/sections", method: "get", ...variables, signal });

/**
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export function getCampaignSectionsQuery(
  variables: GetCampaignSectionsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCampaignSectionsResponse>;
};

export function getCampaignSectionsQuery(
  variables: GetCampaignSectionsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCampaignSectionsResponse>)
    | reactQuery.SkipToken;
};

export function getCampaignSectionsQuery(
  variables: GetCampaignSectionsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/sections",
      operationId: "getCampaignSections",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignSections(variables, signal),
  };
}

/**
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useSuspenseGetCampaignSections = <
  TData = GetCampaignSectionsResponse,
>(
  variables: GetCampaignSectionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignSectionsResponse,
      GetCampaignSectionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCampaignSectionsResponse,
    GetCampaignSectionsError,
    TData
  >({
    ...getCampaignSectionsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return sections in the database as a list of `schemas_campaign.SectionBase`
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignSections = <TData = GetCampaignSectionsResponse,>(
  variables: GetCampaignSectionsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignSectionsResponse,
      GetCampaignSectionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignSectionsResponse,
    GetCampaignSectionsError,
    TData
  >({
    ...getCampaignSectionsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignSectionsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignSectionsVariables = {
  body: Schemas.SectionBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignSections = (
  variables: PostCampaignSectionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SectionComplete,
    PostCampaignSectionsError,
    Schemas.SectionBase,
    {},
    {},
    {}
  >({ url: "/campaign/sections", method: "post", ...variables, signal });

/**
 * Add a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignSections = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SectionComplete,
      PostCampaignSectionsError,
      PostCampaignSectionsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SectionComplete,
    PostCampaignSectionsError,
    PostCampaignSectionsVariables
  >({
    mutationFn: (variables: PostCampaignSectionsVariables) =>
      fetchPostCampaignSections(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCampaignSectionsSectionIdPathParams = {
  sectionId: string;
};

export type DeleteCampaignSectionsSectionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignSectionsSectionIdVariables = {
  pathParams: DeleteCampaignSectionsSectionIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignSectionsSectionId = (
  variables: DeleteCampaignSectionsSectionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignSectionsSectionIdError,
    undefined,
    {},
    {},
    DeleteCampaignSectionsSectionIdPathParams
  >({
    url: "/campaign/sections/{sectionId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignSectionsSectionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignSectionsSectionIdError,
      DeleteCampaignSectionsSectionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignSectionsSectionIdError,
    DeleteCampaignSectionsSectionIdVariables
  >({
    mutationFn: (variables: DeleteCampaignSectionsSectionIdVariables) =>
      fetchDeleteCampaignSectionsSectionId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCampaignListsError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignListsResponse = Schemas.ListReturn[];

export type GetCampaignListsVariables = HyperionContext["fetcherOptions"];

/**
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignLists = (
  variables: GetCampaignListsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignListsResponse,
    GetCampaignListsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/lists", method: "get", ...variables, signal });

/**
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export function getCampaignListsQuery(variables: GetCampaignListsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCampaignListsResponse>;
};

export function getCampaignListsQuery(
  variables: GetCampaignListsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCampaignListsResponse>)
    | reactQuery.SkipToken;
};

export function getCampaignListsQuery(
  variables: GetCampaignListsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/lists",
      operationId: "getCampaignLists",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignLists(variables, signal),
  };
}

/**
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useSuspenseGetCampaignLists = <TData = GetCampaignListsResponse,>(
  variables: GetCampaignListsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignListsResponse,
      GetCampaignListsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCampaignListsResponse,
    GetCampaignListsError,
    TData
  >({
    ...getCampaignListsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return campaign lists registered for the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignLists = <TData = GetCampaignListsResponse,>(
  variables: GetCampaignListsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignListsResponse,
      GetCampaignListsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignListsResponse,
    GetCampaignListsError,
    TData
  >({
    ...getCampaignListsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignListsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignListsVariables = {
  body: Schemas.ListBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add a campaign list to a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignLists = (
  variables: PostCampaignListsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.ListReturn,
    PostCampaignListsError,
    Schemas.ListBase,
    {},
    {},
    {}
  >({ url: "/campaign/lists", method: "post", ...variables, signal });

/**
 * Add a campaign list to a section.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignLists = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ListReturn,
      PostCampaignListsError,
      PostCampaignListsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.ListReturn,
    PostCampaignListsError,
    PostCampaignListsVariables
  >({
    mutationFn: (variables: PostCampaignListsVariables) =>
      fetchPostCampaignLists(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCampaignListsListIdPathParams = {
  listId: string;
};

export type DeleteCampaignListsListIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignListsListIdVariables = {
  pathParams: DeleteCampaignListsListIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignListsListId = (
  variables: DeleteCampaignListsListIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignListsListIdError,
    undefined,
    {},
    {},
    DeleteCampaignListsListIdPathParams
  >({
    url: "/campaign/lists/{listId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignListsListId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignListsListIdError,
      DeleteCampaignListsListIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignListsListIdError,
    DeleteCampaignListsListIdVariables
  >({
    mutationFn: (variables: DeleteCampaignListsListIdVariables) =>
      fetchDeleteCampaignListsListId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchCampaignListsListIdPathParams = {
  listId: string;
};

export type PatchCampaignListsListIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCampaignListsListIdVariables = {
  body?: Schemas.ListEdit;
  pathParams: PatchCampaignListsListIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPatchCampaignListsListId = (
  variables: PatchCampaignListsListIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCampaignListsListIdError,
    Schemas.ListEdit,
    {},
    {},
    PatchCampaignListsListIdPathParams
  >({ url: "/campaign/lists/{listId}", method: "patch", ...variables, signal });

/**
 * Update the campaign list with the given id.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePatchCampaignListsListId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCampaignListsListIdError,
      PatchCampaignListsListIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCampaignListsListIdError,
    PatchCampaignListsListIdVariables
  >({
    mutationFn: (variables: PatchCampaignListsListIdVariables) =>
      fetchPatchCampaignListsListId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCampaignListsQueryParams = {
  list_type?: Schemas.ListType | null;
};

export type DeleteCampaignListsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignListsVariables = {
  queryParams?: DeleteCampaignListsQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete the all lists by type.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignLists = (
  variables: DeleteCampaignListsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignListsError,
    undefined,
    {},
    DeleteCampaignListsQueryParams,
    {}
  >({ url: "/campaign/lists/", method: "delete", ...variables, signal });

/**
 * Delete the all lists by type.
 *
 * This endpoint can only be used in 'waiting' status.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignLists = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignListsError,
      DeleteCampaignListsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignListsError,
    DeleteCampaignListsVariables
  >({
    mutationFn: (variables: DeleteCampaignListsVariables) =>
      fetchDeleteCampaignLists(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCampaignVotersError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignVotersResponse = Schemas.VoterGroup[];

export type GetCampaignVotersVariables = HyperionContext["fetcherOptions"];

/**
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export const fetchGetCampaignVoters = (
  variables: GetCampaignVotersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignVotersResponse,
    GetCampaignVotersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/voters", method: "get", ...variables, signal });

/**
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export function getCampaignVotersQuery(variables: GetCampaignVotersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCampaignVotersResponse>;
};

export function getCampaignVotersQuery(
  variables: GetCampaignVotersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCampaignVotersResponse>)
    | reactQuery.SkipToken;
};

export function getCampaignVotersQuery(
  variables: GetCampaignVotersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/voters",
      operationId: "getCampaignVoters",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignVoters(variables, signal),
  };
}

/**
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export const useSuspenseGetCampaignVoters = <
  TData = GetCampaignVotersResponse,
>(
  variables: GetCampaignVotersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignVotersResponse,
      GetCampaignVotersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCampaignVotersResponse,
    GetCampaignVotersError,
    TData
  >({
    ...getCampaignVotersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the voters (groups allowed to vote) for the current campaign.
 */
export const useGetCampaignVoters = <TData = GetCampaignVotersResponse,>(
  variables: GetCampaignVotersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignVotersResponse,
      GetCampaignVotersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignVotersResponse,
    GetCampaignVotersError,
    TData
  >({
    ...getCampaignVotersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignVotersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignVotersVariables = {
  body: Schemas.VoterGroup;
} & HyperionContext["fetcherOptions"];

/**
 * Add voters (groups allowed to vote) for this campaign
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignVoters = (
  variables: PostCampaignVotersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.VoterGroup,
    PostCampaignVotersError,
    Schemas.VoterGroup,
    {},
    {},
    {}
  >({ url: "/campaign/voters", method: "post", ...variables, signal });

/**
 * Add voters (groups allowed to vote) for this campaign
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignVoters = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.VoterGroup,
      PostCampaignVotersError,
      PostCampaignVotersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.VoterGroup,
    PostCampaignVotersError,
    PostCampaignVotersVariables
  >({
    mutationFn: (variables: PostCampaignVotersVariables) =>
      fetchPostCampaignVoters(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCampaignVotersError = Fetcher.ErrorWrapper<undefined>;

export type DeleteCampaignVotersVariables = HyperionContext["fetcherOptions"];

/**
 * Remove voters (groups allowed to vote)
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignVoters = (
  variables: DeleteCampaignVotersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, DeleteCampaignVotersError, undefined, {}, {}, {}>({
    url: "/campaign/voters",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove voters (groups allowed to vote)
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignVoters = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignVotersError,
      DeleteCampaignVotersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignVotersError,
    DeleteCampaignVotersVariables
  >({
    mutationFn: (variables: DeleteCampaignVotersVariables) =>
      fetchDeleteCampaignVoters(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCampaignVotersGroupIdPathParams = {
  groupId: string;
};

export type DeleteCampaignVotersGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCampaignVotersGroupIdVariables = {
  pathParams: DeleteCampaignVotersGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a voter by its group id
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchDeleteCampaignVotersGroupId = (
  variables: DeleteCampaignVotersGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCampaignVotersGroupIdError,
    undefined,
    {},
    {},
    DeleteCampaignVotersGroupIdPathParams
  >({
    url: "/campaign/voters/{groupId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a voter by its group id
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useDeleteCampaignVotersGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCampaignVotersGroupIdError,
      DeleteCampaignVotersGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCampaignVotersGroupIdError,
    DeleteCampaignVotersGroupIdVariables
  >({
    mutationFn: (variables: DeleteCampaignVotersGroupIdVariables) =>
      fetchDeleteCampaignVotersGroupId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostCampaignStatusOpenError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusOpenVariables = HyperionContext["fetcherOptions"];

/**
 * If the status is 'waiting', change it to 'voting' and create the blank lists.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'open', all users can vote and sections and lists can no longer be edited.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusOpen = (
  variables: PostCampaignStatusOpenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCampaignStatusOpenError, undefined, {}, {}, {}>({
    url: "/campaign/status/open",
    method: "post",
    ...variables,
    signal,
  });

/**
 * If the status is 'waiting', change it to 'voting' and create the blank lists.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'open', all users can vote and sections and lists can no longer be edited.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusOpen = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusOpenError,
      PostCampaignStatusOpenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusOpenError,
    PostCampaignStatusOpenVariables
  >({
    mutationFn: (variables: PostCampaignStatusOpenVariables) =>
      fetchPostCampaignStatusOpen(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostCampaignStatusCloseError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusCloseVariables =
  HyperionContext["fetcherOptions"];

/**
 * If the status is 'open', change it to 'closed'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'closed', users are no longer able to vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusClose = (
  variables: PostCampaignStatusCloseVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCampaignStatusCloseError, undefined, {}, {}, {}>(
    { url: "/campaign/status/close", method: "post", ...variables, signal },
  );

/**
 * If the status is 'open', change it to 'closed'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'closed', users are no longer able to vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusClose = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusCloseError,
      PostCampaignStatusCloseVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusCloseError,
    PostCampaignStatusCloseVariables
  >({
    mutationFn: (variables: PostCampaignStatusCloseVariables) =>
      fetchPostCampaignStatusClose(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostCampaignStatusCountingError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusCountingVariables =
  HyperionContext["fetcherOptions"];

/**
 * If the status is 'closed', change it to 'counting'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'counting', administrators can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusCounting = (
  variables: PostCampaignStatusCountingVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCampaignStatusCountingError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/status/counting", method: "post", ...variables, signal });

/**
 * If the status is 'closed', change it to 'counting'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'counting', administrators can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusCounting = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusCountingError,
      PostCampaignStatusCountingVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusCountingError,
    PostCampaignStatusCountingVariables
  >({
    mutationFn: (variables: PostCampaignStatusCountingVariables) =>
      fetchPostCampaignStatusCounting(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostCampaignStatusPublishedError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusPublishedVariables =
  HyperionContext["fetcherOptions"];

/**
 * If the status is 'counting', change it to 'published'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'published', everyone can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusPublished = (
  variables: PostCampaignStatusPublishedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCampaignStatusPublishedError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/campaign/status/published",
    method: "post",
    ...variables,
    signal,
  });

/**
 * If the status is 'counting', change it to 'published'.
 *
 * > WARNING: this operation can not be reversed.
 * > When the status is 'published', everyone can see the results of the vote.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusPublished = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusPublishedError,
      PostCampaignStatusPublishedVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusPublishedError,
    PostCampaignStatusPublishedVariables
  >({
    mutationFn: (variables: PostCampaignStatusPublishedVariables) =>
      fetchPostCampaignStatusPublished(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostCampaignStatusResetError = Fetcher.ErrorWrapper<undefined>;

export type PostCampaignStatusResetVariables =
  HyperionContext["fetcherOptions"];

/**
 * Reset the vote. Can only be used if the current status is counting ou published.
 *
 * > WARNING: This will delete all votes then put the module to Waiting status. This will also delete blank lists.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignStatusReset = (
  variables: PostCampaignStatusResetVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCampaignStatusResetError, undefined, {}, {}, {}>(
    { url: "/campaign/status/reset", method: "post", ...variables, signal },
  );

/**
 * Reset the vote. Can only be used if the current status is counting ou published.
 *
 * > WARNING: This will delete all votes then put the module to Waiting status. This will also delete blank lists.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignStatusReset = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignStatusResetError,
      PostCampaignStatusResetVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignStatusResetError,
    PostCampaignStatusResetVariables
  >({
    mutationFn: (variables: PostCampaignStatusResetVariables) =>
      fetchPostCampaignStatusReset(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCampaignVotesError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignVotesResponse = string[];

export type GetCampaignVotesVariables = HyperionContext["fetcherOptions"];

/**
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const fetchGetCampaignVotes = (
  variables: GetCampaignVotesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignVotesResponse,
    GetCampaignVotesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/votes", method: "get", ...variables, signal });

/**
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export function getCampaignVotesQuery(variables: GetCampaignVotesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCampaignVotesResponse>;
};

export function getCampaignVotesQuery(
  variables: GetCampaignVotesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCampaignVotesResponse>)
    | reactQuery.SkipToken;
};

export function getCampaignVotesQuery(
  variables: GetCampaignVotesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/votes",
      operationId: "getCampaignVotes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignVotes(variables, signal),
  };
}

/**
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const useSuspenseGetCampaignVotes = <TData = GetCampaignVotesResponse,>(
  variables: GetCampaignVotesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignVotesResponse,
      GetCampaignVotesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCampaignVotesResponse,
    GetCampaignVotesError,
    TData
  >({
    ...getCampaignVotesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the list of id of sections an user has already voted for.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const useGetCampaignVotes = <TData = GetCampaignVotesResponse,>(
  variables: GetCampaignVotesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignVotesResponse,
      GetCampaignVotesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignVotesResponse,
    GetCampaignVotesError,
    TData
  >({
    ...getCampaignVotesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignVotesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignVotesVariables = {
  body: Schemas.VoteBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add a vote for a given campaign list.
 *
 * An user can only vote for one list per section.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const fetchPostCampaignVotes = (
  variables: PostCampaignVotesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCampaignVotesError,
    Schemas.VoteBase,
    {},
    {},
    {}
  >({ url: "/campaign/votes", method: "post", ...variables, signal });

/**
 * Add a vote for a given campaign list.
 *
 * An user can only vote for one list per section.
 *
 * **The user must be a member of a group authorized to vote (voters) to use this endpoint**
 */
export const usePostCampaignVotes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCampaignVotesError,
      PostCampaignVotesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCampaignVotesError,
    PostCampaignVotesVariables
  >({
    mutationFn: (variables: PostCampaignVotesVariables) =>
      fetchPostCampaignVotes(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCampaignResultsError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignResultsResponse =
  Schemas.AppModulesCampaignSchemasCampaignResult[];

export type GetCampaignResultsVariables = HyperionContext["fetcherOptions"];

/**
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignResults = (
  variables: GetCampaignResultsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCampaignResultsResponse,
    GetCampaignResultsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/results", method: "get", ...variables, signal });

/**
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export function getCampaignResultsQuery(
  variables: GetCampaignResultsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCampaignResultsResponse>;
};

export function getCampaignResultsQuery(
  variables: GetCampaignResultsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCampaignResultsResponse>)
    | reactQuery.SkipToken;
};

export function getCampaignResultsQuery(
  variables: GetCampaignResultsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/results",
      operationId: "getCampaignResults",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignResults(variables, signal),
  };
}

/**
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useSuspenseGetCampaignResults = <
  TData = GetCampaignResultsResponse,
>(
  variables: GetCampaignResultsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignResultsResponse,
      GetCampaignResultsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCampaignResultsResponse,
    GetCampaignResultsError,
    TData
  >({
    ...getCampaignResultsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the results of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignResults = <TData = GetCampaignResultsResponse,>(
  variables: GetCampaignResultsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCampaignResultsResponse,
      GetCampaignResultsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCampaignResultsResponse,
    GetCampaignResultsError,
    TData
  >({
    ...getCampaignResultsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCampaignStatusError = Fetcher.ErrorWrapper<undefined>;

export type GetCampaignStatusVariables = HyperionContext["fetcherOptions"];

/**
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignStatus = (
  variables: GetCampaignStatusVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.VoteStatus,
    GetCampaignStatusError,
    undefined,
    {},
    {},
    {}
  >({ url: "/campaign/status", method: "get", ...variables, signal });

/**
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export function getCampaignStatusQuery(variables: GetCampaignStatusVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.VoteStatus>;
};

export function getCampaignStatusQuery(
  variables: GetCampaignStatusVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.VoteStatus>)
    | reactQuery.SkipToken;
};

export function getCampaignStatusQuery(
  variables: GetCampaignStatusVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/status",
      operationId: "getCampaignStatus",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignStatus(variables, signal),
  };
}

/**
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useSuspenseGetCampaignStatus = <TData = Schemas.VoteStatus,>(
  variables: GetCampaignStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VoteStatus,
      GetCampaignStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.VoteStatus,
    GetCampaignStatusError,
    TData
  >({
    ...getCampaignStatusQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the current status of the vote.
 *
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignStatus = <TData = Schemas.VoteStatus,>(
  variables: GetCampaignStatusVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VoteStatus,
      GetCampaignStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.VoteStatus, GetCampaignStatusError, TData>(
    {
      ...getCampaignStatusQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetCampaignStatsSectionIdPathParams = {
  sectionId: string;
};

export type GetCampaignStatsSectionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCampaignStatsSectionIdVariables = {
  pathParams: GetCampaignStatsSectionIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignStatsSectionId = (
  variables: GetCampaignStatsSectionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.VoteStats,
    GetCampaignStatsSectionIdError,
    undefined,
    {},
    {},
    GetCampaignStatsSectionIdPathParams
  >({
    url: "/campaign/stats/{sectionId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export function getCampaignStatsSectionIdQuery(
  variables: GetCampaignStatsSectionIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.VoteStats>;
};

export function getCampaignStatsSectionIdQuery(
  variables: GetCampaignStatsSectionIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.VoteStats>)
    | reactQuery.SkipToken;
};

export function getCampaignStatsSectionIdQuery(
  variables: GetCampaignStatsSectionIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/stats/{sectionId}",
      operationId: "getCampaignStatsSectionId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignStatsSectionId(variables, signal),
  };
}

/**
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useSuspenseGetCampaignStatsSectionId = <
  TData = Schemas.VoteStats,
>(
  variables: GetCampaignStatsSectionIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VoteStats,
      GetCampaignStatsSectionIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.VoteStats,
    GetCampaignStatsSectionIdError,
    TData
  >({
    ...getCampaignStatsSectionIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get stats about a given section.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const useGetCampaignStatsSectionId = <TData = Schemas.VoteStats,>(
  variables: GetCampaignStatsSectionIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.VoteStats,
      GetCampaignStatsSectionIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.VoteStats,
    GetCampaignStatsSectionIdError,
    TData
  >({
    ...getCampaignStatsSectionIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCampaignListsListIdLogoPathParams = {
  listId: string;
};

export type PostCampaignListsListIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCampaignListsListIdLogoVariables = {
  body: Schemas.BodyCreateCampaignsLogoCampaignListsListIdLogoPost;
  pathParams: PostCampaignListsListIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for a campaign list.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const fetchPostCampaignListsListIdLogo = (
  variables: PostCampaignListsListIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostCampaignListsListIdLogoError,
    Schemas.BodyCreateCampaignsLogoCampaignListsListIdLogoPost,
    {},
    {},
    PostCampaignListsListIdLogoPathParams
  >({
    url: "/campaign/lists/{listId}/logo",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for a campaign list.
 *
 * **The user must be a member of the group CAA to use this endpoint**
 */
export const usePostCampaignListsListIdLogo = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostCampaignListsListIdLogoError,
      PostCampaignListsListIdLogoVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostCampaignListsListIdLogoError,
    PostCampaignListsListIdLogoVariables
  >({
    mutationFn: (variables: PostCampaignListsListIdLogoVariables) =>
      fetchPostCampaignListsListIdLogo(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCampaignListsListIdLogoPathParams = {
  listId: string;
};

export type GetCampaignListsListIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCampaignListsListIdLogoVariables = {
  pathParams: GetCampaignListsListIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const fetchGetCampaignListsListIdLogo = (
  variables: GetCampaignListsListIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetCampaignListsListIdLogoError,
    undefined,
    {},
    {},
    GetCampaignListsListIdLogoPathParams
  >({
    url: "/campaign/lists/{listId}/logo",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export function getCampaignListsListIdLogoQuery(
  variables: GetCampaignListsListIdLogoVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getCampaignListsListIdLogoQuery(
  variables: GetCampaignListsListIdLogoVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getCampaignListsListIdLogoQuery(
  variables: GetCampaignListsListIdLogoVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/campaign/lists/{listId}/logo",
      operationId: "getCampaignListsListIdLogo",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCampaignListsListIdLogo(variables, signal),
  };
}

/**
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useSuspenseGetCampaignListsListIdLogo = <TData = undefined,>(
  variables: GetCampaignListsListIdLogoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCampaignListsListIdLogoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetCampaignListsListIdLogoError,
    TData
  >({
    ...getCampaignListsListIdLogoQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the logo of a campaign list.
 * **The user must be a member of a group authorized to vote (voters) or a member of the group CAA to use this endpoint**
 */
export const useGetCampaignListsListIdLogo = <TData = undefined,>(
  variables: GetCampaignListsListIdLogoVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCampaignListsListIdLogoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetCampaignListsListIdLogoError, TData>(
    {
      ...getCampaignListsListIdLogoQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetCdrUsersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrUsersResponse = Schemas.CdrUserPreview[];

export type GetCdrUsersVariables = HyperionContext["fetcherOptions"];

/**
 * Get all users.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const fetchGetCdrUsers = (
  variables: GetCdrUsersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetCdrUsersResponse, GetCdrUsersError, undefined, {}, {}, {}>({
    url: "/cdr/users/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all users.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export function getCdrUsersQuery(variables: GetCdrUsersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrUsersResponse>;
};

export function getCdrUsersQuery(
  variables: GetCdrUsersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersQuery(
  variables: GetCdrUsersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/",
      operationId: "getCdrUsers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCdrUsers(variables, signal),
  };
}

/**
 * Get all users.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const useSuspenseGetCdrUsers = <TData = GetCdrUsersResponse,>(
  variables: GetCdrUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCdrUsersResponse, GetCdrUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersResponse,
    GetCdrUsersError,
    TData
  >({
    ...getCdrUsersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all users.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const useGetCdrUsers = <TData = GetCdrUsersResponse,>(
  variables: GetCdrUsersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetCdrUsersResponse, GetCdrUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetCdrUsersResponse, GetCdrUsersError, TData>({
    ...getCdrUsersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrUsersPendingError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrUsersPendingResponse = Schemas.CdrUserPreview[];

export type GetCdrUsersPendingVariables = HyperionContext["fetcherOptions"];

/**
 * Get all users that have non-validated purchases.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const fetchGetCdrUsersPending = (
  variables: GetCdrUsersPendingVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersPendingResponse,
    GetCdrUsersPendingError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/users/pending/", method: "get", ...variables, signal });

/**
 * Get all users that have non-validated purchases.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export function getCdrUsersPendingQuery(
  variables: GetCdrUsersPendingVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrUsersPendingResponse>;
};

export function getCdrUsersPendingQuery(
  variables: GetCdrUsersPendingVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersPendingResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersPendingQuery(
  variables: GetCdrUsersPendingVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/pending/",
      operationId: "getCdrUsersPending",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersPending(variables, signal),
  };
}

/**
 * Get all users that have non-validated purchases.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const useSuspenseGetCdrUsersPending = <
  TData = GetCdrUsersPendingResponse,
>(
  variables: GetCdrUsersPendingVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersPendingResponse,
      GetCdrUsersPendingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersPendingResponse,
    GetCdrUsersPendingError,
    TData
  >({
    ...getCdrUsersPendingQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all users that have non-validated purchases.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const useGetCdrUsersPending = <TData = GetCdrUsersPendingResponse,>(
  variables: GetCdrUsersPendingVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersPendingResponse,
      GetCdrUsersPendingError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersPendingResponse,
    GetCdrUsersPendingError,
    TData
  >({
    ...getCdrUsersPendingQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrUsersUserIdPathParams = {
  userId: string;
};

export type GetCdrUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdVariables = {
  pathParams: GetCdrUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user.
 *
 * **User must be part of a seller group or trying to get itself to use this endpoint**
 */
export const fetchGetCdrUsersUserId = (
  variables: GetCdrUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CdrUser,
    GetCdrUsersUserIdError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdPathParams
  >({ url: "/cdr/users/{userId}/", method: "get", ...variables, signal });

/**
 * Get a user.
 *
 * **User must be part of a seller group or trying to get itself to use this endpoint**
 */
export function getCdrUsersUserIdQuery(variables: GetCdrUsersUserIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CdrUser>;
};

export function getCdrUsersUserIdQuery(
  variables: GetCdrUsersUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CdrUser>)
    | reactQuery.SkipToken;
};

export function getCdrUsersUserIdQuery(
  variables: GetCdrUsersUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/",
      operationId: "getCdrUsersUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersUserId(variables, signal),
  };
}

/**
 * Get a user.
 *
 * **User must be part of a seller group or trying to get itself to use this endpoint**
 */
export const useSuspenseGetCdrUsersUserId = <TData = Schemas.CdrUser,>(
  variables: GetCdrUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CdrUser, GetCdrUsersUserIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CdrUser,
    GetCdrUsersUserIdError,
    TData
  >({
    ...getCdrUsersUserIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user.
 *
 * **User must be part of a seller group or trying to get itself to use this endpoint**
 */
export const useGetCdrUsersUserId = <TData = Schemas.CdrUser,>(
  variables: GetCdrUsersUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CdrUser, GetCdrUsersUserIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CdrUser, GetCdrUsersUserIdError, TData>({
    ...getCdrUsersUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCdrUsersUserIdPathParams = {
  userId: string;
};

export type PatchCdrUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCdrUsersUserIdVariables = {
  body?: Schemas.CdrUserUpdate;
  pathParams: PatchCdrUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a user email, nickname and/or floor.
 *
 * An email will be send to the user, to confirm its new address.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const fetchPatchCdrUsersUserId = (
  variables: PatchCdrUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrUsersUserIdError,
    Schemas.CdrUserUpdate,
    {},
    {},
    PatchCdrUsersUserIdPathParams
  >({ url: "/cdr/users/{userId}/", method: "patch", ...variables, signal });

/**
 * Edit a user email, nickname and/or floor.
 *
 * An email will be send to the user, to confirm its new address.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const usePatchCdrUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrUsersUserIdError,
      PatchCdrUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrUsersUserIdError,
    PatchCdrUsersUserIdVariables
  >({
    mutationFn: (variables: PatchCdrUsersUserIdVariables) =>
      fetchPatchCdrUsersUserId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCdrSellersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrSellersResponse = Schemas.SellerComplete[];

export type GetCdrSellersVariables = HyperionContext["fetcherOptions"];

/**
 * Get all sellers.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchGetCdrSellers = (
  variables: GetCdrSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersResponse,
    GetCdrSellersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/sellers/", method: "get", ...variables, signal });

/**
 * Get all sellers.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export function getCdrSellersQuery(variables: GetCdrSellersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrSellersResponse>;
};

export function getCdrSellersQuery(
  variables: GetCdrSellersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrSellersResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersQuery(
  variables: GetCdrSellersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/",
      operationId: "getCdrSellers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCdrSellers(variables, signal),
  };
}

/**
 * Get all sellers.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCdrSellers = <TData = GetCdrSellersResponse,>(
  variables: GetCdrSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersResponse,
      GetCdrSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrSellersResponse,
    GetCdrSellersError,
    TData
  >({
    ...getCdrSellersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all sellers.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useGetCdrSellers = <TData = GetCdrSellersResponse,>(
  variables: GetCdrSellersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersResponse,
      GetCdrSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetCdrSellersResponse, GetCdrSellersError, TData>({
    ...getCdrSellersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrSellersVariables = {
  body: Schemas.SellerBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPostCdrSellers = (
  variables: PostCdrSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SellerComplete,
    PostCdrSellersError,
    Schemas.SellerBase,
    {},
    {},
    {}
  >({ url: "/cdr/sellers/", method: "post", ...variables, signal });

/**
 * Create a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePostCdrSellers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SellerComplete,
      PostCdrSellersError,
      PostCdrSellersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SellerComplete,
    PostCdrSellersError,
    PostCdrSellersVariables
  >({
    mutationFn: (variables: PostCdrSellersVariables) =>
      fetchPostCdrSellers(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCdrUsersMeSellersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrUsersMeSellersResponse = Schemas.SellerComplete[];

export type GetCdrUsersMeSellersVariables = HyperionContext["fetcherOptions"];

/**
 * Get sellers user is part of the group. If user is adminCDR, returns all sellers.
 *
 * **User must be authenticated to use this endpoint**
 */
export const fetchGetCdrUsersMeSellers = (
  variables: GetCdrUsersMeSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersMeSellersResponse,
    GetCdrUsersMeSellersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/users/me/sellers/", method: "get", ...variables, signal });

/**
 * Get sellers user is part of the group. If user is adminCDR, returns all sellers.
 *
 * **User must be authenticated to use this endpoint**
 */
export function getCdrUsersMeSellersQuery(
  variables: GetCdrUsersMeSellersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrUsersMeSellersResponse>;
};

export function getCdrUsersMeSellersQuery(
  variables: GetCdrUsersMeSellersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersMeSellersResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersMeSellersQuery(
  variables: GetCdrUsersMeSellersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/me/sellers/",
      operationId: "getCdrUsersMeSellers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersMeSellers(variables, signal),
  };
}

/**
 * Get sellers user is part of the group. If user is adminCDR, returns all sellers.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useSuspenseGetCdrUsersMeSellers = <
  TData = GetCdrUsersMeSellersResponse,
>(
  variables: GetCdrUsersMeSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersMeSellersResponse,
      GetCdrUsersMeSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersMeSellersResponse,
    GetCdrUsersMeSellersError,
    TData
  >({
    ...getCdrUsersMeSellersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get sellers user is part of the group. If user is adminCDR, returns all sellers.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useGetCdrUsersMeSellers = <TData = GetCdrUsersMeSellersResponse,>(
  variables: GetCdrUsersMeSellersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersMeSellersResponse,
      GetCdrUsersMeSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersMeSellersResponse,
    GetCdrUsersMeSellersError,
    TData
  >({
    ...getCdrUsersMeSellersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrOnlineSellersError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrOnlineSellersResponse = Schemas.SellerComplete[];

export type GetCdrOnlineSellersVariables = HyperionContext["fetcherOptions"];

/**
 * Get all sellers that has online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const fetchGetCdrOnlineSellers = (
  variables: GetCdrOnlineSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrOnlineSellersResponse,
    GetCdrOnlineSellersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/online/sellers/", method: "get", ...variables, signal });

/**
 * Get all sellers that has online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export function getCdrOnlineSellersQuery(
  variables: GetCdrOnlineSellersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrOnlineSellersResponse>;
};

export function getCdrOnlineSellersQuery(
  variables: GetCdrOnlineSellersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrOnlineSellersResponse>)
    | reactQuery.SkipToken;
};

export function getCdrOnlineSellersQuery(
  variables: GetCdrOnlineSellersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/online/sellers/",
      operationId: "getCdrOnlineSellers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrOnlineSellers(variables, signal),
  };
}

/**
 * Get all sellers that has online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useSuspenseGetCdrOnlineSellers = <
  TData = GetCdrOnlineSellersResponse,
>(
  variables: GetCdrOnlineSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineSellersResponse,
      GetCdrOnlineSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrOnlineSellersResponse,
    GetCdrOnlineSellersError,
    TData
  >({
    ...getCdrOnlineSellersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all sellers that has online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useGetCdrOnlineSellers = <TData = GetCdrOnlineSellersResponse,>(
  variables: GetCdrOnlineSellersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineSellersResponse,
      GetCdrOnlineSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrOnlineSellersResponse,
    GetCdrOnlineSellersError,
    TData
  >({
    ...getCdrOnlineSellersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrSellersSellerIdResultsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrSellersSellerIdResultsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrSellersSellerIdResultsVariables = {
  pathParams: GetCdrSellersSellerIdResultsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a seller's results.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchGetCdrSellersSellerIdResults = (
  variables: GetCdrSellersSellerIdResultsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetCdrSellersSellerIdResultsError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdResultsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/results/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a seller's results.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export function getCdrSellersSellerIdResultsQuery(
  variables: GetCdrSellersSellerIdResultsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getCdrSellersSellerIdResultsQuery(
  variables: GetCdrSellersSellerIdResultsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdResultsQuery(
  variables: GetCdrSellersSellerIdResultsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/results/",
      operationId: "getCdrSellersSellerIdResults",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdResults(variables, signal),
  };
}

/**
 * Get a seller's results.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCdrSellersSellerIdResults = <TData = undefined,>(
  variables: GetCdrSellersSellerIdResultsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCdrSellersSellerIdResultsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetCdrSellersSellerIdResultsError,
    TData
  >({
    ...getCdrSellersSellerIdResultsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's results.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useGetCdrSellersSellerIdResults = <TData = undefined,>(
  variables: GetCdrSellersSellerIdResultsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCdrSellersSellerIdResultsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetCdrSellersSellerIdResultsError,
    TData
  >({
    ...getCdrSellersSellerIdResultsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrOnlineProductsError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrOnlineProductsResponse =
  Schemas.AppModulesCdrSchemasCdrProductComplete[];

export type GetCdrOnlineProductsVariables = HyperionContext["fetcherOptions"];

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const fetchGetCdrOnlineProducts = (
  variables: GetCdrOnlineProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrOnlineProductsResponse,
    GetCdrOnlineProductsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/online/products/", method: "get", ...variables, signal });

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export function getCdrOnlineProductsQuery(
  variables: GetCdrOnlineProductsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrOnlineProductsResponse>;
};

export function getCdrOnlineProductsQuery(
  variables: GetCdrOnlineProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrOnlineProductsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrOnlineProductsQuery(
  variables: GetCdrOnlineProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/online/products/",
      operationId: "getCdrOnlineProducts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrOnlineProducts(variables, signal),
  };
}

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useSuspenseGetCdrOnlineProducts = <
  TData = GetCdrOnlineProductsResponse,
>(
  variables: GetCdrOnlineProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineProductsResponse,
      GetCdrOnlineProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrOnlineProductsResponse,
    GetCdrOnlineProductsError,
    TData
  >({
    ...getCdrOnlineProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useGetCdrOnlineProducts = <TData = GetCdrOnlineProductsResponse,>(
  variables: GetCdrOnlineProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineProductsResponse,
      GetCdrOnlineProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrOnlineProductsResponse,
    GetCdrOnlineProductsError,
    TData
  >({
    ...getCdrOnlineProductsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrProductsError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrProductsResponse =
  Schemas.AppModulesCdrSchemasCdrProductComplete[];

export type GetCdrProductsVariables = HyperionContext["fetcherOptions"];

/**
 * Get a seller's online available products.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const fetchGetCdrProducts = (
  variables: GetCdrProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrProductsResponse,
    GetCdrProductsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/products/", method: "get", ...variables, signal });

/**
 * Get a seller's online available products.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export function getCdrProductsQuery(variables: GetCdrProductsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrProductsResponse>;
};

export function getCdrProductsQuery(
  variables: GetCdrProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrProductsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrProductsQuery(
  variables: GetCdrProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/products/",
      operationId: "getCdrProducts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrProducts(variables, signal),
  };
}

/**
 * Get a seller's online available products.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const useSuspenseGetCdrProducts = <TData = GetCdrProductsResponse,>(
  variables: GetCdrProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrProductsResponse,
      GetCdrProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrProductsResponse,
    GetCdrProductsError,
    TData
  >({
    ...getCdrProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's online available products.
 *
 * **User must be part of a seller group to use this endpoint**
 */
export const useGetCdrProducts = <TData = GetCdrProductsResponse,>(
  variables: GetCdrProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrProductsResponse,
      GetCdrProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrProductsResponse,
    GetCdrProductsError,
    TData
  >({
    ...getCdrProductsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCdrSellersSellerIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type PatchCdrSellersSellerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCdrSellersSellerIdVariables = {
  body?: Schemas.SellerEdit;
  pathParams: PatchCdrSellersSellerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPatchCdrSellersSellerId = (
  variables: PatchCdrSellersSellerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrSellersSellerIdError,
    Schemas.SellerEdit,
    {},
    {},
    PatchCdrSellersSellerIdPathParams
  >({ url: "/cdr/sellers/{sellerId}/", method: "patch", ...variables, signal });

/**
 * Update a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePatchCdrSellersSellerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrSellersSellerIdError,
      PatchCdrSellersSellerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrSellersSellerIdError,
    PatchCdrSellersSellerIdVariables
  >({
    mutationFn: (variables: PatchCdrSellersSellerIdVariables) =>
      fetchPatchCdrSellersSellerId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type DeleteCdrSellersSellerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrSellersSellerIdVariables = {
  pathParams: DeleteCdrSellersSellerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchDeleteCdrSellersSellerId = (
  variables: DeleteCdrSellersSellerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a seller.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useDeleteCdrSellersSellerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdError,
      DeleteCdrSellersSellerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdError,
    DeleteCdrSellersSellerIdVariables
  >({
    mutationFn: (variables: DeleteCdrSellersSellerIdVariables) =>
      fetchDeleteCdrSellersSellerId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCdrSellersSellerIdProductsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrSellersSellerIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrSellersSellerIdProductsResponse =
  Schemas.AppModulesCdrSchemasCdrProductComplete[];

export type GetCdrSellersSellerIdProductsVariables = {
  pathParams: GetCdrSellersSellerIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a seller's products.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchGetCdrSellersSellerIdProducts = (
  variables: GetCdrSellersSellerIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdProductsResponse,
    GetCdrSellersSellerIdProductsError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdProductsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a seller's products.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export function getCdrSellersSellerIdProductsQuery(
  variables: GetCdrSellersSellerIdProductsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdProductsResponse>;
};

export function getCdrSellersSellerIdProductsQuery(
  variables: GetCdrSellersSellerIdProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdProductsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdProductsQuery(
  variables: GetCdrSellersSellerIdProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/",
      operationId: "getCdrSellersSellerIdProducts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdProducts(variables, signal),
  };
}

/**
 * Get a seller's products.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useSuspenseGetCdrSellersSellerIdProducts = <
  TData = GetCdrSellersSellerIdProductsResponse,
>(
  variables: GetCdrSellersSellerIdProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdProductsResponse,
      GetCdrSellersSellerIdProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrSellersSellerIdProductsResponse,
    GetCdrSellersSellerIdProductsError,
    TData
  >({
    ...getCdrSellersSellerIdProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's products.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useGetCdrSellersSellerIdProducts = <
  TData = GetCdrSellersSellerIdProductsResponse,
>(
  variables: GetCdrSellersSellerIdProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdProductsResponse,
      GetCdrSellersSellerIdProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdProductsResponse,
    GetCdrSellersSellerIdProductsError,
    TData
  >({
    ...getCdrSellersSellerIdProductsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdProductsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type PostCdrSellersSellerIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrSellersSellerIdProductsVariables = {
  body: Schemas.AppModulesCdrSchemasCdrProductBase;
  pathParams: PostCdrSellersSellerIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPostCdrSellersSellerIdProducts = (
  variables: PostCdrSellersSellerIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesCdrSchemasCdrProductComplete,
    PostCdrSellersSellerIdProductsError,
    Schemas.AppModulesCdrSchemasCdrProductBase,
    {},
    {},
    PostCdrSellersSellerIdProductsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePostCdrSellersSellerIdProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsError,
      PostCdrSellersSellerIdProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesCdrSchemasCdrProductComplete,
    PostCdrSellersSellerIdProductsError,
    PostCdrSellersSellerIdProductsVariables
  >({
    mutationFn: (variables: PostCdrSellersSellerIdProductsVariables) =>
      fetchPostCdrSellersSellerIdProducts(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCdrOnlineSellersSellerIdProductsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrOnlineSellersSellerIdProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrOnlineSellersSellerIdProductsResponse =
  Schemas.AppModulesCdrSchemasCdrProductComplete[];

export type GetCdrOnlineSellersSellerIdProductsVariables = {
  pathParams: GetCdrOnlineSellersSellerIdProductsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const fetchGetCdrOnlineSellersSellerIdProducts = (
  variables: GetCdrOnlineSellersSellerIdProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrOnlineSellersSellerIdProductsResponse,
    GetCdrOnlineSellersSellerIdProductsError,
    undefined,
    {},
    {},
    GetCdrOnlineSellersSellerIdProductsPathParams
  >({
    url: "/cdr/online/sellers/{sellerId}/products/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export function getCdrOnlineSellersSellerIdProductsQuery(
  variables: GetCdrOnlineSellersSellerIdProductsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrOnlineSellersSellerIdProductsResponse>;
};

export function getCdrOnlineSellersSellerIdProductsQuery(
  variables:
    | GetCdrOnlineSellersSellerIdProductsVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrOnlineSellersSellerIdProductsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrOnlineSellersSellerIdProductsQuery(
  variables:
    | GetCdrOnlineSellersSellerIdProductsVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/online/sellers/{sellerId}/products/",
      operationId: "getCdrOnlineSellersSellerIdProducts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrOnlineSellersSellerIdProducts(variables, signal),
  };
}

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useSuspenseGetCdrOnlineSellersSellerIdProducts = <
  TData = GetCdrOnlineSellersSellerIdProductsResponse,
>(
  variables: GetCdrOnlineSellersSellerIdProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineSellersSellerIdProductsResponse,
      GetCdrOnlineSellersSellerIdProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrOnlineSellersSellerIdProductsResponse,
    GetCdrOnlineSellersSellerIdProductsError,
    TData
  >({
    ...getCdrOnlineSellersSellerIdProductsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's online available products.
 *
 * **User must be authenticated to use this endpoint**
 */
export const useGetCdrOnlineSellersSellerIdProducts = <
  TData = GetCdrOnlineSellersSellerIdProductsResponse,
>(
  variables:
    | GetCdrOnlineSellersSellerIdProductsVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrOnlineSellersSellerIdProductsResponse,
      GetCdrOnlineSellersSellerIdProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrOnlineSellersSellerIdProductsResponse,
    GetCdrOnlineSellersSellerIdProductsError,
    TData
  >({
    ...getCdrOnlineSellersSellerIdProductsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCdrSellersSellerIdProductsProductIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type PatchCdrSellersSellerIdProductsProductIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrSellersSellerIdProductsProductIdVariables = {
  body?: Schemas.AppModulesCdrSchemasCdrProductEdit;
  pathParams: PatchCdrSellersSellerIdProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPatchCdrSellersSellerIdProductsProductId = (
  variables: PatchCdrSellersSellerIdProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdError,
    Schemas.AppModulesCdrSchemasCdrProductEdit,
    {},
    {},
    PatchCdrSellersSellerIdProductsProductIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePatchCdrSellersSellerIdProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdError,
      PatchCdrSellersSellerIdProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdError,
    PatchCdrSellersSellerIdProductsProductIdVariables
  >({
    mutationFn: (
      variables: PatchCdrSellersSellerIdProductsProductIdVariables,
    ) =>
      fetchPatchCdrSellersSellerIdProductsProductId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdProductsProductIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type DeleteCdrSellersSellerIdProductsProductIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdVariables = {
  pathParams: DeleteCdrSellersSellerIdProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCdrSellersSellerIdProductsProductId = (
  variables: DeleteCdrSellersSellerIdProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdProductsProductIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useDeleteCdrSellersSellerIdProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdError,
      DeleteCdrSellersSellerIdProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdError,
    DeleteCdrSellersSellerIdProductsProductIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdProductsProductIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdProductsProductId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCdrSellersSellerIdProductsProductIdVariantsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type PostCdrSellersSellerIdProductsProductIdVariantsError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdVariantsVariables = {
  body: Schemas.AppModulesCdrSchemasCdrProductVariantBase;
  pathParams: PostCdrSellersSellerIdProductsProductIdVariantsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPostCdrSellersSellerIdProductsProductIdVariants = (
  variables: PostCdrSellersSellerIdProductsProductIdVariantsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesCdrSchemasCdrProductVariantComplete,
    PostCdrSellersSellerIdProductsProductIdVariantsError,
    Schemas.AppModulesCdrSchemasCdrProductVariantBase,
    {},
    {},
    PostCdrSellersSellerIdProductsProductIdVariantsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/variants/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePostCdrSellersSellerIdProductsProductIdVariants = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesCdrSchemasCdrProductVariantComplete,
      PostCdrSellersSellerIdProductsProductIdVariantsError,
      PostCdrSellersSellerIdProductsProductIdVariantsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesCdrSchemasCdrProductVariantComplete,
    PostCdrSellersSellerIdProductsProductIdVariantsError,
    PostCdrSellersSellerIdProductsProductIdVariantsVariables
  >({
    mutationFn: (
      variables: PostCdrSellersSellerIdProductsProductIdVariantsVariables,
    ) =>
      fetchPostCdrSellersSellerIdProductsProductIdVariants(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    variantId: string;
  };

export type PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables =
  {
    body?: Schemas.AppModulesCdrSchemasCdrProductVariantEdit;
    pathParams: PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams;
  } & HyperionContext["fetcherOptions"];

/**
 * Edit a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPatchCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  variables: PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    Schemas.AppModulesCdrSchemasCdrProductVariantEdit,
    {},
    {},
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/variants/{variantId}/",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePatchCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
      PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
  >({
    mutationFn: (
      variables: PatchCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
    ) =>
      fetchPatchCdrSellersSellerIdProductsProductIdVariantsVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    variantId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams;
  } & HyperionContext["fetcherOptions"];

/**
 * Delete a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  variables: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/variants/{variantId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useDeleteCdrSellersSellerIdProductsProductIdVariantsVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
      DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdError,
    DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdProductsProductIdVariantsVariantIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdProductsProductIdVariantsVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrSellersSellerIdDocumentsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type GetCdrSellersSellerIdDocumentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrSellersSellerIdDocumentsResponse = Schemas.DocumentComplete[];

export type GetCdrSellersSellerIdDocumentsVariables = {
  pathParams: GetCdrSellersSellerIdDocumentsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a seller's documents.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchGetCdrSellersSellerIdDocuments = (
  variables: GetCdrSellersSellerIdDocumentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdDocumentsResponse,
    GetCdrSellersSellerIdDocumentsError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdDocumentsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/documents/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a seller's documents.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export function getCdrSellersSellerIdDocumentsQuery(
  variables: GetCdrSellersSellerIdDocumentsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdDocumentsResponse>;
};

export function getCdrSellersSellerIdDocumentsQuery(
  variables: GetCdrSellersSellerIdDocumentsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdDocumentsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdDocumentsQuery(
  variables: GetCdrSellersSellerIdDocumentsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/documents/",
      operationId: "getCdrSellersSellerIdDocuments",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdDocuments(variables, signal),
  };
}

/**
 * Get a seller's documents.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useSuspenseGetCdrSellersSellerIdDocuments = <
  TData = GetCdrSellersSellerIdDocumentsResponse,
>(
  variables: GetCdrSellersSellerIdDocumentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdDocumentsResponse,
      GetCdrSellersSellerIdDocumentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrSellersSellerIdDocumentsResponse,
    GetCdrSellersSellerIdDocumentsError,
    TData
  >({
    ...getCdrSellersSellerIdDocumentsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's documents.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useGetCdrSellersSellerIdDocuments = <
  TData = GetCdrSellersSellerIdDocumentsResponse,
>(
  variables: GetCdrSellersSellerIdDocumentsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdDocumentsResponse,
      GetCdrSellersSellerIdDocumentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdDocumentsResponse,
    GetCdrSellersSellerIdDocumentsError,
    TData
  >({
    ...getCdrSellersSellerIdDocumentsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdDocumentsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
};

export type PostCdrSellersSellerIdDocumentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrSellersSellerIdDocumentsVariables = {
  body: Schemas.DocumentBase;
  pathParams: PostCdrSellersSellerIdDocumentsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a document.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPostCdrSellersSellerIdDocuments = (
  variables: PostCdrSellersSellerIdDocumentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.DocumentComplete,
    PostCdrSellersSellerIdDocumentsError,
    Schemas.DocumentBase,
    {},
    {},
    PostCdrSellersSellerIdDocumentsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/documents/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a document.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePostCdrSellersSellerIdDocuments = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DocumentComplete,
      PostCdrSellersSellerIdDocumentsError,
      PostCdrSellersSellerIdDocumentsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.DocumentComplete,
    PostCdrSellersSellerIdDocumentsError,
    PostCdrSellersSellerIdDocumentsVariables
  >({
    mutationFn: (variables: PostCdrSellersSellerIdDocumentsVariables) =>
      fetchPostCdrSellersSellerIdDocuments(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrDocumentsError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrDocumentsResponse = Schemas.DocumentComplete[];

export type GetCdrDocumentsVariables = HyperionContext["fetcherOptions"];

/**
 * Get a seller's documents.
 *
 * **User must be part of a seller's group to use this endpoint**
 */
export const fetchGetCdrDocuments = (
  variables: GetCdrDocumentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrDocumentsResponse,
    GetCdrDocumentsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/documents/", method: "get", ...variables, signal });

/**
 * Get a seller's documents.
 *
 * **User must be part of a seller's group to use this endpoint**
 */
export function getCdrDocumentsQuery(variables: GetCdrDocumentsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrDocumentsResponse>;
};

export function getCdrDocumentsQuery(
  variables: GetCdrDocumentsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrDocumentsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrDocumentsQuery(
  variables: GetCdrDocumentsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/documents/",
      operationId: "getCdrDocuments",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrDocuments(variables, signal),
  };
}

/**
 * Get a seller's documents.
 *
 * **User must be part of a seller's group to use this endpoint**
 */
export const useSuspenseGetCdrDocuments = <TData = GetCdrDocumentsResponse,>(
  variables: GetCdrDocumentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrDocumentsResponse,
      GetCdrDocumentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrDocumentsResponse,
    GetCdrDocumentsError,
    TData
  >({
    ...getCdrDocumentsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a seller's documents.
 *
 * **User must be part of a seller's group to use this endpoint**
 */
export const useGetCdrDocuments = <TData = GetCdrDocumentsResponse,>(
  variables: GetCdrDocumentsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrDocumentsResponse,
      GetCdrDocumentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrDocumentsResponse,
    GetCdrDocumentsError,
    TData
  >({
    ...getCdrDocumentsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DeleteCdrSellersSellerIdDocumentsDocumentIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  documentId: string;
};

export type DeleteCdrSellersSellerIdDocumentsDocumentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdDocumentsDocumentIdVariables = {
  pathParams: DeleteCdrSellersSellerIdDocumentsDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a document.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCdrSellersSellerIdDocumentsDocumentId = (
  variables: DeleteCdrSellersSellerIdDocumentsDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdDocumentsDocumentIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdDocumentsDocumentIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/documents/{documentId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a document.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useDeleteCdrSellersSellerIdDocumentsDocumentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdDocumentsDocumentIdError,
      DeleteCdrSellersSellerIdDocumentsDocumentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdDocumentsDocumentIdError,
    DeleteCdrSellersSellerIdDocumentsDocumentIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdDocumentsDocumentIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdDocumentsDocumentId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrUsersUserIdPurchasesPathParams = {
  userId: string;
};

export type GetCdrUsersUserIdPurchasesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdPurchasesResponse = Schemas.PurchaseReturn[];

export type GetCdrUsersUserIdPurchasesVariables = {
  pathParams: GetCdrUsersUserIdPurchasesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const fetchGetCdrUsersUserIdPurchases = (
  variables: GetCdrUsersUserIdPurchasesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdPurchasesResponse,
    GetCdrUsersUserIdPurchasesError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdPurchasesPathParams
  >({
    url: "/cdr/users/{userId}/purchases/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export function getCdrUsersUserIdPurchasesQuery(
  variables: GetCdrUsersUserIdPurchasesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrUsersUserIdPurchasesResponse>;
};

export function getCdrUsersUserIdPurchasesQuery(
  variables: GetCdrUsersUserIdPurchasesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersUserIdPurchasesResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersUserIdPurchasesQuery(
  variables: GetCdrUsersUserIdPurchasesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/purchases/",
      operationId: "getCdrUsersUserIdPurchases",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersUserIdPurchases(variables, signal),
  };
}

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCdrUsersUserIdPurchases = <
  TData = GetCdrUsersUserIdPurchasesResponse,
>(
  variables: GetCdrUsersUserIdPurchasesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdPurchasesResponse,
      GetCdrUsersUserIdPurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersUserIdPurchasesResponse,
    GetCdrUsersUserIdPurchasesError,
    TData
  >({
    ...getCdrUsersUserIdPurchasesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const useGetCdrUsersUserIdPurchases = <
  TData = GetCdrUsersUserIdPurchasesResponse,
>(
  variables: GetCdrUsersUserIdPurchasesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdPurchasesResponse,
      GetCdrUsersUserIdPurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdPurchasesResponse,
    GetCdrUsersUserIdPurchasesError,
    TData
  >({
    ...getCdrUsersUserIdPurchasesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrMePurchasesError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrMePurchasesResponse = Schemas.PurchaseReturn[];

export type GetCdrMePurchasesVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrMePurchases = (
  variables: GetCdrMePurchasesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrMePurchasesResponse,
    GetCdrMePurchasesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/me/purchases/", method: "get", ...variables, signal });

export function getCdrMePurchasesQuery(variables: GetCdrMePurchasesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrMePurchasesResponse>;
};

export function getCdrMePurchasesQuery(
  variables: GetCdrMePurchasesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrMePurchasesResponse>)
    | reactQuery.SkipToken;
};

export function getCdrMePurchasesQuery(
  variables: GetCdrMePurchasesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/me/purchases/",
      operationId: "getCdrMePurchases",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrMePurchases(variables, signal),
  };
}

export const useSuspenseGetCdrMePurchases = <
  TData = GetCdrMePurchasesResponse,
>(
  variables: GetCdrMePurchasesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrMePurchasesResponse,
      GetCdrMePurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrMePurchasesResponse,
    GetCdrMePurchasesError,
    TData
  >({
    ...getCdrMePurchasesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCdrMePurchases = <TData = GetCdrMePurchasesResponse,>(
  variables: GetCdrMePurchasesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrMePurchasesResponse,
      GetCdrMePurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrMePurchasesResponse,
    GetCdrMePurchasesError,
    TData
  >({
    ...getCdrMePurchasesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrSellersSellerIdUsersUserIdPurchasesPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  userId: string;
};

export type GetCdrSellersSellerIdUsersUserIdPurchasesError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdUsersUserIdPurchasesResponse =
  Schemas.PurchaseReturn[];

export type GetCdrSellersSellerIdUsersUserIdPurchasesVariables = {
  pathParams: GetCdrSellersSellerIdUsersUserIdPurchasesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be part of the seller's group to use this endpoint**
 */
export const fetchGetCdrSellersSellerIdUsersUserIdPurchases = (
  variables: GetCdrSellersSellerIdUsersUserIdPurchasesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
    GetCdrSellersSellerIdUsersUserIdPurchasesError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdUsersUserIdPurchasesPathParams
  >({
    url: "/cdr/sellers/{sellerId}/users/{userId}/purchases/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be part of the seller's group to use this endpoint**
 */
export function getCdrSellersSellerIdUsersUserIdPurchasesQuery(
  variables: GetCdrSellersSellerIdUsersUserIdPurchasesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdUsersUserIdPurchasesResponse>;
};

export function getCdrSellersSellerIdUsersUserIdPurchasesQuery(
  variables:
    | GetCdrSellersSellerIdUsersUserIdPurchasesVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdUsersUserIdPurchasesResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdUsersUserIdPurchasesQuery(
  variables:
    | GetCdrSellersSellerIdUsersUserIdPurchasesVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/users/{userId}/purchases/",
      operationId: "getCdrSellersSellerIdUsersUserIdPurchases",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdUsersUserIdPurchases(variables, signal),
  };
}

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be part of the seller's group to use this endpoint**
 */
export const useSuspenseGetCdrSellersSellerIdUsersUserIdPurchases = <
  TData = GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
>(
  variables: GetCdrSellersSellerIdUsersUserIdPurchasesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
      GetCdrSellersSellerIdUsersUserIdPurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
    GetCdrSellersSellerIdUsersUserIdPurchasesError,
    TData
  >({
    ...getCdrSellersSellerIdUsersUserIdPurchasesQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be part of the seller's group to use this endpoint**
 */
export const useGetCdrSellersSellerIdUsersUserIdPurchases = <
  TData = GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
>(
  variables:
    | GetCdrSellersSellerIdUsersUserIdPurchasesVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
      GetCdrSellersSellerIdUsersUserIdPurchasesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdUsersUserIdPurchasesResponse,
    GetCdrSellersSellerIdUsersUserIdPurchasesError,
    TData
  >({
    ...getCdrSellersSellerIdUsersUserIdPurchasesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrUsersUserIdPurchasesProductVariantIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type PostCdrUsersUserIdPurchasesProductVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrUsersUserIdPurchasesProductVariantIdVariables = {
  body: Schemas.AppModulesCdrSchemasCdrPurchaseBase;
  pathParams: PostCdrUsersUserIdPurchasesProductVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const fetchPostCdrUsersUserIdPurchasesProductVariantId = (
  variables: PostCdrUsersUserIdPurchasesProductVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PurchaseComplete,
    PostCdrUsersUserIdPurchasesProductVariantIdError,
    Schemas.AppModulesCdrSchemasCdrPurchaseBase,
    {},
    {},
    PostCdrUsersUserIdPurchasesProductVariantIdPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const usePostCdrUsersUserIdPurchasesProductVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PurchaseComplete,
      PostCdrUsersUserIdPurchasesProductVariantIdError,
      PostCdrUsersUserIdPurchasesProductVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PurchaseComplete,
    PostCdrUsersUserIdPurchasesProductVariantIdError,
    PostCdrUsersUserIdPurchasesProductVariantIdVariables
  >({
    mutationFn: (
      variables: PostCdrUsersUserIdPurchasesProductVariantIdVariables,
    ) =>
      fetchPostCdrUsersUserIdPurchasesProductVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrUsersUserIdPurchasesProductVariantIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type DeleteCdrUsersUserIdPurchasesProductVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrUsersUserIdPurchasesProductVariantIdVariables = {
  pathParams: DeleteCdrUsersUserIdPurchasesProductVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCdrUsersUserIdPurchasesProductVariantId = (
  variables: DeleteCdrUsersUserIdPurchasesProductVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdPurchasesProductVariantIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdPurchasesProductVariantIdPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const useDeleteCdrUsersUserIdPurchasesProductVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdPurchasesProductVariantIdError,
      DeleteCdrUsersUserIdPurchasesProductVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdPurchasesProductVariantIdError,
    DeleteCdrUsersUserIdPurchasesProductVariantIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrUsersUserIdPurchasesProductVariantIdVariables,
    ) =>
      fetchDeleteCdrUsersUserIdPurchasesProductVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdValidatedPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdValidatedQueryParams = {
  validated: boolean;
};

export type PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrUsersUserIdPurchasesProductVariantIdValidatedVariables = {
  pathParams: PatchCdrUsersUserIdPurchasesProductVariantIdValidatedPathParams;
  queryParams: PatchCdrUsersUserIdPurchasesProductVariantIdValidatedQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Validate a purchase.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPatchCdrUsersUserIdPurchasesProductVariantIdValidated = (
  variables: PatchCdrUsersUserIdPurchasesProductVariantIdValidatedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError,
    undefined,
    {},
    PatchCdrUsersUserIdPurchasesProductVariantIdValidatedQueryParams,
    PatchCdrUsersUserIdPurchasesProductVariantIdValidatedPathParams
  >({
    url: "/cdr/users/{userId}/purchases/{productVariantId}/validated/",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Validate a purchase.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePatchCdrUsersUserIdPurchasesProductVariantIdValidated = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError,
      PatchCdrUsersUserIdPurchasesProductVariantIdValidatedVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrUsersUserIdPurchasesProductVariantIdValidatedError,
    PatchCdrUsersUserIdPurchasesProductVariantIdValidatedVariables
  >({
    mutationFn: (
      variables: PatchCdrUsersUserIdPurchasesProductVariantIdValidatedVariables,
    ) =>
      fetchPatchCdrUsersUserIdPurchasesProductVariantIdValidated(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrUsersUserIdSignaturesPathParams = {
  userId: string;
};

export type GetCdrUsersUserIdSignaturesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdSignaturesResponse = Schemas.SignatureComplete[];

export type GetCdrUsersUserIdSignaturesVariables = {
  pathParams: GetCdrUsersUserIdSignaturesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's signatures.
 *
 * **User must get his own signatures or be CDR Admin to use this endpoint**
 */
export const fetchGetCdrUsersUserIdSignatures = (
  variables: GetCdrUsersUserIdSignaturesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdSignaturesResponse,
    GetCdrUsersUserIdSignaturesError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdSignaturesPathParams
  >({
    url: "/cdr/users/{userId}/signatures/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's signatures.
 *
 * **User must get his own signatures or be CDR Admin to use this endpoint**
 */
export function getCdrUsersUserIdSignaturesQuery(
  variables: GetCdrUsersUserIdSignaturesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrUsersUserIdSignaturesResponse>;
};

export function getCdrUsersUserIdSignaturesQuery(
  variables: GetCdrUsersUserIdSignaturesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrUsersUserIdSignaturesResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersUserIdSignaturesQuery(
  variables: GetCdrUsersUserIdSignaturesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/signatures/",
      operationId: "getCdrUsersUserIdSignatures",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersUserIdSignatures(variables, signal),
  };
}

/**
 * Get a user's signatures.
 *
 * **User must get his own signatures or be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCdrUsersUserIdSignatures = <
  TData = GetCdrUsersUserIdSignaturesResponse,
>(
  variables: GetCdrUsersUserIdSignaturesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdSignaturesResponse,
      GetCdrUsersUserIdSignaturesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersUserIdSignaturesResponse,
    GetCdrUsersUserIdSignaturesError,
    TData
  >({
    ...getCdrUsersUserIdSignaturesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's signatures.
 *
 * **User must get his own signatures or be CDR Admin to use this endpoint**
 */
export const useGetCdrUsersUserIdSignatures = <
  TData = GetCdrUsersUserIdSignaturesResponse,
>(
  variables: GetCdrUsersUserIdSignaturesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdSignaturesResponse,
      GetCdrUsersUserIdSignaturesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdSignaturesResponse,
    GetCdrUsersUserIdSignaturesError,
    TData
  >({
    ...getCdrUsersUserIdSignaturesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrSellersSellerIdUsersUserIdSignaturesPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  userId: string;
};

export type GetCdrSellersSellerIdUsersUserIdSignaturesError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdUsersUserIdSignaturesResponse =
  Schemas.SignatureComplete[];

export type GetCdrSellersSellerIdUsersUserIdSignaturesVariables = {
  pathParams: GetCdrSellersSellerIdUsersUserIdSignaturesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's signatures for a single seller.
 *
 * **User must get his own signatures or be part of the seller's group to use this endpoint**
 */
export const fetchGetCdrSellersSellerIdUsersUserIdSignatures = (
  variables: GetCdrSellersSellerIdUsersUserIdSignaturesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
    GetCdrSellersSellerIdUsersUserIdSignaturesError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdUsersUserIdSignaturesPathParams
  >({
    url: "/cdr/sellers/{sellerId}/users/{userId}/signatures/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's signatures for a single seller.
 *
 * **User must get his own signatures or be part of the seller's group to use this endpoint**
 */
export function getCdrSellersSellerIdUsersUserIdSignaturesQuery(
  variables: GetCdrSellersSellerIdUsersUserIdSignaturesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdUsersUserIdSignaturesResponse>;
};

export function getCdrSellersSellerIdUsersUserIdSignaturesQuery(
  variables:
    | GetCdrSellersSellerIdUsersUserIdSignaturesVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdUsersUserIdSignaturesResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdUsersUserIdSignaturesQuery(
  variables:
    | GetCdrSellersSellerIdUsersUserIdSignaturesVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/users/{userId}/signatures/",
      operationId: "getCdrSellersSellerIdUsersUserIdSignatures",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdUsersUserIdSignatures(variables, signal),
  };
}

/**
 * Get a user's signatures for a single seller.
 *
 * **User must get his own signatures or be part of the seller's group to use this endpoint**
 */
export const useSuspenseGetCdrSellersSellerIdUsersUserIdSignatures = <
  TData = GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
>(
  variables: GetCdrSellersSellerIdUsersUserIdSignaturesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
      GetCdrSellersSellerIdUsersUserIdSignaturesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
    GetCdrSellersSellerIdUsersUserIdSignaturesError,
    TData
  >({
    ...getCdrSellersSellerIdUsersUserIdSignaturesQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's signatures for a single seller.
 *
 * **User must get his own signatures or be part of the seller's group to use this endpoint**
 */
export const useGetCdrSellersSellerIdUsersUserIdSignatures = <
  TData = GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
>(
  variables:
    | GetCdrSellersSellerIdUsersUserIdSignaturesVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
      GetCdrSellersSellerIdUsersUserIdSignaturesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdUsersUserIdSignaturesResponse,
    GetCdrSellersSellerIdUsersUserIdSignaturesError,
    TData
  >({
    ...getCdrSellersSellerIdUsersUserIdSignaturesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrUsersUserIdSignaturesDocumentIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  documentId: string;
};

export type PostCdrUsersUserIdSignaturesDocumentIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrUsersUserIdSignaturesDocumentIdVariables = {
  body: Schemas.SignatureBase;
  pathParams: PostCdrUsersUserIdSignaturesDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a signature.
 *
 * **User must sign numerically or be part of the seller's group to use this endpoint**
 */
export const fetchPostCdrUsersUserIdSignaturesDocumentId = (
  variables: PostCdrUsersUserIdSignaturesDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SignatureComplete,
    PostCdrUsersUserIdSignaturesDocumentIdError,
    Schemas.SignatureBase,
    {},
    {},
    PostCdrUsersUserIdSignaturesDocumentIdPathParams
  >({
    url: "/cdr/users/{userId}/signatures/{documentId}/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a signature.
 *
 * **User must sign numerically or be part of the seller's group to use this endpoint**
 */
export const usePostCdrUsersUserIdSignaturesDocumentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SignatureComplete,
      PostCdrUsersUserIdSignaturesDocumentIdError,
      PostCdrUsersUserIdSignaturesDocumentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SignatureComplete,
    PostCdrUsersUserIdSignaturesDocumentIdError,
    PostCdrUsersUserIdSignaturesDocumentIdVariables
  >({
    mutationFn: (variables: PostCdrUsersUserIdSignaturesDocumentIdVariables) =>
      fetchPostCdrUsersUserIdSignaturesDocumentId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrUsersUserIdSignaturesDocumentIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  documentId: string;
};

export type DeleteCdrUsersUserIdSignaturesDocumentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrUsersUserIdSignaturesDocumentIdVariables = {
  pathParams: DeleteCdrUsersUserIdSignaturesDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a signature.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchDeleteCdrUsersUserIdSignaturesDocumentId = (
  variables: DeleteCdrUsersUserIdSignaturesDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdSignaturesDocumentIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdSignaturesDocumentIdPathParams
  >({
    url: "/cdr/users/{userId}/signatures/{documentId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a signature.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useDeleteCdrUsersUserIdSignaturesDocumentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdSignaturesDocumentIdError,
      DeleteCdrUsersUserIdSignaturesDocumentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdSignaturesDocumentIdError,
    DeleteCdrUsersUserIdSignaturesDocumentIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrUsersUserIdSignaturesDocumentIdVariables,
    ) =>
      fetchDeleteCdrUsersUserIdSignaturesDocumentId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrCurriculumsError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrCurriculumsResponse = Schemas.CurriculumComplete[];

export type GetCdrCurriculumsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all curriculums.
 *
 * **User be authenticated to use this endpoint**
 */
export const fetchGetCdrCurriculums = (
  variables: GetCdrCurriculumsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrCurriculumsResponse,
    GetCdrCurriculumsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/curriculums/", method: "get", ...variables, signal });

/**
 * Get all curriculums.
 *
 * **User be authenticated to use this endpoint**
 */
export function getCdrCurriculumsQuery(variables: GetCdrCurriculumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrCurriculumsResponse>;
};

export function getCdrCurriculumsQuery(
  variables: GetCdrCurriculumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrCurriculumsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrCurriculumsQuery(
  variables: GetCdrCurriculumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/curriculums/",
      operationId: "getCdrCurriculums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrCurriculums(variables, signal),
  };
}

/**
 * Get all curriculums.
 *
 * **User be authenticated to use this endpoint**
 */
export const useSuspenseGetCdrCurriculums = <
  TData = GetCdrCurriculumsResponse,
>(
  variables: GetCdrCurriculumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrCurriculumsResponse,
      GetCdrCurriculumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrCurriculumsResponse,
    GetCdrCurriculumsError,
    TData
  >({
    ...getCdrCurriculumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all curriculums.
 *
 * **User be authenticated to use this endpoint**
 */
export const useGetCdrCurriculums = <TData = GetCdrCurriculumsResponse,>(
  variables: GetCdrCurriculumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrCurriculumsResponse,
      GetCdrCurriculumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrCurriculumsResponse,
    GetCdrCurriculumsError,
    TData
  >({
    ...getCdrCurriculumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrCurriculumsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrCurriculumsVariables = {
  body: Schemas.CurriculumBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a curriculum.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPostCdrCurriculums = (
  variables: PostCdrCurriculumsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CurriculumComplete,
    PostCdrCurriculumsError,
    Schemas.CurriculumBase,
    {},
    {},
    {}
  >({ url: "/cdr/curriculums/", method: "post", ...variables, signal });

/**
 * Create a curriculum.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePostCdrCurriculums = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CurriculumComplete,
      PostCdrCurriculumsError,
      PostCdrCurriculumsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CurriculumComplete,
    PostCdrCurriculumsError,
    PostCdrCurriculumsVariables
  >({
    mutationFn: (variables: PostCdrCurriculumsVariables) =>
      fetchPostCdrCurriculums(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCdrCurriculumsCurriculumIdPathParams = {
  /**
   * @format uuid
   */
  curriculumId: string;
};

export type DeleteCdrCurriculumsCurriculumIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrCurriculumsCurriculumIdVariables = {
  pathParams: DeleteCdrCurriculumsCurriculumIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a curriculum.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchDeleteCdrCurriculumsCurriculumId = (
  variables: DeleteCdrCurriculumsCurriculumIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrCurriculumsCurriculumIdError,
    undefined,
    {},
    {},
    DeleteCdrCurriculumsCurriculumIdPathParams
  >({
    url: "/cdr/curriculums/{curriculumId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a curriculum.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useDeleteCdrCurriculumsCurriculumId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrCurriculumsCurriculumIdError,
      DeleteCdrCurriculumsCurriculumIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrCurriculumsCurriculumIdError,
    DeleteCdrCurriculumsCurriculumIdVariables
  >({
    mutationFn: (variables: DeleteCdrCurriculumsCurriculumIdVariables) =>
      fetchDeleteCdrCurriculumsCurriculumId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCdrUsersUserIdCurriculumsCurriculumIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  curriculumId: string;
};

export type PostCdrUsersUserIdCurriculumsCurriculumIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrUsersUserIdCurriculumsCurriculumIdVariables = {
  pathParams: PostCdrUsersUserIdCurriculumsCurriculumIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Add a curriculum to a user.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const fetchPostCdrUsersUserIdCurriculumsCurriculumId = (
  variables: PostCdrUsersUserIdCurriculumsCurriculumIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostCdrUsersUserIdCurriculumsCurriculumIdError,
    undefined,
    {},
    {},
    PostCdrUsersUserIdCurriculumsCurriculumIdPathParams
  >({
    url: "/cdr/users/{userId}/curriculums/{curriculumId}/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add a curriculum to a user.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const usePostCdrUsersUserIdCurriculumsCurriculumId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostCdrUsersUserIdCurriculumsCurriculumIdError,
      PostCdrUsersUserIdCurriculumsCurriculumIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostCdrUsersUserIdCurriculumsCurriculumIdError,
    PostCdrUsersUserIdCurriculumsCurriculumIdVariables
  >({
    mutationFn: (
      variables: PostCdrUsersUserIdCurriculumsCurriculumIdVariables,
    ) =>
      fetchPostCdrUsersUserIdCurriculumsCurriculumId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCdrUsersUserIdCurriculumsCurriculumIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  curriculumId: string;
};

export type PatchCdrUsersUserIdCurriculumsCurriculumIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrUsersUserIdCurriculumsCurriculumIdVariables = {
  pathParams: PatchCdrUsersUserIdCurriculumsCurriculumIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a curriculum membership.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const fetchPatchCdrUsersUserIdCurriculumsCurriculumId = (
  variables: PatchCdrUsersUserIdCurriculumsCurriculumIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCdrUsersUserIdCurriculumsCurriculumIdError,
    undefined,
    {},
    {},
    PatchCdrUsersUserIdCurriculumsCurriculumIdPathParams
  >({
    url: "/cdr/users/{userId}/curriculums/{curriculumId}/",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a curriculum membership.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const usePatchCdrUsersUserIdCurriculumsCurriculumId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrUsersUserIdCurriculumsCurriculumIdError,
      PatchCdrUsersUserIdCurriculumsCurriculumIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrUsersUserIdCurriculumsCurriculumIdError,
    PatchCdrUsersUserIdCurriculumsCurriculumIdVariables
  >({
    mutationFn: (
      variables: PatchCdrUsersUserIdCurriculumsCurriculumIdVariables,
    ) =>
      fetchPatchCdrUsersUserIdCurriculumsCurriculumId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrUsersUserIdCurriculumsCurriculumIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  curriculumId: string;
};

export type DeleteCdrUsersUserIdCurriculumsCurriculumIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables = {
  pathParams: DeleteCdrUsersUserIdCurriculumsCurriculumIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a curriculum from a user.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const fetchDeleteCdrUsersUserIdCurriculumsCurriculumId = (
  variables: DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdCurriculumsCurriculumIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdCurriculumsCurriculumIdPathParams
  >({
    url: "/cdr/users/{userId}/curriculums/{curriculumId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a curriculum from a user.
 *
 * **User must add a curriculum to themself or be CDR Admin to use this endpoint**
 */
export const useDeleteCdrUsersUserIdCurriculumsCurriculumId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdCurriculumsCurriculumIdError,
      DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdCurriculumsCurriculumIdError,
    DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrUsersUserIdCurriculumsCurriculumIdVariables,
    ) =>
      fetchDeleteCdrUsersUserIdCurriculumsCurriculumId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrUsersUserIdPaymentsPathParams = {
  userId: string;
};

export type GetCdrUsersUserIdPaymentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdPaymentsResponse =
  Schemas.AppModulesCdrSchemasCdrPaymentComplete[];

export type GetCdrUsersUserIdPaymentsVariables = {
  pathParams: GetCdrUsersUserIdPaymentsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const fetchGetCdrUsersUserIdPayments = (
  variables: GetCdrUsersUserIdPaymentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdPaymentsResponse,
    GetCdrUsersUserIdPaymentsError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdPaymentsPathParams
  >({
    url: "/cdr/users/{userId}/payments/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export function getCdrUsersUserIdPaymentsQuery(
  variables: GetCdrUsersUserIdPaymentsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrUsersUserIdPaymentsResponse>;
};

export function getCdrUsersUserIdPaymentsQuery(
  variables: GetCdrUsersUserIdPaymentsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersUserIdPaymentsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersUserIdPaymentsQuery(
  variables: GetCdrUsersUserIdPaymentsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/payments/",
      operationId: "getCdrUsersUserIdPayments",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersUserIdPayments(variables, signal),
  };
}

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCdrUsersUserIdPayments = <
  TData = GetCdrUsersUserIdPaymentsResponse,
>(
  variables: GetCdrUsersUserIdPaymentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdPaymentsResponse,
      GetCdrUsersUserIdPaymentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersUserIdPaymentsResponse,
    GetCdrUsersUserIdPaymentsError,
    TData
  >({
    ...getCdrUsersUserIdPaymentsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const useGetCdrUsersUserIdPayments = <
  TData = GetCdrUsersUserIdPaymentsResponse,
>(
  variables: GetCdrUsersUserIdPaymentsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdPaymentsResponse,
      GetCdrUsersUserIdPaymentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdPaymentsResponse,
    GetCdrUsersUserIdPaymentsError,
    TData
  >({
    ...getCdrUsersUserIdPaymentsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrUsersUserIdPaymentsPathParams = {
  userId: string;
};

export type PostCdrUsersUserIdPaymentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCdrUsersUserIdPaymentsVariables = {
  body: Schemas.AppModulesCdrSchemasCdrPaymentBase;
  pathParams: PostCdrUsersUserIdPaymentsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPostCdrUsersUserIdPayments = (
  variables: PostCdrUsersUserIdPaymentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesCdrSchemasCdrPaymentComplete,
    PostCdrUsersUserIdPaymentsError,
    Schemas.AppModulesCdrSchemasCdrPaymentBase,
    {},
    {},
    PostCdrUsersUserIdPaymentsPathParams
  >({
    url: "/cdr/users/{userId}/payments/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePostCdrUsersUserIdPayments = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesCdrSchemasCdrPaymentComplete,
      PostCdrUsersUserIdPaymentsError,
      PostCdrUsersUserIdPaymentsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesCdrSchemasCdrPaymentComplete,
    PostCdrUsersUserIdPaymentsError,
    PostCdrUsersUserIdPaymentsVariables
  >({
    mutationFn: (variables: PostCdrUsersUserIdPaymentsVariables) =>
      fetchPostCdrUsersUserIdPayments(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCdrUsersUserIdPaymentsPaymentIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  paymentId: string;
};

export type DeleteCdrUsersUserIdPaymentsPaymentIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCdrUsersUserIdPaymentsPaymentIdVariables = {
  pathParams: DeleteCdrUsersUserIdPaymentsPaymentIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchDeleteCdrUsersUserIdPaymentsPaymentId = (
  variables: DeleteCdrUsersUserIdPaymentsPaymentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrUsersUserIdPaymentsPaymentIdError,
    undefined,
    {},
    {},
    DeleteCdrUsersUserIdPaymentsPaymentIdPathParams
  >({
    url: "/cdr/users/{userId}/payments/{paymentId}/",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useDeleteCdrUsersUserIdPaymentsPaymentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrUsersUserIdPaymentsPaymentIdError,
      DeleteCdrUsersUserIdPaymentsPaymentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrUsersUserIdPaymentsPaymentIdError,
    DeleteCdrUsersUserIdPaymentsPaymentIdVariables
  >({
    mutationFn: (variables: DeleteCdrUsersUserIdPaymentsPaymentIdVariables) =>
      fetchDeleteCdrUsersUserIdPaymentsPaymentId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCdrPayError = Fetcher.ErrorWrapper<undefined>;

export type PostCdrPayVariables = HyperionContext["fetcherOptions"];

/**
 * Get payment url
 */
export const fetchPostCdrPay = (
  variables: PostCdrPayVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.PaymentUrl, PostCdrPayError, undefined, {}, {}, {}>({
    url: "/cdr/pay/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Get payment url
 */
export const usePostCdrPay = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaymentUrl,
      PostCdrPayError,
      PostCdrPayVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PaymentUrl,
    PostCdrPayError,
    PostCdrPayVariables
  >({
    mutationFn: (variables: PostCdrPayVariables) =>
      fetchPostCdrPay(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCdrStatusError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrStatusVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrStatus = (
  variables: GetCdrStatusVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.Status, GetCdrStatusError, undefined, {}, {}, {}>({
    url: "/cdr/status/",
    method: "get",
    ...variables,
    signal,
  });

export function getCdrStatusQuery(variables: GetCdrStatusVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Status>;
};

export function getCdrStatusQuery(
  variables: GetCdrStatusVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Status>)
    | reactQuery.SkipToken;
};

export function getCdrStatusQuery(
  variables: GetCdrStatusVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/status/",
      operationId: "getCdrStatus",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetCdrStatus(variables, signal),
  };
}

export const useSuspenseGetCdrStatus = <TData = Schemas.Status,>(
  variables: GetCdrStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Status, GetCdrStatusError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<Schemas.Status, GetCdrStatusError, TData>({
    ...getCdrStatusQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCdrStatus = <TData = Schemas.Status,>(
  variables: GetCdrStatusVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.Status, GetCdrStatusError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.Status, GetCdrStatusError, TData>({
    ...getCdrStatusQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCdrStatusError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCdrStatusVariables = {
  body?: Schemas.Status;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCdrStatus = (
  variables: PatchCdrStatusVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PatchCdrStatusError, Schemas.Status, {}, {}, {}>({
    url: "/cdr/status/",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCdrStatus = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCdrStatusError,
      PatchCdrStatusVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCdrStatusError,
    PatchCdrStatusVariables
  >({
    mutationFn: (variables: PatchCdrStatusVariables) =>
      fetchPatchCdrStatus(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCdrUsersMeTicketsError = Fetcher.ErrorWrapper<undefined>;

export type GetCdrUsersMeTicketsResponse = Schemas.Ticket[];

export type GetCdrUsersMeTicketsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersMeTickets = (
  variables: GetCdrUsersMeTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersMeTicketsResponse,
    GetCdrUsersMeTicketsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cdr/users/me/tickets/", method: "get", ...variables, signal });

export function getCdrUsersMeTicketsQuery(
  variables: GetCdrUsersMeTicketsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCdrUsersMeTicketsResponse>;
};

export function getCdrUsersMeTicketsQuery(
  variables: GetCdrUsersMeTicketsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersMeTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersMeTicketsQuery(
  variables: GetCdrUsersMeTicketsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/me/tickets/",
      operationId: "getCdrUsersMeTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersMeTickets(variables, signal),
  };
}

export const useSuspenseGetCdrUsersMeTickets = <
  TData = GetCdrUsersMeTicketsResponse,
>(
  variables: GetCdrUsersMeTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersMeTicketsResponse,
      GetCdrUsersMeTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersMeTicketsResponse,
    GetCdrUsersMeTicketsError,
    TData
  >({
    ...getCdrUsersMeTicketsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCdrUsersMeTickets = <TData = GetCdrUsersMeTicketsResponse,>(
  variables: GetCdrUsersMeTicketsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersMeTicketsResponse,
      GetCdrUsersMeTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersMeTicketsResponse,
    GetCdrUsersMeTicketsError,
    TData
  >({
    ...getCdrUsersMeTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrUsersUserIdTicketsPathParams = {
  userId: string;
};

export type GetCdrUsersUserIdTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersUserIdTicketsResponse = Schemas.Ticket[];

export type GetCdrUsersUserIdTicketsVariables = {
  pathParams: GetCdrUsersUserIdTicketsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersUserIdTickets = (
  variables: GetCdrUsersUserIdTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrUsersUserIdTicketsResponse,
    GetCdrUsersUserIdTicketsError,
    undefined,
    {},
    {},
    GetCdrUsersUserIdTicketsPathParams
  >({
    url: "/cdr/users/{userId}/tickets/",
    method: "get",
    ...variables,
    signal,
  });

export function getCdrUsersUserIdTicketsQuery(
  variables: GetCdrUsersUserIdTicketsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrUsersUserIdTicketsResponse>;
};

export function getCdrUsersUserIdTicketsQuery(
  variables: GetCdrUsersUserIdTicketsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCdrUsersUserIdTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getCdrUsersUserIdTicketsQuery(
  variables: GetCdrUsersUserIdTicketsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/{userId}/tickets/",
      operationId: "getCdrUsersUserIdTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersUserIdTickets(variables, signal),
  };
}

export const useSuspenseGetCdrUsersUserIdTickets = <
  TData = GetCdrUsersUserIdTicketsResponse,
>(
  variables: GetCdrUsersUserIdTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdTicketsResponse,
      GetCdrUsersUserIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrUsersUserIdTicketsResponse,
    GetCdrUsersUserIdTicketsError,
    TData
  >({
    ...getCdrUsersUserIdTicketsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCdrUsersUserIdTickets = <
  TData = GetCdrUsersUserIdTicketsResponse,
>(
  variables: GetCdrUsersUserIdTicketsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrUsersUserIdTicketsResponse,
      GetCdrUsersUserIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrUsersUserIdTicketsResponse,
    GetCdrUsersUserIdTicketsError,
    TData
  >({
    ...getCdrUsersUserIdTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrUsersMeTicketsTicketIdSecretPathParams = {
  /**
   * @format uuid
   */
  ticketId: string;
};

export type GetCdrUsersMeTicketsTicketIdSecretError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCdrUsersMeTicketsTicketIdSecretVariables = {
  pathParams: GetCdrUsersMeTicketsTicketIdSecretPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrUsersMeTicketsTicketIdSecret = (
  variables: GetCdrUsersMeTicketsTicketIdSecretVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.TicketSecret,
    GetCdrUsersMeTicketsTicketIdSecretError,
    undefined,
    {},
    {},
    GetCdrUsersMeTicketsTicketIdSecretPathParams
  >({
    url: "/cdr/users/me/tickets/{ticketId}/secret/",
    method: "get",
    ...variables,
    signal,
  });

export function getCdrUsersMeTicketsTicketIdSecretQuery(
  variables: GetCdrUsersMeTicketsTicketIdSecretVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.TicketSecret>;
};

export function getCdrUsersMeTicketsTicketIdSecretQuery(
  variables: GetCdrUsersMeTicketsTicketIdSecretVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.TicketSecret>)
    | reactQuery.SkipToken;
};

export function getCdrUsersMeTicketsTicketIdSecretQuery(
  variables: GetCdrUsersMeTicketsTicketIdSecretVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/users/me/tickets/{ticketId}/secret/",
      operationId: "getCdrUsersMeTicketsTicketIdSecret",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrUsersMeTicketsTicketIdSecret(variables, signal),
  };
}

export const useSuspenseGetCdrUsersMeTicketsTicketIdSecret = <
  TData = Schemas.TicketSecret,
>(
  variables: GetCdrUsersMeTicketsTicketIdSecretVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TicketSecret,
      GetCdrUsersMeTicketsTicketIdSecretError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.TicketSecret,
    GetCdrUsersMeTicketsTicketIdSecretError,
    TData
  >({
    ...getCdrUsersMeTicketsTicketIdSecretQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCdrUsersMeTicketsTicketIdSecret = <
  TData = Schemas.TicketSecret,
>(
  variables: GetCdrUsersMeTicketsTicketIdSecretVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TicketSecret,
      GetCdrUsersMeTicketsTicketIdSecretError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.TicketSecret,
    GetCdrUsersMeTicketsTicketIdSecretError,
    TData
  >({
    ...getCdrUsersMeTicketsTicketIdSecretQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    generatorId: string;
    /**
     * @format uuid
     */
    secret: string;
  };

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables =
  {
    pathParams: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret =
  (
    variables: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      Schemas.Ticket,
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
      undefined,
      {},
      {},
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/{secret}/",
      method: "get",
      ...variables,
      signal,
    });

export function getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQuery(
  variables: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Ticket>;
};

export function getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Ticket>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/{secret}/",
      operationId:
        "getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret(
              variables,
              signal,
            ),
  };
}

export const useSuspenseGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret =
  <TData = Schemas.Ticket,>(
    variables: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables,
    options?: Omit<
      reactQuery.UseQueryOptions<
        Schemas.Ticket,
        GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useSuspenseQuery<
      Schemas.Ticket,
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
      TData
    >({
      ...getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQuery(
        deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

export const useGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret =
  <TData = Schemas.Ticket,>(
    variables:
      | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables
      | reactQuery.SkipToken,
    options?: Omit<
      reactQuery.UseQueryOptions<
        Schemas.Ticket,
        GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useQuery<
      Schemas.Ticket,
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
      TData
    >({
      ...getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

export type PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    generatorId: string;
    /**
     * @format uuid
     */
    secret: string;
  };

export type PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables =
  {
    body: Schemas.TicketScan;
    pathParams: PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret =
  (
    variables: PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
      Schemas.TicketScan,
      {},
      {},
      PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/{secret}/",
      method: "patch",
      ...variables,
      signal,
    });

export const usePatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
        PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretError,
      PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables
    >({
      mutationFn: (
        variables: PatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables,
      ) =>
        fetchPatchCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret(
          deepMerge(fetcherOptions, variables),
        ),
      ...options,
    });
  };

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    generatorId: string;
    tag: string;
  };

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse =
  Schemas.CoreUserSimple[];

export type GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables =
  {
    pathParams: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag =
  (
    variables: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError,
      undefined,
      {},
      {},
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/lists/{tag}/",
      method: "get",
      ...variables,
      signal,
    });

export function getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQuery(
  variables: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse>;
};

export function getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/lists/{tag}/",
      operationId:
        "getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag(
              variables,
              signal,
            ),
  };
}

export const useSuspenseGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag =
  <
    TData = GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
  >(
    variables: GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables,
    options?: Omit<
      reactQuery.UseQueryOptions<
        GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
        GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useSuspenseQuery<
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError,
      TData
    >({
      ...getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQuery(
        deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

export const useGetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag =
  <
    TData = GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
  >(
    variables:
      | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables
      | reactQuery.SkipToken,
    options?: Omit<
      reactQuery.UseQueryOptions<
        GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
        GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useQuery<
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagResponse,
      GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagError,
      TData
    >({
      ...getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

export type GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
  /**
   * @format uuid
   */
  generatorId: string;
};

export type GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse =
  string[];

export type GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables = {
  pathParams: GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdProductsProductIdTagsGeneratorId = (
  variables: GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,
    GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/tags/{generatorId}/",
    method: "get",
    ...variables,
    signal,
  });

export function getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQuery(
  variables: GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse>;
};

export function getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/{productId}/tags/{generatorId}/",
      operationId: "getCdrSellersSellerIdProductsProductIdTagsGeneratorId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdProductsProductIdTagsGeneratorId(
              variables,
              signal,
            ),
  };
}

export const useSuspenseGetCdrSellersSellerIdProductsProductIdTagsGeneratorId =
  <TData = GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,>(
    variables: GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables,
    options?: Omit<
      reactQuery.UseQueryOptions<
        GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,
        GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useSuspenseQuery<
      GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,
      GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError,
      TData
    >({
      ...getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQuery(
        deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

export const useGetCdrSellersSellerIdProductsProductIdTagsGeneratorId = <
  TData = GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,
>(
  variables:
    | GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,
      GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdResponse,
    GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdError,
    TData
  >({
    ...getCdrSellersSellerIdProductsProductIdTagsGeneratorIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdProductsProductIdTicketsPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type PostCdrSellersSellerIdProductsProductIdTicketsError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdTicketsVariables = {
  body: Schemas.GenerateTicketBase;
  pathParams: PostCdrSellersSellerIdProductsProductIdTicketsPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProductsProductIdTickets = (
  variables: PostCdrSellersSellerIdProductsProductIdTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesCdrSchemasCdrProductComplete,
    PostCdrSellersSellerIdProductsProductIdTicketsError,
    Schemas.GenerateTicketBase,
    {},
    {},
    PostCdrSellersSellerIdProductsProductIdTicketsPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/tickets/",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrSellersSellerIdProductsProductIdTickets = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesCdrSchemasCdrProductComplete,
      PostCdrSellersSellerIdProductsProductIdTicketsError,
      PostCdrSellersSellerIdProductsProductIdTicketsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesCdrSchemasCdrProductComplete,
    PostCdrSellersSellerIdProductsProductIdTicketsError,
    PostCdrSellersSellerIdProductsProductIdTicketsVariables
  >({
    mutationFn: (
      variables: PostCdrSellersSellerIdProductsProductIdTicketsVariables,
    ) =>
      fetchPostCdrSellersSellerIdProductsProductIdTickets(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    /**
     * @format uuid
     */
    ticketGeneratorId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorId =
  (
    variables: DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError,
      undefined,
      {},
      {},
      DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{ticketGeneratorId}",
      method: "delete",
      ...variables,
      signal,
    });

export const useDeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError,
        DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdError,
      DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdVariables
    >({
      mutationFn: (
        variables: DeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorIdVariables,
      ) =>
        fetchDeleteCdrSellersSellerIdProductsProductIdTicketsTicketGeneratorId(
          deepMerge(fetcherOptions, variables),
        ),
      ...options,
    });
  };

export type GetCdrSellersSellerIdProductsProductIdDataPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type GetCdrSellersSellerIdProductsProductIdDataError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdProductsProductIdDataResponse =
  Schemas.CustomDataFieldComplete[];

export type GetCdrSellersSellerIdProductsProductIdDataVariables = {
  pathParams: GetCdrSellersSellerIdProductsProductIdDataPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdProductsProductIdData = (
  variables: GetCdrSellersSellerIdProductsProductIdDataVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCdrSellersSellerIdProductsProductIdDataResponse,
    GetCdrSellersSellerIdProductsProductIdDataError,
    undefined,
    {},
    {},
    GetCdrSellersSellerIdProductsProductIdDataPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/data/",
    method: "get",
    ...variables,
    signal,
  });

export function getCdrSellersSellerIdProductsProductIdDataQuery(
  variables: GetCdrSellersSellerIdProductsProductIdDataVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCdrSellersSellerIdProductsProductIdDataResponse>;
};

export function getCdrSellersSellerIdProductsProductIdDataQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdDataVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCdrSellersSellerIdProductsProductIdDataResponse>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdProductsProductIdDataQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdDataVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/{productId}/data/",
      operationId: "getCdrSellersSellerIdProductsProductIdData",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdProductsProductIdData(variables, signal),
  };
}

export const useSuspenseGetCdrSellersSellerIdProductsProductIdData = <
  TData = GetCdrSellersSellerIdProductsProductIdDataResponse,
>(
  variables: GetCdrSellersSellerIdProductsProductIdDataVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdProductsProductIdDataResponse,
      GetCdrSellersSellerIdProductsProductIdDataError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCdrSellersSellerIdProductsProductIdDataResponse,
    GetCdrSellersSellerIdProductsProductIdDataError,
    TData
  >({
    ...getCdrSellersSellerIdProductsProductIdDataQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCdrSellersSellerIdProductsProductIdData = <
  TData = GetCdrSellersSellerIdProductsProductIdDataResponse,
>(
  variables:
    | GetCdrSellersSellerIdProductsProductIdDataVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCdrSellersSellerIdProductsProductIdDataResponse,
      GetCdrSellersSellerIdProductsProductIdDataError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCdrSellersSellerIdProductsProductIdDataResponse,
    GetCdrSellersSellerIdProductsProductIdDataError,
    TData
  >({
    ...getCdrSellersSellerIdProductsProductIdDataQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdProductsProductIdDataPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
};

export type PostCdrSellersSellerIdProductsProductIdDataError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdDataVariables = {
  body: Schemas.CustomDataFieldBase;
  pathParams: PostCdrSellersSellerIdProductsProductIdDataPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProductsProductIdData = (
  variables: PostCdrSellersSellerIdProductsProductIdDataVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CustomDataFieldComplete,
    PostCdrSellersSellerIdProductsProductIdDataError,
    Schemas.CustomDataFieldBase,
    {},
    {},
    PostCdrSellersSellerIdProductsProductIdDataPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/data/",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCdrSellersSellerIdProductsProductIdData = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CustomDataFieldComplete,
      PostCdrSellersSellerIdProductsProductIdDataError,
      PostCdrSellersSellerIdProductsProductIdDataVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CustomDataFieldComplete,
    PostCdrSellersSellerIdProductsProductIdDataError,
    PostCdrSellersSellerIdProductsProductIdDataVariables
  >({
    mutationFn: (
      variables: PostCdrSellersSellerIdProductsProductIdDataVariables,
    ) =>
      fetchPostCdrSellersSellerIdProductsProductIdData(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCdrSellersSellerIdProductsProductIdDataFieldIdPathParams = {
  /**
   * @format uuid
   */
  sellerId: string;
  /**
   * @format uuid
   */
  productId: string;
  /**
   * @format uuid
   */
  fieldId: string;
};

export type DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdDataFieldIdVariables = {
  pathParams: DeleteCdrSellersSellerIdProductsProductIdDataFieldIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdDataFieldId = (
  variables: DeleteCdrSellersSellerIdProductsProductIdDataFieldIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError,
    undefined,
    {},
    {},
    DeleteCdrSellersSellerIdProductsProductIdDataFieldIdPathParams
  >({
    url: "/cdr/sellers/{sellerId}/products/{productId}/data/{fieldId}/",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCdrSellersSellerIdProductsProductIdDataFieldId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError,
      DeleteCdrSellersSellerIdProductsProductIdDataFieldIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCdrSellersSellerIdProductsProductIdDataFieldIdError,
    DeleteCdrSellersSellerIdProductsProductIdDataFieldIdVariables
  >({
    mutationFn: (
      variables: DeleteCdrSellersSellerIdProductsProductIdDataFieldIdVariables,
    ) =>
      fetchDeleteCdrSellersSellerIdProductsProductIdDataFieldId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    userId: string;
    /**
     * @format uuid
     */
    fieldId: string;
  };

export type GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables =
  {
    pathParams: GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchGetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    variables: GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      Schemas.CustomDataComplete,
      GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      undefined,
      {},
      {},
      GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/users/{userId}/data/{fieldId}/",
      method: "get",
      ...variables,
      signal,
    });

export function getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQuery(
  variables: GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CustomDataComplete>;
};

export function getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CustomDataComplete>)
    | reactQuery.SkipToken;
};

export function getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQuery(
  variables:
    | GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cdr/sellers/{sellerId}/products/{productId}/users/{userId}/data/{fieldId}/",
      operationId:
        "getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId(
              variables,
              signal,
            ),
  };
}

export const useSuspenseGetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  <TData = Schemas.CustomDataComplete,>(
    variables: GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
    options?: Omit<
      reactQuery.UseQueryOptions<
        Schemas.CustomDataComplete,
        GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useSuspenseQuery<
      Schemas.CustomDataComplete,
      GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      TData
    >({
      ...getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQuery(
        deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

export const useGetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId = <
  TData = Schemas.CustomDataComplete,
>(
  variables:
    | GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CustomDataComplete,
      GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CustomDataComplete,
    GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
    TData
  >({
    ...getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    userId: string;
    /**
     * @format uuid
     */
    fieldId: string;
  };

export type PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables =
  {
    body: Schemas.CustomDataBase;
    pathParams: PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    variables: PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      Schemas.CustomDataComplete,
      PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      Schemas.CustomDataBase,
      {},
      {},
      PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/users/{userId}/data/{fieldId}/",
      method: "post",
      ...variables,
      signal,
    });

export const usePostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        Schemas.CustomDataComplete,
        PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
        PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      Schemas.CustomDataComplete,
      PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
    >({
      mutationFn: (
        variables: PostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
      ) =>
        fetchPostCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId(
          deepMerge(fetcherOptions, variables),
        ),
      ...options,
    });
  };

export type PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    userId: string;
    /**
     * @format uuid
     */
    fieldId: string;
  };

export type PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables =
  {
    body: Schemas.CustomDataBase;
    pathParams: PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    variables: PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      Schemas.CustomDataBase,
      {},
      {},
      PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/users/{userId}/data/{fieldId}/",
      method: "patch",
      ...variables,
      signal,
    });

export const usePatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
        PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
    >({
      mutationFn: (
        variables: PatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
      ) =>
        fetchPatchCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId(
          deepMerge(fetcherOptions, variables),
        ),
      ...options,
    });
  };

export type DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams =
  {
    /**
     * @format uuid
     */
    sellerId: string;
    /**
     * @format uuid
     */
    productId: string;
    userId: string;
    /**
     * @format uuid
     */
    fieldId: string;
  };

export type DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables =
  {
    pathParams: DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchDeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    variables: DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      undefined,
      {},
      {},
      DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdPathParams
    >({
      url: "/cdr/sellers/{sellerId}/products/{productId}/users/{userId}/data/{fieldId}/",
      method: "delete",
      ...variables,
      signal,
    });

export const useDeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
        DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdError,
      DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
    >({
      mutationFn: (
        variables: DeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables,
      ) =>
        fetchDeleteCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId(
          deepMerge(fetcherOptions, variables),
        ),
      ...options,
    });
  };

export type GetCinemaThemoviedbThemoviedbIdPathParams = {
  themoviedbId: string;
};

export type GetCinemaThemoviedbThemoviedbIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCinemaThemoviedbThemoviedbIdVariables = {
  pathParams: GetCinemaThemoviedbThemoviedbIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Makes a HTTP request to The Movie Database (TMDB)
 * using an API key and returns a TheMovieDB object
 * * https://developer.themoviedb.org/reference/movie-details
 * * https://developer.themoviedb.org/docs/errors
 */
export const fetchGetCinemaThemoviedbThemoviedbId = (
  variables: GetCinemaThemoviedbThemoviedbIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.TheMovieDB,
    GetCinemaThemoviedbThemoviedbIdError,
    undefined,
    {},
    {},
    GetCinemaThemoviedbThemoviedbIdPathParams
  >({
    url: "/cinema/themoviedb/{themoviedbId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Makes a HTTP request to The Movie Database (TMDB)
 * using an API key and returns a TheMovieDB object
 * * https://developer.themoviedb.org/reference/movie-details
 * * https://developer.themoviedb.org/docs/errors
 */
export function getCinemaThemoviedbThemoviedbIdQuery(
  variables: GetCinemaThemoviedbThemoviedbIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.TheMovieDB>;
};

export function getCinemaThemoviedbThemoviedbIdQuery(
  variables: GetCinemaThemoviedbThemoviedbIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.TheMovieDB>)
    | reactQuery.SkipToken;
};

export function getCinemaThemoviedbThemoviedbIdQuery(
  variables: GetCinemaThemoviedbThemoviedbIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cinema/themoviedb/{themoviedbId}",
      operationId: "getCinemaThemoviedbThemoviedbId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCinemaThemoviedbThemoviedbId(variables, signal),
  };
}

/**
 * Makes a HTTP request to The Movie Database (TMDB)
 * using an API key and returns a TheMovieDB object
 * * https://developer.themoviedb.org/reference/movie-details
 * * https://developer.themoviedb.org/docs/errors
 */
export const useSuspenseGetCinemaThemoviedbThemoviedbId = <
  TData = Schemas.TheMovieDB,
>(
  variables: GetCinemaThemoviedbThemoviedbIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TheMovieDB,
      GetCinemaThemoviedbThemoviedbIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.TheMovieDB,
    GetCinemaThemoviedbThemoviedbIdError,
    TData
  >({
    ...getCinemaThemoviedbThemoviedbIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Makes a HTTP request to The Movie Database (TMDB)
 * using an API key and returns a TheMovieDB object
 * * https://developer.themoviedb.org/reference/movie-details
 * * https://developer.themoviedb.org/docs/errors
 */
export const useGetCinemaThemoviedbThemoviedbId = <TData = Schemas.TheMovieDB,>(
  variables: GetCinemaThemoviedbThemoviedbIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TheMovieDB,
      GetCinemaThemoviedbThemoviedbIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.TheMovieDB,
    GetCinemaThemoviedbThemoviedbIdError,
    TData
  >({
    ...getCinemaThemoviedbThemoviedbIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCinemaSessionsError = Fetcher.ErrorWrapper<undefined>;

export type GetCinemaSessionsResponse = Schemas.CineSessionComplete[];

export type GetCinemaSessionsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCinemaSessions = (
  variables: GetCinemaSessionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCinemaSessionsResponse,
    GetCinemaSessionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/cinema/sessions", method: "get", ...variables, signal });

export function getCinemaSessionsQuery(variables: GetCinemaSessionsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCinemaSessionsResponse>;
};

export function getCinemaSessionsQuery(
  variables: GetCinemaSessionsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCinemaSessionsResponse>)
    | reactQuery.SkipToken;
};

export function getCinemaSessionsQuery(
  variables: GetCinemaSessionsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cinema/sessions",
      operationId: "getCinemaSessions",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCinemaSessions(variables, signal),
  };
}

export const useSuspenseGetCinemaSessions = <
  TData = GetCinemaSessionsResponse,
>(
  variables: GetCinemaSessionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCinemaSessionsResponse,
      GetCinemaSessionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCinemaSessionsResponse,
    GetCinemaSessionsError,
    TData
  >({
    ...getCinemaSessionsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCinemaSessions = <TData = GetCinemaSessionsResponse,>(
  variables: GetCinemaSessionsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCinemaSessionsResponse,
      GetCinemaSessionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCinemaSessionsResponse,
    GetCinemaSessionsError,
    TData
  >({
    ...getCinemaSessionsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCinemaSessionsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCinemaSessionsVariables = {
  body: Schemas.CineSessionBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCinemaSessions = (
  variables: PostCinemaSessionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CineSessionComplete,
    PostCinemaSessionsError,
    Schemas.CineSessionBase,
    {},
    {},
    {}
  >({ url: "/cinema/sessions", method: "post", ...variables, signal });

export const usePostCinemaSessions = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CineSessionComplete,
      PostCinemaSessionsError,
      PostCinemaSessionsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CineSessionComplete,
    PostCinemaSessionsError,
    PostCinemaSessionsVariables
  >({
    mutationFn: (variables: PostCinemaSessionsVariables) =>
      fetchPostCinemaSessions(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchCinemaSessionsSessionIdPathParams = {
  sessionId: string;
};

export type PatchCinemaSessionsSessionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCinemaSessionsSessionIdVariables = {
  body?: Schemas.CineSessionUpdate;
  pathParams: PatchCinemaSessionsSessionIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCinemaSessionsSessionId = (
  variables: PatchCinemaSessionsSessionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PatchCinemaSessionsSessionIdError,
    Schemas.CineSessionUpdate,
    {},
    {},
    PatchCinemaSessionsSessionIdPathParams
  >({
    url: "/cinema/sessions/{sessionId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCinemaSessionsSessionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PatchCinemaSessionsSessionIdError,
      PatchCinemaSessionsSessionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PatchCinemaSessionsSessionIdError,
    PatchCinemaSessionsSessionIdVariables
  >({
    mutationFn: (variables: PatchCinemaSessionsSessionIdVariables) =>
      fetchPatchCinemaSessionsSessionId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCinemaSessionsSessionIdPathParams = {
  sessionId: string;
};

export type DeleteCinemaSessionsSessionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCinemaSessionsSessionIdVariables = {
  pathParams: DeleteCinemaSessionsSessionIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCinemaSessionsSessionId = (
  variables: DeleteCinemaSessionsSessionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCinemaSessionsSessionIdError,
    undefined,
    {},
    {},
    DeleteCinemaSessionsSessionIdPathParams
  >({
    url: "/cinema/sessions/{sessionId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCinemaSessionsSessionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCinemaSessionsSessionIdError,
      DeleteCinemaSessionsSessionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCinemaSessionsSessionIdError,
    DeleteCinemaSessionsSessionIdVariables
  >({
    mutationFn: (variables: DeleteCinemaSessionsSessionIdVariables) =>
      fetchDeleteCinemaSessionsSessionId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostCinemaSessionsSessionIdPosterPathParams = {
  sessionId: string;
};

export type PostCinemaSessionsSessionIdPosterError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCinemaSessionsSessionIdPosterVariables = {
  body: Schemas.BodyCreateCampaignsLogoCinemaSessionsSessionIdPosterPost;
  pathParams: PostCinemaSessionsSessionIdPosterPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCinemaSessionsSessionIdPoster = (
  variables: PostCinemaSessionsSessionIdPosterVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostCinemaSessionsSessionIdPosterError,
    Schemas.BodyCreateCampaignsLogoCinemaSessionsSessionIdPosterPost,
    {},
    {},
    PostCinemaSessionsSessionIdPosterPathParams
  >({
    url: "/cinema/sessions/{sessionId}/poster",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCinemaSessionsSessionIdPoster = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostCinemaSessionsSessionIdPosterError,
      PostCinemaSessionsSessionIdPosterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostCinemaSessionsSessionIdPosterError,
    PostCinemaSessionsSessionIdPosterVariables
  >({
    mutationFn: (variables: PostCinemaSessionsSessionIdPosterVariables) =>
      fetchPostCinemaSessionsSessionIdPoster(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCinemaSessionsSessionIdPosterPathParams = {
  sessionId: string;
};

export type GetCinemaSessionsSessionIdPosterError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCinemaSessionsSessionIdPosterVariables = {
  pathParams: GetCinemaSessionsSessionIdPosterPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCinemaSessionsSessionIdPoster = (
  variables: GetCinemaSessionsSessionIdPosterVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetCinemaSessionsSessionIdPosterError,
    undefined,
    {},
    {},
    GetCinemaSessionsSessionIdPosterPathParams
  >({
    url: "/cinema/sessions/{sessionId}/poster",
    method: "get",
    ...variables,
    signal,
  });

export function getCinemaSessionsSessionIdPosterQuery(
  variables: GetCinemaSessionsSessionIdPosterVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getCinemaSessionsSessionIdPosterQuery(
  variables: GetCinemaSessionsSessionIdPosterVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getCinemaSessionsSessionIdPosterQuery(
  variables: GetCinemaSessionsSessionIdPosterVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/cinema/sessions/{sessionId}/poster",
      operationId: "getCinemaSessionsSessionIdPoster",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCinemaSessionsSessionIdPoster(variables, signal),
  };
}

export const useSuspenseGetCinemaSessionsSessionIdPoster = <TData = undefined,>(
  variables: GetCinemaSessionsSessionIdPosterVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCinemaSessionsSessionIdPosterError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetCinemaSessionsSessionIdPosterError,
    TData
  >({
    ...getCinemaSessionsSessionIdPosterQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCinemaSessionsSessionIdPoster = <TData = undefined,>(
  variables: GetCinemaSessionsSessionIdPosterVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetCinemaSessionsSessionIdPosterError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetCinemaSessionsSessionIdPosterError,
    TData
  >({
    ...getCinemaSessionsSessionIdPosterQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaRafflesError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaRafflesResponse = Schemas.RaffleComplete[];

export type GetTombolaRafflesVariables = HyperionContext["fetcherOptions"];

/**
 * Return all raffles
 */
export const fetchGetTombolaRaffles = (
  variables: GetTombolaRafflesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesResponse,
    GetTombolaRafflesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/raffles", method: "get", ...variables, signal });

/**
 * Return all raffles
 */
export function getTombolaRafflesQuery(variables: GetTombolaRafflesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetTombolaRafflesResponse>;
};

export function getTombolaRafflesQuery(
  variables: GetTombolaRafflesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetTombolaRafflesResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaRafflesQuery(
  variables: GetTombolaRafflesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/raffles",
      operationId: "getTombolaRaffles",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaRaffles(variables, signal),
  };
}

/**
 * Return all raffles
 */
export const useSuspenseGetTombolaRaffles = <
  TData = GetTombolaRafflesResponse,
>(
  variables: GetTombolaRafflesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesResponse,
      GetTombolaRafflesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaRafflesResponse,
    GetTombolaRafflesError,
    TData
  >({
    ...getTombolaRafflesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all raffles
 */
export const useGetTombolaRaffles = <TData = GetTombolaRafflesResponse,>(
  variables: GetTombolaRafflesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesResponse,
      GetTombolaRafflesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesResponse,
    GetTombolaRafflesError,
    TData
  >({
    ...getTombolaRafflesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaRafflesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaRafflesVariables = {
  body: Schemas.RaffleBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new raffle
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchPostTombolaRaffles = (
  variables: PostTombolaRafflesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaffleComplete,
    PostTombolaRafflesError,
    Schemas.RaffleBase,
    {},
    {},
    {}
  >({ url: "/tombola/raffles", method: "post", ...variables, signal });

/**
 * Create a new raffle
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const usePostTombolaRaffles = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RaffleComplete,
      PostTombolaRafflesError,
      PostTombolaRafflesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RaffleComplete,
    PostTombolaRafflesError,
    PostTombolaRafflesVariables
  >({
    mutationFn: (variables: PostTombolaRafflesVariables) =>
      fetchPostTombolaRaffles(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchTombolaRafflesRaffleIdPathParams = {
  raffleId: string;
};

export type PatchTombolaRafflesRaffleIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaRafflesRaffleIdVariables = {
  body?: Schemas.RaffleEdit;
  pathParams: PatchTombolaRafflesRaffleIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaRafflesRaffleId = (
  variables: PatchTombolaRafflesRaffleIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaRafflesRaffleIdError,
    Schemas.RaffleEdit,
    {},
    {},
    PatchTombolaRafflesRaffleIdPathParams
  >({
    url: "/tombola/raffles/{raffleId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaRafflesRaffleId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaRafflesRaffleIdError,
      PatchTombolaRafflesRaffleIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaRafflesRaffleIdError,
    PatchTombolaRafflesRaffleIdVariables
  >({
    mutationFn: (variables: PatchTombolaRafflesRaffleIdVariables) =>
      fetchPatchTombolaRafflesRaffleId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteTombolaRafflesRaffleIdPathParams = {
  raffleId: string;
};

export type DeleteTombolaRafflesRaffleIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteTombolaRafflesRaffleIdVariables = {
  pathParams: DeleteTombolaRafflesRaffleIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchDeleteTombolaRafflesRaffleId = (
  variables: DeleteTombolaRafflesRaffleIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteTombolaRafflesRaffleIdError,
    undefined,
    {},
    {},
    DeleteTombolaRafflesRaffleIdPathParams
  >({
    url: "/tombola/raffles/{raffleId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const useDeleteTombolaRafflesRaffleId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteTombolaRafflesRaffleIdError,
      DeleteTombolaRafflesRaffleIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteTombolaRafflesRaffleIdError,
    DeleteTombolaRafflesRaffleIdVariables
  >({
    mutationFn: (variables: DeleteTombolaRafflesRaffleIdVariables) =>
      fetchDeleteTombolaRafflesRaffleId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetTombolaGroupGroupIdRafflesPathParams = {
  groupId: string;
};

export type GetTombolaGroupGroupIdRafflesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaGroupGroupIdRafflesResponse = Schemas.RaffleComplete[];

export type GetTombolaGroupGroupIdRafflesVariables = {
  pathParams: GetTombolaGroupGroupIdRafflesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all raffles from a group
 */
export const fetchGetTombolaGroupGroupIdRaffles = (
  variables: GetTombolaGroupGroupIdRafflesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaGroupGroupIdRafflesResponse,
    GetTombolaGroupGroupIdRafflesError,
    undefined,
    {},
    {},
    GetTombolaGroupGroupIdRafflesPathParams
  >({
    url: "/tombola/group/{groupId}/raffles",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all raffles from a group
 */
export function getTombolaGroupGroupIdRafflesQuery(
  variables: GetTombolaGroupGroupIdRafflesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetTombolaGroupGroupIdRafflesResponse>;
};

export function getTombolaGroupGroupIdRafflesQuery(
  variables: GetTombolaGroupGroupIdRafflesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetTombolaGroupGroupIdRafflesResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaGroupGroupIdRafflesQuery(
  variables: GetTombolaGroupGroupIdRafflesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/group/{groupId}/raffles",
      operationId: "getTombolaGroupGroupIdRaffles",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaGroupGroupIdRaffles(variables, signal),
  };
}

/**
 * Return all raffles from a group
 */
export const useSuspenseGetTombolaGroupGroupIdRaffles = <
  TData = GetTombolaGroupGroupIdRafflesResponse,
>(
  variables: GetTombolaGroupGroupIdRafflesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaGroupGroupIdRafflesResponse,
      GetTombolaGroupGroupIdRafflesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaGroupGroupIdRafflesResponse,
    GetTombolaGroupGroupIdRafflesError,
    TData
  >({
    ...getTombolaGroupGroupIdRafflesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all raffles from a group
 */
export const useGetTombolaGroupGroupIdRaffles = <
  TData = GetTombolaGroupGroupIdRafflesResponse,
>(
  variables: GetTombolaGroupGroupIdRafflesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaGroupGroupIdRafflesResponse,
      GetTombolaGroupGroupIdRafflesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaGroupGroupIdRafflesResponse,
    GetTombolaGroupGroupIdRafflesError,
    TData
  >({
    ...getTombolaGroupGroupIdRafflesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaRafflesRaffleIdStatsPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdStatsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdStatsVariables = {
  pathParams: GetTombolaRafflesRaffleIdStatsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export const fetchGetTombolaRafflesRaffleIdStats = (
  variables: GetTombolaRafflesRaffleIdStatsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaffleStats,
    GetTombolaRafflesRaffleIdStatsError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdStatsPathParams
  >({
    url: "/tombola/raffles/{raffleId}/stats",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export function getTombolaRafflesRaffleIdStatsQuery(
  variables: GetTombolaRafflesRaffleIdStatsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RaffleStats>;
};

export function getTombolaRafflesRaffleIdStatsQuery(
  variables: GetTombolaRafflesRaffleIdStatsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaffleStats>)
    | reactQuery.SkipToken;
};

export function getTombolaRafflesRaffleIdStatsQuery(
  variables: GetTombolaRafflesRaffleIdStatsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/stats",
      operationId: "getTombolaRafflesRaffleIdStats",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaRafflesRaffleIdStats(variables, signal),
  };
}

/**
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export const useSuspenseGetTombolaRafflesRaffleIdStats = <
  TData = Schemas.RaffleStats,
>(
  variables: GetTombolaRafflesRaffleIdStatsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaffleStats,
      GetTombolaRafflesRaffleIdStatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaffleStats,
    GetTombolaRafflesRaffleIdStatsError,
    TData
  >({
    ...getTombolaRafflesRaffleIdStatsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the number of ticket sold and the total amount recollected for a raffle
 */
export const useGetTombolaRafflesRaffleIdStats = <TData = Schemas.RaffleStats,>(
  variables: GetTombolaRafflesRaffleIdStatsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaffleStats,
      GetTombolaRafflesRaffleIdStatsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RaffleStats,
    GetTombolaRafflesRaffleIdStatsError,
    TData
  >({
    ...getTombolaRafflesRaffleIdStatsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaRafflesRaffleIdLogoPathParams = {
  raffleId: string;
};

export type PostTombolaRafflesRaffleIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaRafflesRaffleIdLogoVariables = {
  body: Schemas.BodyCreateCurrentRaffleLogoTombolaRafflesRaffleIdLogoPost;
  pathParams: PostTombolaRafflesRaffleIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPostTombolaRafflesRaffleIdLogo = (
  variables: PostTombolaRafflesRaffleIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostTombolaRafflesRaffleIdLogoError,
    Schemas.BodyCreateCurrentRaffleLogoTombolaRafflesRaffleIdLogoPost,
    {},
    {},
    PostTombolaRafflesRaffleIdLogoPathParams
  >({
    url: "/tombola/raffles/{raffleId}/logo",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePostTombolaRafflesRaffleIdLogo = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostTombolaRafflesRaffleIdLogoError,
      PostTombolaRafflesRaffleIdLogoVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostTombolaRafflesRaffleIdLogoError,
    PostTombolaRafflesRaffleIdLogoVariables
  >({
    mutationFn: (variables: PostTombolaRafflesRaffleIdLogoVariables) =>
      fetchPostTombolaRafflesRaffleIdLogo(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetTombolaRafflesRaffleIdLogoPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdLogoError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdLogoVariables = {
  pathParams: GetTombolaRafflesRaffleIdLogoPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of a specific raffle.
 */
export const fetchGetTombolaRafflesRaffleIdLogo = (
  variables: GetTombolaRafflesRaffleIdLogoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetTombolaRafflesRaffleIdLogoError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdLogoPathParams
  >({
    url: "/tombola/raffles/{raffleId}/logo",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of a specific raffle.
 */
export function getTombolaRafflesRaffleIdLogoQuery(
  variables: GetTombolaRafflesRaffleIdLogoVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getTombolaRafflesRaffleIdLogoQuery(
  variables: GetTombolaRafflesRaffleIdLogoVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getTombolaRafflesRaffleIdLogoQuery(
  variables: GetTombolaRafflesRaffleIdLogoVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/logo",
      operationId: "getTombolaRafflesRaffleIdLogo",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaRafflesRaffleIdLogo(variables, signal),
  };
}

/**
 * Get the logo of a specific raffle.
 */
export const useSuspenseGetTombolaRafflesRaffleIdLogo = <TData = undefined,>(
  variables: GetTombolaRafflesRaffleIdLogoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetTombolaRafflesRaffleIdLogoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetTombolaRafflesRaffleIdLogoError,
    TData
  >({
    ...getTombolaRafflesRaffleIdLogoQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the logo of a specific raffle.
 */
export const useGetTombolaRafflesRaffleIdLogo = <TData = undefined,>(
  variables: GetTombolaRafflesRaffleIdLogoVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetTombolaRafflesRaffleIdLogoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetTombolaRafflesRaffleIdLogoError,
    TData
  >({
    ...getTombolaRafflesRaffleIdLogoQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaPackTicketsError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaPackTicketsResponse = Schemas.PackTicketSimple[];

export type GetTombolaPackTicketsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all tickets
 */
export const fetchGetTombolaPackTickets = (
  variables: GetTombolaPackTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaPackTicketsResponse,
    GetTombolaPackTicketsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/pack_tickets", method: "get", ...variables, signal });

/**
 * Return all tickets
 */
export function getTombolaPackTicketsQuery(
  variables: GetTombolaPackTicketsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetTombolaPackTicketsResponse>;
};

export function getTombolaPackTicketsQuery(
  variables: GetTombolaPackTicketsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetTombolaPackTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaPackTicketsQuery(
  variables: GetTombolaPackTicketsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/pack_tickets",
      operationId: "getTombolaPackTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaPackTickets(variables, signal),
  };
}

/**
 * Return all tickets
 */
export const useSuspenseGetTombolaPackTickets = <
  TData = GetTombolaPackTicketsResponse,
>(
  variables: GetTombolaPackTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaPackTicketsResponse,
      GetTombolaPackTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaPackTicketsResponse,
    GetTombolaPackTicketsError,
    TData
  >({
    ...getTombolaPackTicketsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all tickets
 */
export const useGetTombolaPackTickets = <
  TData = GetTombolaPackTicketsResponse,
>(
  variables: GetTombolaPackTicketsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaPackTicketsResponse,
      GetTombolaPackTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaPackTicketsResponse,
    GetTombolaPackTicketsError,
    TData
  >({
    ...getTombolaPackTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaPackTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPackTicketsVariables = {
  body: Schemas.PackTicketBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPostTombolaPackTickets = (
  variables: PostTombolaPackTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PackTicketSimple,
    PostTombolaPackTicketsError,
    Schemas.PackTicketBase,
    {},
    {},
    {}
  >({ url: "/tombola/pack_tickets", method: "post", ...variables, signal });

/**
 * Create a new packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePostTombolaPackTickets = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PackTicketSimple,
      PostTombolaPackTicketsError,
      PostTombolaPackTicketsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PackTicketSimple,
    PostTombolaPackTicketsError,
    PostTombolaPackTicketsVariables
  >({
    mutationFn: (variables: PostTombolaPackTicketsVariables) =>
      fetchPostTombolaPackTickets(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchTombolaPackTicketsPackticketIdPathParams = {
  packticketId: string;
};

export type PatchTombolaPackTicketsPackticketIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaPackTicketsPackticketIdVariables = {
  body?: Schemas.PackTicketEdit;
  pathParams: PatchTombolaPackTicketsPackticketIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaPackTicketsPackticketId = (
  variables: PatchTombolaPackTicketsPackticketIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaPackTicketsPackticketIdError,
    Schemas.PackTicketEdit,
    {},
    {},
    PatchTombolaPackTicketsPackticketIdPathParams
  >({
    url: "/tombola/pack_tickets/{packticketId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a packticket
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaPackTicketsPackticketId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaPackTicketsPackticketIdError,
      PatchTombolaPackTicketsPackticketIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaPackTicketsPackticketIdError,
    PatchTombolaPackTicketsPackticketIdVariables
  >({
    mutationFn: (variables: PatchTombolaPackTicketsPackticketIdVariables) =>
      fetchPatchTombolaPackTicketsPackticketId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteTombolaPackTicketsPackticketIdPathParams = {
  packticketId: string;
};

export type DeleteTombolaPackTicketsPackticketIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteTombolaPackTicketsPackticketIdVariables = {
  pathParams: DeleteTombolaPackTicketsPackticketIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a packticket.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchDeleteTombolaPackTicketsPackticketId = (
  variables: DeleteTombolaPackTicketsPackticketIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteTombolaPackTicketsPackticketIdError,
    undefined,
    {},
    {},
    DeleteTombolaPackTicketsPackticketIdPathParams
  >({
    url: "/tombola/pack_tickets/{packticketId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a packticket.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const useDeleteTombolaPackTicketsPackticketId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteTombolaPackTicketsPackticketIdError,
      DeleteTombolaPackTicketsPackticketIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteTombolaPackTicketsPackticketIdError,
    DeleteTombolaPackTicketsPackticketIdVariables
  >({
    mutationFn: (variables: DeleteTombolaPackTicketsPackticketIdVariables) =>
      fetchDeleteTombolaPackTicketsPackticketId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetTombolaRafflesRaffleIdPackTicketsPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdPackTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdPackTicketsResponse =
  Schemas.PackTicketSimple[];

export type GetTombolaRafflesRaffleIdPackTicketsVariables = {
  pathParams: GetTombolaRafflesRaffleIdPackTicketsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all pack_tickets associated to a raffle
 */
export const fetchGetTombolaRafflesRaffleIdPackTickets = (
  variables: GetTombolaRafflesRaffleIdPackTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesRaffleIdPackTicketsResponse,
    GetTombolaRafflesRaffleIdPackTicketsError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdPackTicketsPathParams
  >({
    url: "/tombola/raffles/{raffleId}/pack_tickets",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all pack_tickets associated to a raffle
 */
export function getTombolaRafflesRaffleIdPackTicketsQuery(
  variables: GetTombolaRafflesRaffleIdPackTicketsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetTombolaRafflesRaffleIdPackTicketsResponse>;
};

export function getTombolaRafflesRaffleIdPackTicketsQuery(
  variables:
    | GetTombolaRafflesRaffleIdPackTicketsVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetTombolaRafflesRaffleIdPackTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaRafflesRaffleIdPackTicketsQuery(
  variables:
    | GetTombolaRafflesRaffleIdPackTicketsVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/pack_tickets",
      operationId: "getTombolaRafflesRaffleIdPackTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaRafflesRaffleIdPackTickets(variables, signal),
  };
}

/**
 * Return all pack_tickets associated to a raffle
 */
export const useSuspenseGetTombolaRafflesRaffleIdPackTickets = <
  TData = GetTombolaRafflesRaffleIdPackTicketsResponse,
>(
  variables: GetTombolaRafflesRaffleIdPackTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdPackTicketsResponse,
      GetTombolaRafflesRaffleIdPackTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaRafflesRaffleIdPackTicketsResponse,
    GetTombolaRafflesRaffleIdPackTicketsError,
    TData
  >({
    ...getTombolaRafflesRaffleIdPackTicketsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all pack_tickets associated to a raffle
 */
export const useGetTombolaRafflesRaffleIdPackTickets = <
  TData = GetTombolaRafflesRaffleIdPackTicketsResponse,
>(
  variables:
    | GetTombolaRafflesRaffleIdPackTicketsVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdPackTicketsResponse,
      GetTombolaRafflesRaffleIdPackTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesRaffleIdPackTicketsResponse,
    GetTombolaRafflesRaffleIdPackTicketsError,
    TData
  >({
    ...getTombolaRafflesRaffleIdPackTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaTicketsError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaTicketsResponse = Schemas.TicketSimple[];

export type GetTombolaTicketsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchGetTombolaTickets = (
  variables: GetTombolaTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaTicketsResponse,
    GetTombolaTicketsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/tickets", method: "get", ...variables, signal });

/**
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export function getTombolaTicketsQuery(variables: GetTombolaTicketsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetTombolaTicketsResponse>;
};

export function getTombolaTicketsQuery(
  variables: GetTombolaTicketsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetTombolaTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaTicketsQuery(
  variables: GetTombolaTicketsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/tickets",
      operationId: "getTombolaTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaTickets(variables, signal),
  };
}

/**
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const useSuspenseGetTombolaTickets = <
  TData = GetTombolaTicketsResponse,
>(
  variables: GetTombolaTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaTicketsResponse,
      GetTombolaTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaTicketsResponse,
    GetTombolaTicketsError,
    TData
  >({
    ...getTombolaTicketsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all tickets
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const useGetTombolaTickets = <TData = GetTombolaTicketsResponse,>(
  variables: GetTombolaTicketsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaTicketsResponse,
      GetTombolaTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaTicketsResponse,
    GetTombolaTicketsError,
    TData
  >({
    ...getTombolaTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaTicketsBuyPackIdPathParams = {
  packId: string;
};

export type PostTombolaTicketsBuyPackIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaTicketsBuyPackIdResponse = Schemas.TicketComplete[];

export type PostTombolaTicketsBuyPackIdVariables = {
  pathParams: PostTombolaTicketsBuyPackIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Buy a ticket
 */
export const fetchPostTombolaTicketsBuyPackId = (
  variables: PostTombolaTicketsBuyPackIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    PostTombolaTicketsBuyPackIdResponse,
    PostTombolaTicketsBuyPackIdError,
    undefined,
    {},
    {},
    PostTombolaTicketsBuyPackIdPathParams
  >({
    url: "/tombola/tickets/buy/{packId}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Buy a ticket
 */
export const usePostTombolaTicketsBuyPackId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      PostTombolaTicketsBuyPackIdResponse,
      PostTombolaTicketsBuyPackIdError,
      PostTombolaTicketsBuyPackIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    PostTombolaTicketsBuyPackIdResponse,
    PostTombolaTicketsBuyPackIdError,
    PostTombolaTicketsBuyPackIdVariables
  >({
    mutationFn: (variables: PostTombolaTicketsBuyPackIdVariables) =>
      fetchPostTombolaTicketsBuyPackId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetTombolaUsersUserIdTicketsPathParams = {
  userId: string;
};

export type GetTombolaUsersUserIdTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaUsersUserIdTicketsResponse = Schemas.TicketComplete[];

export type GetTombolaUsersUserIdTicketsVariables = {
  pathParams: GetTombolaUsersUserIdTicketsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export const fetchGetTombolaUsersUserIdTickets = (
  variables: GetTombolaUsersUserIdTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaUsersUserIdTicketsResponse,
    GetTombolaUsersUserIdTicketsError,
    undefined,
    {},
    {},
    GetTombolaUsersUserIdTicketsPathParams
  >({
    url: "/tombola/users/{userId}/tickets",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export function getTombolaUsersUserIdTicketsQuery(
  variables: GetTombolaUsersUserIdTicketsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetTombolaUsersUserIdTicketsResponse>;
};

export function getTombolaUsersUserIdTicketsQuery(
  variables: GetTombolaUsersUserIdTicketsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetTombolaUsersUserIdTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaUsersUserIdTicketsQuery(
  variables: GetTombolaUsersUserIdTicketsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/users/{userId}/tickets",
      operationId: "getTombolaUsersUserIdTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaUsersUserIdTickets(variables, signal),
  };
}

/**
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export const useSuspenseGetTombolaUsersUserIdTickets = <
  TData = GetTombolaUsersUserIdTicketsResponse,
>(
  variables: GetTombolaUsersUserIdTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaUsersUserIdTicketsResponse,
      GetTombolaUsersUserIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaUsersUserIdTicketsResponse,
    GetTombolaUsersUserIdTicketsError,
    TData
  >({
    ...getTombolaUsersUserIdTicketsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get tickets of a specific user.
 *
 * **Only admin users can get tickets of another user**
 */
export const useGetTombolaUsersUserIdTickets = <
  TData = GetTombolaUsersUserIdTicketsResponse,
>(
  variables: GetTombolaUsersUserIdTicketsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaUsersUserIdTicketsResponse,
      GetTombolaUsersUserIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaUsersUserIdTicketsResponse,
    GetTombolaUsersUserIdTicketsError,
    TData
  >({
    ...getTombolaUsersUserIdTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaRafflesRaffleIdTicketsPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdTicketsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdTicketsResponse = Schemas.TicketComplete[];

export type GetTombolaRafflesRaffleIdTicketsVariables = {
  pathParams: GetTombolaRafflesRaffleIdTicketsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const fetchGetTombolaRafflesRaffleIdTickets = (
  variables: GetTombolaRafflesRaffleIdTicketsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesRaffleIdTicketsResponse,
    GetTombolaRafflesRaffleIdTicketsError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdTicketsPathParams
  >({
    url: "/tombola/raffles/{raffleId}/tickets",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export function getTombolaRafflesRaffleIdTicketsQuery(
  variables: GetTombolaRafflesRaffleIdTicketsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetTombolaRafflesRaffleIdTicketsResponse>;
};

export function getTombolaRafflesRaffleIdTicketsQuery(
  variables: GetTombolaRafflesRaffleIdTicketsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetTombolaRafflesRaffleIdTicketsResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaRafflesRaffleIdTicketsQuery(
  variables: GetTombolaRafflesRaffleIdTicketsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/tickets",
      operationId: "getTombolaRafflesRaffleIdTickets",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaRafflesRaffleIdTickets(variables, signal),
  };
}

/**
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const useSuspenseGetTombolaRafflesRaffleIdTickets = <
  TData = GetTombolaRafflesRaffleIdTicketsResponse,
>(
  variables: GetTombolaRafflesRaffleIdTicketsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdTicketsResponse,
      GetTombolaRafflesRaffleIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaRafflesRaffleIdTicketsResponse,
    GetTombolaRafflesRaffleIdTicketsError,
    TData
  >({
    ...getTombolaRafflesRaffleIdTicketsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get tickets from a specific raffle.
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const useGetTombolaRafflesRaffleIdTickets = <
  TData = GetTombolaRafflesRaffleIdTicketsResponse,
>(
  variables: GetTombolaRafflesRaffleIdTicketsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdTicketsResponse,
      GetTombolaRafflesRaffleIdTicketsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesRaffleIdTicketsResponse,
    GetTombolaRafflesRaffleIdTicketsError,
    TData
  >({
    ...getTombolaRafflesRaffleIdTicketsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaPrizesError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaPrizesResponse = Schemas.PrizeSimple[];

export type GetTombolaPrizesVariables = HyperionContext["fetcherOptions"];

/**
 * Return all prizes
 */
export const fetchGetTombolaPrizes = (
  variables: GetTombolaPrizesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaPrizesResponse,
    GetTombolaPrizesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/prizes", method: "get", ...variables, signal });

/**
 * Return all prizes
 */
export function getTombolaPrizesQuery(variables: GetTombolaPrizesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetTombolaPrizesResponse>;
};

export function getTombolaPrizesQuery(
  variables: GetTombolaPrizesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetTombolaPrizesResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaPrizesQuery(
  variables: GetTombolaPrizesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/prizes",
      operationId: "getTombolaPrizes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaPrizes(variables, signal),
  };
}

/**
 * Return all prizes
 */
export const useSuspenseGetTombolaPrizes = <TData = GetTombolaPrizesResponse,>(
  variables: GetTombolaPrizesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaPrizesResponse,
      GetTombolaPrizesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaPrizesResponse,
    GetTombolaPrizesError,
    TData
  >({
    ...getTombolaPrizesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all prizes
 */
export const useGetTombolaPrizes = <TData = GetTombolaPrizesResponse,>(
  variables: GetTombolaPrizesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaPrizesResponse,
      GetTombolaPrizesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaPrizesResponse,
    GetTombolaPrizesError,
    TData
  >({
    ...getTombolaPrizesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaPrizesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPrizesVariables = {
  body: Schemas.PrizeBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new prize
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const fetchPostTombolaPrizes = (
  variables: PostTombolaPrizesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PrizeSimple,
    PostTombolaPrizesError,
    Schemas.PrizeBase,
    {},
    {},
    {}
  >({ url: "/tombola/prizes", method: "post", ...variables, signal });

/**
 * Create a new prize
 *
 * **The user must be a member of the raffle's group to use this endpoint
 */
export const usePostTombolaPrizes = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PrizeSimple,
      PostTombolaPrizesError,
      PostTombolaPrizesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PrizeSimple,
    PostTombolaPrizesError,
    PostTombolaPrizesVariables
  >({
    mutationFn: (variables: PostTombolaPrizesVariables) =>
      fetchPostTombolaPrizes(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchTombolaPrizesPrizeIdPathParams = {
  prizeId: string;
};

export type PatchTombolaPrizesPrizeIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaPrizesPrizeIdVariables = {
  body?: Schemas.PrizeEdit;
  pathParams: PatchTombolaPrizesPrizeIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a prize
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const fetchPatchTombolaPrizesPrizeId = (
  variables: PatchTombolaPrizesPrizeIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaPrizesPrizeIdError,
    Schemas.PrizeEdit,
    {},
    {},
    PatchTombolaPrizesPrizeIdPathParams
  >({
    url: "/tombola/prizes/{prizeId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a prize
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const usePatchTombolaPrizesPrizeId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaPrizesPrizeIdError,
      PatchTombolaPrizesPrizeIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaPrizesPrizeIdError,
    PatchTombolaPrizesPrizeIdVariables
  >({
    mutationFn: (variables: PatchTombolaPrizesPrizeIdVariables) =>
      fetchPatchTombolaPrizesPrizeId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteTombolaPrizesPrizeIdPathParams = {
  prizeId: string;
};

export type DeleteTombolaPrizesPrizeIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteTombolaPrizesPrizeIdVariables = {
  pathParams: DeleteTombolaPrizesPrizeIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a prize.
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const fetchDeleteTombolaPrizesPrizeId = (
  variables: DeleteTombolaPrizesPrizeIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteTombolaPrizesPrizeIdError,
    undefined,
    {},
    {},
    DeleteTombolaPrizesPrizeIdPathParams
  >({
    url: "/tombola/prizes/{prizeId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a prize.
 *
 * **The user must be a member of the group raffle's to use this endpoint
 */
export const useDeleteTombolaPrizesPrizeId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteTombolaPrizesPrizeIdError,
      DeleteTombolaPrizesPrizeIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteTombolaPrizesPrizeIdError,
    DeleteTombolaPrizesPrizeIdVariables
  >({
    mutationFn: (variables: DeleteTombolaPrizesPrizeIdVariables) =>
      fetchDeleteTombolaPrizesPrizeId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetTombolaRafflesRaffleIdPrizesPathParams = {
  raffleId: string;
};

export type GetTombolaRafflesRaffleIdPrizesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaRafflesRaffleIdPrizesResponse = Schemas.PrizeSimple[];

export type GetTombolaRafflesRaffleIdPrizesVariables = {
  pathParams: GetTombolaRafflesRaffleIdPrizesPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get prizes from a specific raffle.
 */
export const fetchGetTombolaRafflesRaffleIdPrizes = (
  variables: GetTombolaRafflesRaffleIdPrizesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaRafflesRaffleIdPrizesResponse,
    GetTombolaRafflesRaffleIdPrizesError,
    undefined,
    {},
    {},
    GetTombolaRafflesRaffleIdPrizesPathParams
  >({
    url: "/tombola/raffles/{raffleId}/prizes",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get prizes from a specific raffle.
 */
export function getTombolaRafflesRaffleIdPrizesQuery(
  variables: GetTombolaRafflesRaffleIdPrizesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetTombolaRafflesRaffleIdPrizesResponse>;
};

export function getTombolaRafflesRaffleIdPrizesQuery(
  variables: GetTombolaRafflesRaffleIdPrizesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetTombolaRafflesRaffleIdPrizesResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaRafflesRaffleIdPrizesQuery(
  variables: GetTombolaRafflesRaffleIdPrizesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/raffles/{raffleId}/prizes",
      operationId: "getTombolaRafflesRaffleIdPrizes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaRafflesRaffleIdPrizes(variables, signal),
  };
}

/**
 * Get prizes from a specific raffle.
 */
export const useSuspenseGetTombolaRafflesRaffleIdPrizes = <
  TData = GetTombolaRafflesRaffleIdPrizesResponse,
>(
  variables: GetTombolaRafflesRaffleIdPrizesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdPrizesResponse,
      GetTombolaRafflesRaffleIdPrizesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaRafflesRaffleIdPrizesResponse,
    GetTombolaRafflesRaffleIdPrizesError,
    TData
  >({
    ...getTombolaRafflesRaffleIdPrizesQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get prizes from a specific raffle.
 */
export const useGetTombolaRafflesRaffleIdPrizes = <
  TData = GetTombolaRafflesRaffleIdPrizesResponse,
>(
  variables: GetTombolaRafflesRaffleIdPrizesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaRafflesRaffleIdPrizesResponse,
      GetTombolaRafflesRaffleIdPrizesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaRafflesRaffleIdPrizesResponse,
    GetTombolaRafflesRaffleIdPrizesError,
    TData
  >({
    ...getTombolaRafflesRaffleIdPrizesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaPrizesPrizeIdPicturePathParams = {
  prizeId: string;
};

export type PostTombolaPrizesPrizeIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPrizesPrizeIdPictureVariables = {
  body: Schemas.BodyCreatePrizePictureTombolaPrizesPrizeIdPicturePost;
  pathParams: PostTombolaPrizesPrizeIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for a specific prize.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPostTombolaPrizesPrizeIdPicture = (
  variables: PostTombolaPrizesPrizeIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostTombolaPrizesPrizeIdPictureError,
    Schemas.BodyCreatePrizePictureTombolaPrizesPrizeIdPicturePost,
    {},
    {},
    PostTombolaPrizesPrizeIdPicturePathParams
  >({
    url: "/tombola/prizes/{prizeId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for a specific prize.
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePostTombolaPrizesPrizeIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostTombolaPrizesPrizeIdPictureError,
      PostTombolaPrizesPrizeIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostTombolaPrizesPrizeIdPictureError,
    PostTombolaPrizesPrizeIdPictureVariables
  >({
    mutationFn: (variables: PostTombolaPrizesPrizeIdPictureVariables) =>
      fetchPostTombolaPrizesPrizeIdPicture(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetTombolaPrizesPrizeIdPicturePathParams = {
  prizeId: string;
};

export type GetTombolaPrizesPrizeIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaPrizesPrizeIdPictureVariables = {
  pathParams: GetTombolaPrizesPrizeIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of a specific prize.
 */
export const fetchGetTombolaPrizesPrizeIdPicture = (
  variables: GetTombolaPrizesPrizeIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetTombolaPrizesPrizeIdPictureError,
    undefined,
    {},
    {},
    GetTombolaPrizesPrizeIdPicturePathParams
  >({
    url: "/tombola/prizes/{prizeId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of a specific prize.
 */
export function getTombolaPrizesPrizeIdPictureQuery(
  variables: GetTombolaPrizesPrizeIdPictureVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getTombolaPrizesPrizeIdPictureQuery(
  variables: GetTombolaPrizesPrizeIdPictureVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getTombolaPrizesPrizeIdPictureQuery(
  variables: GetTombolaPrizesPrizeIdPictureVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/prizes/{prizeId}/picture",
      operationId: "getTombolaPrizesPrizeIdPicture",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaPrizesPrizeIdPicture(variables, signal),
  };
}

/**
 * Get the logo of a specific prize.
 */
export const useSuspenseGetTombolaPrizesPrizeIdPicture = <TData = undefined,>(
  variables: GetTombolaPrizesPrizeIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetTombolaPrizesPrizeIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetTombolaPrizesPrizeIdPictureError,
    TData
  >({
    ...getTombolaPrizesPrizeIdPictureQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the logo of a specific prize.
 */
export const useGetTombolaPrizesPrizeIdPicture = <TData = undefined,>(
  variables: GetTombolaPrizesPrizeIdPictureVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetTombolaPrizesPrizeIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetTombolaPrizesPrizeIdPictureError,
    TData
  >({
    ...getTombolaPrizesPrizeIdPictureQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaUsersCashError = Fetcher.ErrorWrapper<undefined>;

export type GetTombolaUsersCashResponse = Schemas.CashComplete[];

export type GetTombolaUsersCashVariables = HyperionContext["fetcherOptions"];

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export const fetchGetTombolaUsersCash = (
  variables: GetTombolaUsersCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetTombolaUsersCashResponse,
    GetTombolaUsersCashError,
    undefined,
    {},
    {},
    {}
  >({ url: "/tombola/users/cash", method: "get", ...variables, signal });

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export function getTombolaUsersCashQuery(
  variables: GetTombolaUsersCashVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetTombolaUsersCashResponse>;
};

export function getTombolaUsersCashQuery(
  variables: GetTombolaUsersCashVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetTombolaUsersCashResponse>)
    | reactQuery.SkipToken;
};

export function getTombolaUsersCashQuery(
  variables: GetTombolaUsersCashVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/users/cash",
      operationId: "getTombolaUsersCash",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaUsersCash(variables, signal),
  };
}

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export const useSuspenseGetTombolaUsersCash = <
  TData = GetTombolaUsersCashResponse,
>(
  variables: GetTombolaUsersCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaUsersCashResponse,
      GetTombolaUsersCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetTombolaUsersCashResponse,
    GetTombolaUsersCashError,
    TData
  >({
    ...getTombolaUsersCashQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get cash from all users.
 *
 * **The user must be a member of the group admin to use this endpoint
 */
export const useGetTombolaUsersCash = <TData = GetTombolaUsersCashResponse,>(
  variables: GetTombolaUsersCashVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetTombolaUsersCashResponse,
      GetTombolaUsersCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetTombolaUsersCashResponse,
    GetTombolaUsersCashError,
    TData
  >({
    ...getTombolaUsersCashQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTombolaUsersUserIdCashPathParams = {
  userId: string;
};

export type GetTombolaUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetTombolaUsersUserIdCashVariables = {
  pathParams: GetTombolaUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export const fetchGetTombolaUsersUserIdCash = (
  variables: GetTombolaUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    GetTombolaUsersUserIdCashError,
    undefined,
    {},
    {},
    GetTombolaUsersUserIdCashPathParams
  >({
    url: "/tombola/users/{userId}/cash",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export function getTombolaUsersUserIdCashQuery(
  variables: GetTombolaUsersUserIdCashVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CashComplete>;
};

export function getTombolaUsersUserIdCashQuery(
  variables: GetTombolaUsersUserIdCashVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CashComplete>)
    | reactQuery.SkipToken;
};

export function getTombolaUsersUserIdCashQuery(
  variables: GetTombolaUsersUserIdCashVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/tombola/users/{userId}/cash",
      operationId: "getTombolaUsersUserIdCash",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTombolaUsersUserIdCash(variables, signal),
  };
}

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useSuspenseGetTombolaUsersUserIdCash = <
  TData = Schemas.CashComplete,
>(
  variables: GetTombolaUsersUserIdCashVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CashComplete,
      GetTombolaUsersUserIdCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CashComplete,
    GetTombolaUsersUserIdCashError,
    TData
  >({
    ...getTombolaUsersUserIdCashQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get cash from a specific user.
 *
 * **The user must be a member of the group admin to use this endpoint or can only access the endpoint for its own user_id**
 */
export const useGetTombolaUsersUserIdCash = <TData = Schemas.CashComplete,>(
  variables: GetTombolaUsersUserIdCashVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CashComplete,
      GetTombolaUsersUserIdCashError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CashComplete,
    GetTombolaUsersUserIdCashError,
    TData
  >({
    ...getTombolaUsersUserIdCashQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostTombolaUsersUserIdCashPathParams = {
  userId: string;
};

export type PostTombolaUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PostTombolaUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create cash for a user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchPostTombolaUsersUserIdCash = (
  variables: PostTombolaUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CashComplete,
    PostTombolaUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PostTombolaUsersUserIdCashPathParams
  >({
    url: "/tombola/users/{userId}/cash",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create cash for a user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const usePostTombolaUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CashComplete,
      PostTombolaUsersUserIdCashError,
      PostTombolaUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CashComplete,
    PostTombolaUsersUserIdCashError,
    PostTombolaUsersUserIdCashVariables
  >({
    mutationFn: (variables: PostTombolaUsersUserIdCashVariables) =>
      fetchPostTombolaUsersUserIdCash(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchTombolaUsersUserIdCashPathParams = {
  userId: string;
};

export type PatchTombolaUsersUserIdCashError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaUsersUserIdCashVariables = {
  body: Schemas.CashEdit;
  pathParams: PatchTombolaUsersUserIdCashPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const fetchPatchTombolaUsersUserIdCash = (
  variables: PatchTombolaUsersUserIdCashVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaUsersUserIdCashError,
    Schemas.CashEdit,
    {},
    {},
    PatchTombolaUsersUserIdCashPathParams
  >({
    url: "/tombola/users/{userId}/cash",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit cash for an user. This will add the balance to the current balance.
 * A negative value can be provided to remove money from the user.
 *
 * **The user must be a member of the group admin to use this endpoint**
 */
export const usePatchTombolaUsersUserIdCash = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaUsersUserIdCashError,
      PatchTombolaUsersUserIdCashVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaUsersUserIdCashError,
    PatchTombolaUsersUserIdCashVariables
  >({
    mutationFn: (variables: PatchTombolaUsersUserIdCashVariables) =>
      fetchPatchTombolaUsersUserIdCash(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostTombolaPrizesPrizeIdDrawPathParams = {
  prizeId: string;
};

export type PostTombolaPrizesPrizeIdDrawError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostTombolaPrizesPrizeIdDrawResponse = Schemas.TicketComplete[];

export type PostTombolaPrizesPrizeIdDrawVariables = {
  pathParams: PostTombolaPrizesPrizeIdDrawPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostTombolaPrizesPrizeIdDraw = (
  variables: PostTombolaPrizesPrizeIdDrawVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    PostTombolaPrizesPrizeIdDrawResponse,
    PostTombolaPrizesPrizeIdDrawError,
    undefined,
    {},
    {},
    PostTombolaPrizesPrizeIdDrawPathParams
  >({
    url: "/tombola/prizes/{prizeId}/draw",
    method: "post",
    ...variables,
    signal,
  });

export const usePostTombolaPrizesPrizeIdDraw = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      PostTombolaPrizesPrizeIdDrawResponse,
      PostTombolaPrizesPrizeIdDrawError,
      PostTombolaPrizesPrizeIdDrawVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    PostTombolaPrizesPrizeIdDrawResponse,
    PostTombolaPrizesPrizeIdDrawError,
    PostTombolaPrizesPrizeIdDrawVariables
  >({
    mutationFn: (variables: PostTombolaPrizesPrizeIdDrawVariables) =>
      fetchPostTombolaPrizesPrizeIdDraw(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchTombolaRafflesRaffleIdOpenPathParams = {
  raffleId: string;
};

export type PatchTombolaRafflesRaffleIdOpenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaRafflesRaffleIdOpenVariables = {
  pathParams: PatchTombolaRafflesRaffleIdOpenPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Open a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaRafflesRaffleIdOpen = (
  variables: PatchTombolaRafflesRaffleIdOpenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaRafflesRaffleIdOpenError,
    undefined,
    {},
    {},
    PatchTombolaRafflesRaffleIdOpenPathParams
  >({
    url: "/tombola/raffles/{raffleId}/open",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Open a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaRafflesRaffleIdOpen = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaRafflesRaffleIdOpenError,
      PatchTombolaRafflesRaffleIdOpenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaRafflesRaffleIdOpenError,
    PatchTombolaRafflesRaffleIdOpenVariables
  >({
    mutationFn: (variables: PatchTombolaRafflesRaffleIdOpenVariables) =>
      fetchPatchTombolaRafflesRaffleIdOpen(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchTombolaRafflesRaffleIdLockPathParams = {
  raffleId: string;
};

export type PatchTombolaRafflesRaffleIdLockError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchTombolaRafflesRaffleIdLockVariables = {
  pathParams: PatchTombolaRafflesRaffleIdLockPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Lock a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const fetchPatchTombolaRafflesRaffleIdLock = (
  variables: PatchTombolaRafflesRaffleIdLockVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchTombolaRafflesRaffleIdLockError,
    undefined,
    {},
    {},
    PatchTombolaRafflesRaffleIdLockPathParams
  >({
    url: "/tombola/raffles/{raffleId}/lock",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Lock a raffle
 *
 * **The user must be a member of the raffle's group to use this endpoint**
 */
export const usePatchTombolaRafflesRaffleIdLock = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchTombolaRafflesRaffleIdLockError,
      PatchTombolaRafflesRaffleIdLockVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchTombolaRafflesRaffleIdLockError,
    PatchTombolaRafflesRaffleIdLockVariables
  >({
    mutationFn: (variables: PatchTombolaRafflesRaffleIdLockVariables) =>
      fetchPatchTombolaRafflesRaffleIdLock(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetRecommendationRecommendationsError =
  Fetcher.ErrorWrapper<undefined>;

export type GetRecommendationRecommendationsResponse = Schemas.Recommendation[];

export type GetRecommendationRecommendationsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetRecommendationRecommendations = (
  variables: GetRecommendationRecommendationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetRecommendationRecommendationsResponse,
    GetRecommendationRecommendationsError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/recommendation/recommendations",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getRecommendationRecommendationsQuery(
  variables: GetRecommendationRecommendationsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetRecommendationRecommendationsResponse>;
};

export function getRecommendationRecommendationsQuery(
  variables: GetRecommendationRecommendationsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetRecommendationRecommendationsResponse>)
    | reactQuery.SkipToken;
};

export function getRecommendationRecommendationsQuery(
  variables: GetRecommendationRecommendationsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/recommendation/recommendations",
      operationId: "getRecommendationRecommendations",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRecommendationRecommendations(variables, signal),
  };
}

/**
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetRecommendationRecommendations = <
  TData = GetRecommendationRecommendationsResponse,
>(
  variables: GetRecommendationRecommendationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecommendationRecommendationsResponse,
      GetRecommendationRecommendationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetRecommendationRecommendationsResponse,
    GetRecommendationRecommendationsError,
    TData
  >({
    ...getRecommendationRecommendationsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get recommendations.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetRecommendationRecommendations = <
  TData = GetRecommendationRecommendationsResponse,
>(
  variables: GetRecommendationRecommendationsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetRecommendationRecommendationsResponse,
      GetRecommendationRecommendationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetRecommendationRecommendationsResponse,
    GetRecommendationRecommendationsError,
    TData
  >({
    ...getRecommendationRecommendationsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostRecommendationRecommendationsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRecommendationRecommendationsVariables = {
  body: Schemas.RecommendationBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchPostRecommendationRecommendations = (
  variables: PostRecommendationRecommendationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Recommendation,
    PostRecommendationRecommendationsError,
    Schemas.RecommendationBase,
    {},
    {},
    {}
  >({
    url: "/recommendation/recommendations",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const usePostRecommendationRecommendations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Recommendation,
      PostRecommendationRecommendationsError,
      PostRecommendationRecommendationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Recommendation,
    PostRecommendationRecommendationsError,
    PostRecommendationRecommendationsVariables
  >({
    mutationFn: (variables: PostRecommendationRecommendationsVariables) =>
      fetchPostRecommendationRecommendations(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchRecommendationRecommendationsRecommendationIdPathParams = {
  /**
   * @format uuid
   */
  recommendationId: string;
};

export type PatchRecommendationRecommendationsRecommendationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchRecommendationRecommendationsRecommendationIdVariables = {
  body?: Schemas.RecommendationEdit;
  pathParams: PatchRecommendationRecommendationsRecommendationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchPatchRecommendationRecommendationsRecommendationId = (
  variables: PatchRecommendationRecommendationsRecommendationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchRecommendationRecommendationsRecommendationIdError,
    Schemas.RecommendationEdit,
    {},
    {},
    PatchRecommendationRecommendationsRecommendationIdPathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const usePatchRecommendationRecommendationsRecommendationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRecommendationRecommendationsRecommendationIdError,
      PatchRecommendationRecommendationsRecommendationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRecommendationRecommendationsRecommendationIdError,
    PatchRecommendationRecommendationsRecommendationIdVariables
  >({
    mutationFn: (
      variables: PatchRecommendationRecommendationsRecommendationIdVariables,
    ) =>
      fetchPatchRecommendationRecommendationsRecommendationId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteRecommendationRecommendationsRecommendationIdPathParams = {
  /**
   * @format uuid
   */
  recommendationId: string;
};

export type DeleteRecommendationRecommendationsRecommendationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteRecommendationRecommendationsRecommendationIdVariables = {
  pathParams: DeleteRecommendationRecommendationsRecommendationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchDeleteRecommendationRecommendationsRecommendationId = (
  variables: DeleteRecommendationRecommendationsRecommendationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteRecommendationRecommendationsRecommendationIdError,
    undefined,
    {},
    {},
    DeleteRecommendationRecommendationsRecommendationIdPathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const useDeleteRecommendationRecommendationsRecommendationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRecommendationRecommendationsRecommendationIdError,
      DeleteRecommendationRecommendationsRecommendationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRecommendationRecommendationsRecommendationIdError,
    DeleteRecommendationRecommendationsRecommendationIdVariables
  >({
    mutationFn: (
      variables: DeleteRecommendationRecommendationsRecommendationIdVariables,
    ) =>
      fetchDeleteRecommendationRecommendationsRecommendationId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetRecommendationRecommendationsRecommendationIdPicturePathParams =
  {
    /**
     * @format uuid
     */
    recommendationId: string;
  };

export type GetRecommendationRecommendationsRecommendationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetRecommendationRecommendationsRecommendationIdPictureVariables = {
  pathParams: GetRecommendationRecommendationsRecommendationIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetRecommendationRecommendationsRecommendationIdPicture = (
  variables: GetRecommendationRecommendationsRecommendationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetRecommendationRecommendationsRecommendationIdPictureError,
    undefined,
    {},
    {},
    GetRecommendationRecommendationsRecommendationIdPicturePathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getRecommendationRecommendationsRecommendationIdPictureQuery(
  variables: GetRecommendationRecommendationsRecommendationIdPictureVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getRecommendationRecommendationsRecommendationIdPictureQuery(
  variables:
    | GetRecommendationRecommendationsRecommendationIdPictureVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getRecommendationRecommendationsRecommendationIdPictureQuery(
  variables:
    | GetRecommendationRecommendationsRecommendationIdPictureVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/recommendation/recommendations/{recommendationId}/picture",
      operationId: "getRecommendationRecommendationsRecommendationIdPicture",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRecommendationRecommendationsRecommendationIdPicture(
              variables,
              signal,
            ),
  };
}

/**
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetRecommendationRecommendationsRecommendationIdPicture =
  <TData = undefined,>(
    variables: GetRecommendationRecommendationsRecommendationIdPictureVariables,
    options?: Omit<
      reactQuery.UseQueryOptions<
        undefined,
        GetRecommendationRecommendationsRecommendationIdPictureError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useSuspenseQuery<
      undefined,
      GetRecommendationRecommendationsRecommendationIdPictureError,
      TData
    >({
      ...getRecommendationRecommendationsRecommendationIdPictureQuery(
        deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

/**
 * Get the image of a recommendation.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetRecommendationRecommendationsRecommendationIdPicture = <
  TData = undefined,
>(
  variables:
    | GetRecommendationRecommendationsRecommendationIdPictureVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetRecommendationRecommendationsRecommendationIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetRecommendationRecommendationsRecommendationIdPictureError,
    TData
  >({
    ...getRecommendationRecommendationsRecommendationIdPictureQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostRecommendationRecommendationsRecommendationIdPicturePathParams =
  {
    /**
     * @format uuid
     */
    recommendationId: string;
  };

export type PostRecommendationRecommendationsRecommendationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostRecommendationRecommendationsRecommendationIdPictureVariables =
  {
    body: Schemas.BodyCreateRecommendationImageRecommendationRecommendationsRecommendationIdPicturePost;
    pathParams: PostRecommendationRecommendationsRecommendationIdPicturePathParams;
  } & HyperionContext["fetcherOptions"];

/**
 * Add an image to a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const fetchPostRecommendationRecommendationsRecommendationIdPicture = (
  variables: PostRecommendationRecommendationsRecommendationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostRecommendationRecommendationsRecommendationIdPictureError,
    Schemas.BodyCreateRecommendationImageRecommendationRecommendationsRecommendationIdPicturePost,
    {},
    {},
    PostRecommendationRecommendationsRecommendationIdPicturePathParams
  >({
    url: "/recommendation/recommendations/{recommendationId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add an image to a recommendation.
 *
 * **This endpoint is only usable by members of the group BDE**
 */
export const usePostRecommendationRecommendationsRecommendationIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostRecommendationRecommendationsRecommendationIdPictureError,
      PostRecommendationRecommendationsRecommendationIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostRecommendationRecommendationsRecommendationIdPictureError,
    PostRecommendationRecommendationsRecommendationIdPictureVariables
  >({
    mutationFn: (
      variables: PostRecommendationRecommendationsRecommendationIdPictureVariables,
    ) =>
      fetchPostRecommendationRecommendationsRecommendationIdPicture(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetPhPaperIdPdfPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type GetPhPaperIdPdfError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPhPaperIdPdfVariables = {
  pathParams: GetPhPaperIdPdfPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetPhPaperIdPdf = (
  variables: GetPhPaperIdPdfVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetPhPaperIdPdfError,
    undefined,
    {},
    {},
    GetPhPaperIdPdfPathParams
  >({ url: "/ph/{paperId}/pdf", method: "get", ...variables, signal });

export function getPhPaperIdPdfQuery(variables: GetPhPaperIdPdfVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getPhPaperIdPdfQuery(
  variables: GetPhPaperIdPdfVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getPhPaperIdPdfQuery(
  variables: GetPhPaperIdPdfVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/ph/{paperId}/pdf",
      operationId: "getPhPaperIdPdf",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhPaperIdPdf(variables, signal),
  };
}

export const useSuspenseGetPhPaperIdPdf = <TData = undefined,>(
  variables: GetPhPaperIdPdfVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetPhPaperIdPdfError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetPhPaperIdPdfError, TData>({
    ...getPhPaperIdPdfQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetPhPaperIdPdf = <TData = undefined,>(
  variables: GetPhPaperIdPdfVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetPhPaperIdPdfError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetPhPaperIdPdfError, TData>({
    ...getPhPaperIdPdfQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostPhPaperIdPdfPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type PostPhPaperIdPdfError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhPaperIdPdfVariables = {
  body: Schemas.BodyCreatePaperPdfAndCoverPhPaperIdPdfPost;
  pathParams: PostPhPaperIdPdfPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostPhPaperIdPdf = (
  variables: PostPhPaperIdPdfVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostPhPaperIdPdfError,
    Schemas.BodyCreatePaperPdfAndCoverPhPaperIdPdfPost,
    {},
    {},
    PostPhPaperIdPdfPathParams
  >({ url: "/ph/{paperId}/pdf", method: "post", ...variables, signal });

export const usePostPhPaperIdPdf = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostPhPaperIdPdfError,
      PostPhPaperIdPdfVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostPhPaperIdPdfError,
    PostPhPaperIdPdfVariables
  >({
    mutationFn: (variables: PostPhPaperIdPdfVariables) =>
      fetchPostPhPaperIdPdf(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetPhError = Fetcher.ErrorWrapper<undefined>;

export type GetPhResponse = Schemas.PaperComplete[];

export type GetPhVariables = HyperionContext["fetcherOptions"];

/**
 * Return all editions until now, sorted from the latest to the oldest
 */
export const fetchGetPh = (variables: GetPhVariables, signal?: AbortSignal) =>
  hyperionFetch<GetPhResponse, GetPhError, undefined, {}, {}, {}>({
    url: "/ph/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all editions until now, sorted from the latest to the oldest
 */
export function getPhQuery(variables: GetPhVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetPhResponse>;
};

export function getPhQuery(variables: GetPhVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetPhResponse>)
    | reactQuery.SkipToken;
};

export function getPhQuery(variables: GetPhVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/ph/",
      operationId: "getPh",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetPh(variables, signal),
  };
}

/**
 * Return all editions until now, sorted from the latest to the oldest
 */
export const useSuspenseGetPh = <TData = GetPhResponse,>(
  variables: GetPhVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetPhResponse, GetPhError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<GetPhResponse, GetPhError, TData>({
    ...getPhQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all editions until now, sorted from the latest to the oldest
 */
export const useGetPh = <TData = GetPhResponse,>(
  variables: GetPhVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetPhResponse, GetPhError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetPhResponse, GetPhError, TData>({
    ...getPhQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostPhError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhVariables = {
  body: Schemas.PaperBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new paper.
 */
export const fetchPostPh = (variables: PostPhVariables, signal?: AbortSignal) =>
  hyperionFetch<
    Schemas.PaperComplete,
    PostPhError,
    Schemas.PaperBase,
    {},
    {},
    {}
  >({ url: "/ph/", method: "post", ...variables, signal });

/**
 * Create a new paper.
 */
export const usePostPh = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaperComplete,
      PostPhError,
      PostPhVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PaperComplete,
    PostPhError,
    PostPhVariables
  >({
    mutationFn: (variables: PostPhVariables) =>
      fetchPostPh(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetPhAdminError = Fetcher.ErrorWrapper<undefined>;

export type GetPhAdminResponse = Schemas.PaperComplete[];

export type GetPhAdminVariables = HyperionContext["fetcherOptions"];

/**
 * Return all editions, sorted from the latest to the oldest
 */
export const fetchGetPhAdmin = (
  variables: GetPhAdminVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetPhAdminResponse, GetPhAdminError, undefined, {}, {}, {}>({
    url: "/ph/admin",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all editions, sorted from the latest to the oldest
 */
export function getPhAdminQuery(variables: GetPhAdminVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetPhAdminResponse>;
};

export function getPhAdminQuery(
  variables: GetPhAdminVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetPhAdminResponse>)
    | reactQuery.SkipToken;
};

export function getPhAdminQuery(
  variables: GetPhAdminVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/ph/admin",
      operationId: "getPhAdmin",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetPhAdmin(variables, signal),
  };
}

/**
 * Return all editions, sorted from the latest to the oldest
 */
export const useSuspenseGetPhAdmin = <TData = GetPhAdminResponse,>(
  variables: GetPhAdminVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetPhAdminResponse, GetPhAdminError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetPhAdminResponse,
    GetPhAdminError,
    TData
  >({
    ...getPhAdminQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all editions, sorted from the latest to the oldest
 */
export const useGetPhAdmin = <TData = GetPhAdminResponse,>(
  variables: GetPhAdminVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetPhAdminResponse, GetPhAdminError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetPhAdminResponse, GetPhAdminError, TData>({
    ...getPhAdminQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetPhPaperIdCoverPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type GetPhPaperIdCoverError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPhPaperIdCoverVariables = {
  pathParams: GetPhPaperIdCoverPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetPhPaperIdCover = (
  variables: GetPhPaperIdCoverVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetPhPaperIdCoverError,
    undefined,
    {},
    {},
    GetPhPaperIdCoverPathParams
  >({ url: "/ph/{paperId}/cover", method: "get", ...variables, signal });

export function getPhPaperIdCoverQuery(variables: GetPhPaperIdCoverVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getPhPaperIdCoverQuery(
  variables: GetPhPaperIdCoverVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getPhPaperIdCoverQuery(
  variables: GetPhPaperIdCoverVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/ph/{paperId}/cover",
      operationId: "getPhPaperIdCover",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhPaperIdCover(variables, signal),
  };
}

export const useSuspenseGetPhPaperIdCover = <TData = void,>(
  variables: GetPhPaperIdCoverVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetPhPaperIdCoverError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<void, GetPhPaperIdCoverError, TData>({
    ...getPhPaperIdCoverQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetPhPaperIdCover = <TData = void,>(
  variables: GetPhPaperIdCoverVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetPhPaperIdCoverError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetPhPaperIdCoverError, TData>({
    ...getPhPaperIdCoverQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchPhPaperIdPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type PatchPhPaperIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchPhPaperIdVariables = {
  body?: Schemas.PaperUpdate;
  pathParams: PatchPhPaperIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchPhPaperId = (
  variables: PatchPhPaperIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhPaperIdError,
    Schemas.PaperUpdate,
    {},
    {},
    PatchPhPaperIdPathParams
  >({ url: "/ph/{paperId}", method: "patch", ...variables, signal });

export const usePatchPhPaperId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhPaperIdError,
      PatchPhPaperIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhPaperIdError,
    PatchPhPaperIdVariables
  >({
    mutationFn: (variables: PatchPhPaperIdVariables) =>
      fetchPatchPhPaperId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeletePhPaperIdPathParams = {
  /**
   * @format uuid
   */
  paperId: string;
};

export type DeletePhPaperIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeletePhPaperIdVariables = {
  pathParams: DeletePhPaperIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeletePhPaperId = (
  variables: DeletePhPaperIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeletePhPaperIdError,
    undefined,
    {},
    {},
    DeletePhPaperIdPathParams
  >({ url: "/ph/{paperId}", method: "delete", ...variables, signal });

export const useDeletePhPaperId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeletePhPaperIdError,
      DeletePhPaperIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeletePhPaperIdError,
    DeletePhPaperIdVariables
  >({
    mutationFn: (variables: DeletePhPaperIdVariables) =>
      fetchDeletePhPaperId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetLoansLoanersError = Fetcher.ErrorWrapper<undefined>;

export type GetLoansLoanersResponse = Schemas.Loaner[];

export type GetLoansLoanersVariables = HyperionContext["fetcherOptions"];

/**
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetLoansLoaners = (
  variables: GetLoansLoanersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansLoanersResponse,
    GetLoansLoanersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/loans/loaners/", method: "get", ...variables, signal });

/**
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export function getLoansLoanersQuery(variables: GetLoansLoanersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetLoansLoanersResponse>;
};

export function getLoansLoanersQuery(
  variables: GetLoansLoanersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetLoansLoanersResponse>)
    | reactQuery.SkipToken;
};

export function getLoansLoanersQuery(
  variables: GetLoansLoanersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/loans/loaners/",
      operationId: "getLoansLoaners",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetLoansLoaners(variables, signal),
  };
}

/**
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetLoansLoaners = <TData = GetLoansLoanersResponse,>(
  variables: GetLoansLoanersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersResponse,
      GetLoansLoanersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetLoansLoanersResponse,
    GetLoansLoanersError,
    TData
  >({
    ...getLoansLoanersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get existing loaners.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetLoansLoaners = <TData = GetLoansLoanersResponse,>(
  variables: GetLoansLoanersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersResponse,
      GetLoansLoanersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansLoanersResponse,
    GetLoansLoanersError,
    TData
  >({
    ...getLoansLoanersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostLoansLoanersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanersVariables = {
  body: Schemas.LoanerBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new loaner.
 *
 * Each loaner is associated with a `manager_group`. Users belonging to this group are able to manage the loaner items and loans.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostLoansLoaners = (
  variables: PostLoansLoanersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Loaner,
    PostLoansLoanersError,
    Schemas.LoanerBase,
    {},
    {},
    {}
  >({ url: "/loans/loaners/", method: "post", ...variables, signal });

/**
 * Create a new loaner.
 *
 * Each loaner is associated with a `manager_group`. Users belonging to this group are able to manage the loaner items and loans.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostLoansLoaners = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Loaner,
      PostLoansLoanersError,
      PostLoansLoanersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Loaner,
    PostLoansLoanersError,
    PostLoansLoanersVariables
  >({
    mutationFn: (variables: PostLoansLoanersVariables) =>
      fetchPostLoansLoaners(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteLoansLoanersLoanerIdPathParams = {
  loanerId: string;
};

export type DeleteLoansLoanersLoanerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteLoansLoanersLoanerIdVariables = {
  pathParams: DeleteLoansLoanersLoanerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a loaner. All items and loans associated with the loaner will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteLoansLoanersLoanerId = (
  variables: DeleteLoansLoanersLoanerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteLoansLoanersLoanerIdError,
    undefined,
    {},
    {},
    DeleteLoansLoanersLoanerIdPathParams
  >({
    url: "/loans/loaners/{loanerId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a loaner. All items and loans associated with the loaner will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteLoansLoanersLoanerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteLoansLoanersLoanerIdError,
      DeleteLoansLoanersLoanerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteLoansLoanersLoanerIdError,
    DeleteLoansLoanersLoanerIdVariables
  >({
    mutationFn: (variables: DeleteLoansLoanersLoanerIdVariables) =>
      fetchDeleteLoansLoanersLoanerId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchLoansLoanersLoanerIdPathParams = {
  loanerId: string;
};

export type PatchLoansLoanersLoanerIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchLoansLoanersLoanerIdVariables = {
  body?: Schemas.LoanerUpdate;
  pathParams: PatchLoansLoanersLoanerIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a loaner, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchLoansLoanersLoanerId = (
  variables: PatchLoansLoanersLoanerIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchLoansLoanersLoanerIdError,
    Schemas.LoanerUpdate,
    {},
    {},
    PatchLoansLoanersLoanerIdPathParams
  >({
    url: "/loans/loaners/{loanerId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a loaner, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchLoansLoanersLoanerId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchLoansLoanersLoanerIdError,
      PatchLoansLoanersLoanerIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchLoansLoanersLoanerIdError,
    PatchLoansLoanersLoanerIdVariables
  >({
    mutationFn: (variables: PatchLoansLoanersLoanerIdVariables) =>
      fetchPatchLoansLoanersLoanerId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetLoansLoanersLoanerIdLoansPathParams = {
  loanerId: string;
};

export type GetLoansLoanersLoanerIdLoansQueryParams = {
  returned?: boolean | null;
};

export type GetLoansLoanersLoanerIdLoansError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetLoansLoanersLoanerIdLoansResponse = Schemas.Loan[];

export type GetLoansLoanersLoanerIdLoansVariables = {
  pathParams: GetLoansLoanersLoanerIdLoansPathParams;
  queryParams?: GetLoansLoanersLoanerIdLoansQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchGetLoansLoanersLoanerIdLoans = (
  variables: GetLoansLoanersLoanerIdLoansVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansLoanersLoanerIdLoansResponse,
    GetLoansLoanersLoanerIdLoansError,
    undefined,
    {},
    GetLoansLoanersLoanerIdLoansQueryParams,
    GetLoansLoanersLoanerIdLoansPathParams
  >({
    url: "/loans/loaners/{loanerId}/loans",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export function getLoansLoanersLoanerIdLoansQuery(
  variables: GetLoansLoanersLoanerIdLoansVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetLoansLoanersLoanerIdLoansResponse>;
};

export function getLoansLoanersLoanerIdLoansQuery(
  variables: GetLoansLoanersLoanerIdLoansVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetLoansLoanersLoanerIdLoansResponse>)
    | reactQuery.SkipToken;
};

export function getLoansLoanersLoanerIdLoansQuery(
  variables: GetLoansLoanersLoanerIdLoansVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/loans/loaners/{loanerId}/loans",
      operationId: "getLoansLoanersLoanerIdLoans",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetLoansLoanersLoanerIdLoans(variables, signal),
  };
}

/**
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useSuspenseGetLoansLoanersLoanerIdLoans = <
  TData = GetLoansLoanersLoanerIdLoansResponse,
>(
  variables: GetLoansLoanersLoanerIdLoansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersLoanerIdLoansResponse,
      GetLoansLoanersLoanerIdLoansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetLoansLoanersLoanerIdLoansResponse,
    GetLoansLoanersLoanerIdLoansError,
    TData
  >({
    ...getLoansLoanersLoanerIdLoansQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all loans from a given group.
 *
 *
 * The query string `returned` can be used to get only return or non returned loans. By default, all loans are returned.
 *
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useGetLoansLoanersLoanerIdLoans = <
  TData = GetLoansLoanersLoanerIdLoansResponse,
>(
  variables: GetLoansLoanersLoanerIdLoansVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersLoanerIdLoansResponse,
      GetLoansLoanersLoanerIdLoansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansLoanersLoanerIdLoansResponse,
    GetLoansLoanersLoanerIdLoansError,
    TData
  >({
    ...getLoansLoanersLoanerIdLoansQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetLoansLoanersLoanerIdItemsPathParams = {
  loanerId: string;
};

export type GetLoansLoanersLoanerIdItemsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetLoansLoanersLoanerIdItemsResponse = Schemas.Item[];

export type GetLoansLoanersLoanerIdItemsVariables = {
  pathParams: GetLoansLoanersLoanerIdItemsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchGetLoansLoanersLoanerIdItems = (
  variables: GetLoansLoanersLoanerIdItemsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansLoanersLoanerIdItemsResponse,
    GetLoansLoanersLoanerIdItemsError,
    undefined,
    {},
    {},
    GetLoansLoanersLoanerIdItemsPathParams
  >({
    url: "/loans/loaners/{loanerId}/items",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export function getLoansLoanersLoanerIdItemsQuery(
  variables: GetLoansLoanersLoanerIdItemsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetLoansLoanersLoanerIdItemsResponse>;
};

export function getLoansLoanersLoanerIdItemsQuery(
  variables: GetLoansLoanersLoanerIdItemsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetLoansLoanersLoanerIdItemsResponse>)
    | reactQuery.SkipToken;
};

export function getLoansLoanersLoanerIdItemsQuery(
  variables: GetLoansLoanersLoanerIdItemsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/loans/loaners/{loanerId}/items",
      operationId: "getLoansLoanersLoanerIdItems",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetLoansLoanersLoanerIdItems(variables, signal),
  };
}

/**
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useSuspenseGetLoansLoanersLoanerIdItems = <
  TData = GetLoansLoanersLoanerIdItemsResponse,
>(
  variables: GetLoansLoanersLoanerIdItemsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersLoanerIdItemsResponse,
      GetLoansLoanersLoanerIdItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetLoansLoanersLoanerIdItemsResponse,
    GetLoansLoanersLoanerIdItemsError,
    TData
  >({
    ...getLoansLoanersLoanerIdItemsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all items of a loaner.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useGetLoansLoanersLoanerIdItems = <
  TData = GetLoansLoanersLoanerIdItemsResponse,
>(
  variables: GetLoansLoanersLoanerIdItemsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansLoanersLoanerIdItemsResponse,
      GetLoansLoanersLoanerIdItemsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansLoanersLoanerIdItemsResponse,
    GetLoansLoanersLoanerIdItemsError,
    TData
  >({
    ...getLoansLoanersLoanerIdItemsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostLoansLoanersLoanerIdItemsPathParams = {
  loanerId: string;
};

export type PostLoansLoanersLoanerIdItemsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanersLoanerIdItemsVariables = {
  body: Schemas.ItemBase;
  pathParams: PostLoansLoanersLoanerIdItemsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new item for a loaner. A given loaner can not have more than one item with the same `name`.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoansLoanersLoanerIdItems = (
  variables: PostLoansLoanersLoanerIdItemsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Item,
    PostLoansLoanersLoanerIdItemsError,
    Schemas.ItemBase,
    {},
    {},
    PostLoansLoanersLoanerIdItemsPathParams
  >({
    url: "/loans/loaners/{loanerId}/items",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new item for a loaner. A given loaner can not have more than one item with the same `name`.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoansLoanersLoanerIdItems = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Item,
      PostLoansLoanersLoanerIdItemsError,
      PostLoansLoanersLoanerIdItemsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Item,
    PostLoansLoanersLoanerIdItemsError,
    PostLoansLoanersLoanerIdItemsVariables
  >({
    mutationFn: (variables: PostLoansLoanersLoanerIdItemsVariables) =>
      fetchPostLoansLoanersLoanerIdItems(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchLoansLoanersLoanerIdItemsItemIdPathParams = {
  loanerId: string;
  itemId: string;
};

export type PatchLoansLoanersLoanerIdItemsItemIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchLoansLoanersLoanerIdItemsItemIdVariables = {
  body?: Schemas.ItemUpdate;
  pathParams: PatchLoansLoanersLoanerIdItemsItemIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a loaner's item.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPatchLoansLoanersLoanerIdItemsItemId = (
  variables: PatchLoansLoanersLoanerIdItemsItemIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchLoansLoanersLoanerIdItemsItemIdError,
    Schemas.ItemUpdate,
    {},
    {},
    PatchLoansLoanersLoanerIdItemsItemIdPathParams
  >({
    url: "/loans/loaners/{loanerId}/items/{itemId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a loaner's item.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePatchLoansLoanersLoanerIdItemsItemId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchLoansLoanersLoanerIdItemsItemIdError,
      PatchLoansLoanersLoanerIdItemsItemIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchLoansLoanersLoanerIdItemsItemIdError,
    PatchLoansLoanersLoanerIdItemsItemIdVariables
  >({
    mutationFn: (variables: PatchLoansLoanersLoanerIdItemsItemIdVariables) =>
      fetchPatchLoansLoanersLoanerIdItemsItemId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteLoansLoanersLoanerIdItemsItemIdPathParams = {
  loanerId: string;
  itemId: string;
};

export type DeleteLoansLoanersLoanerIdItemsItemIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteLoansLoanersLoanerIdItemsItemIdVariables = {
  pathParams: DeleteLoansLoanersLoanerIdItemsItemIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a loaner's item.
 * This will remove the item from all loans but won't delete any loan.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchDeleteLoansLoanersLoanerIdItemsItemId = (
  variables: DeleteLoansLoanersLoanerIdItemsItemIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteLoansLoanersLoanerIdItemsItemIdError,
    undefined,
    {},
    {},
    DeleteLoansLoanersLoanerIdItemsItemIdPathParams
  >({
    url: "/loans/loaners/{loanerId}/items/{itemId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a loaner's item.
 * This will remove the item from all loans but won't delete any loan.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useDeleteLoansLoanersLoanerIdItemsItemId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteLoansLoanersLoanerIdItemsItemIdError,
      DeleteLoansLoanersLoanerIdItemsItemIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteLoansLoanersLoanerIdItemsItemIdError,
    DeleteLoansLoanersLoanerIdItemsItemIdVariables
  >({
    mutationFn: (variables: DeleteLoansLoanersLoanerIdItemsItemIdVariables) =>
      fetchDeleteLoansLoanersLoanerIdItemsItemId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetLoansUsersMeQueryParams = {
  returned?: boolean | null;
};

export type GetLoansUsersMeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetLoansUsersMeResponse = Schemas.Loan[];

export type GetLoansUsersMeVariables = {
  queryParams?: GetLoansUsersMeQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetLoansUsersMe = (
  variables: GetLoansUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansUsersMeResponse,
    GetLoansUsersMeError,
    undefined,
    {},
    GetLoansUsersMeQueryParams,
    {}
  >({ url: "/loans/users/me", method: "get", ...variables, signal });

/**
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getLoansUsersMeQuery(variables: GetLoansUsersMeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetLoansUsersMeResponse>;
};

export function getLoansUsersMeQuery(
  variables: GetLoansUsersMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetLoansUsersMeResponse>)
    | reactQuery.SkipToken;
};

export function getLoansUsersMeQuery(
  variables: GetLoansUsersMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/loans/users/me",
      operationId: "getLoansUsersMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetLoansUsersMe(variables, signal),
  };
}

/**
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetLoansUsersMe = <TData = GetLoansUsersMeResponse,>(
  variables: GetLoansUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansUsersMeResponse,
      GetLoansUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetLoansUsersMeResponse,
    GetLoansUsersMeError,
    TData
  >({
    ...getLoansUsersMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all loans from the current user.
 *
 * The query string `returned` can be used to get only returned or non returned loans. By default, all loans are returned.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetLoansUsersMe = <TData = GetLoansUsersMeResponse,>(
  variables: GetLoansUsersMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansUsersMeResponse,
      GetLoansUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansUsersMeResponse,
    GetLoansUsersMeError,
    TData
  >({
    ...getLoansUsersMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetLoansUsersMeLoanersError = Fetcher.ErrorWrapper<undefined>;

export type GetLoansUsersMeLoanersResponse = Schemas.Loaner[];

export type GetLoansUsersMeLoanersVariables = HyperionContext["fetcherOptions"];

/**
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetLoansUsersMeLoaners = (
  variables: GetLoansUsersMeLoanersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetLoansUsersMeLoanersResponse,
    GetLoansUsersMeLoanersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/loans/users/me/loaners", method: "get", ...variables, signal });

/**
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getLoansUsersMeLoanersQuery(
  variables: GetLoansUsersMeLoanersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetLoansUsersMeLoanersResponse>;
};

export function getLoansUsersMeLoanersQuery(
  variables: GetLoansUsersMeLoanersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetLoansUsersMeLoanersResponse>)
    | reactQuery.SkipToken;
};

export function getLoansUsersMeLoanersQuery(
  variables: GetLoansUsersMeLoanersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/loans/users/me/loaners",
      operationId: "getLoansUsersMeLoaners",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetLoansUsersMeLoaners(variables, signal),
  };
}

/**
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetLoansUsersMeLoaners = <
  TData = GetLoansUsersMeLoanersResponse,
>(
  variables: GetLoansUsersMeLoanersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansUsersMeLoanersResponse,
      GetLoansUsersMeLoanersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetLoansUsersMeLoanersResponse,
    GetLoansUsersMeLoanersError,
    TData
  >({
    ...getLoansUsersMeLoanersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all loaners the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetLoansUsersMeLoaners = <
  TData = GetLoansUsersMeLoanersResponse,
>(
  variables: GetLoansUsersMeLoanersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetLoansUsersMeLoanersResponse,
      GetLoansUsersMeLoanersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetLoansUsersMeLoanersResponse,
    GetLoansUsersMeLoanersError,
    TData
  >({
    ...getLoansUsersMeLoanersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostLoansError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansVariables = {
  body: Schemas.LoanCreation;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new loan in database and add the requested items
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoans = (
  variables: PostLoansVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.Loan, PostLoansError, Schemas.LoanCreation, {}, {}, {}>(
    { url: "/loans/", method: "post", ...variables, signal },
  );

/**
 * Create a new loan in database and add the requested items
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoans = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Loan,
      PostLoansError,
      PostLoansVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Loan,
    PostLoansError,
    PostLoansVariables
  >({
    mutationFn: (variables: PostLoansVariables) =>
      fetchPostLoans(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchLoansLoanIdPathParams = {
  loanId: string;
};

export type PatchLoansLoanIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchLoansLoanIdVariables = {
  body?: Schemas.LoanUpdate;
  pathParams: PatchLoansLoanIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a loan and its items.
 *
 * As the endpoint can update the loan items, it will send back
 * the new representation of the loan `Loan` including the new items relationships
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPatchLoansLoanId = (
  variables: PatchLoansLoanIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchLoansLoanIdError,
    Schemas.LoanUpdate,
    {},
    {},
    PatchLoansLoanIdPathParams
  >({ url: "/loans/{loanId}", method: "patch", ...variables, signal });

/**
 * Update a loan and its items.
 *
 * As the endpoint can update the loan items, it will send back
 * the new representation of the loan `Loan` including the new items relationships
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePatchLoansLoanId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchLoansLoanIdError,
      PatchLoansLoanIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchLoansLoanIdError,
    PatchLoansLoanIdVariables
  >({
    mutationFn: (variables: PatchLoansLoanIdVariables) =>
      fetchPatchLoansLoanId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteLoansLoanIdPathParams = {
  loanId: string;
};

export type DeleteLoansLoanIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteLoansLoanIdVariables = {
  pathParams: DeleteLoansLoanIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a loan
 * This will remove the loan but won't delete any loaner items.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchDeleteLoansLoanId = (
  variables: DeleteLoansLoanIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteLoansLoanIdError,
    undefined,
    {},
    {},
    DeleteLoansLoanIdPathParams
  >({ url: "/loans/{loanId}", method: "delete", ...variables, signal });

/**
 * Delete a loan
 * This will remove the loan but won't delete any loaner items.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const useDeleteLoansLoanId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteLoansLoanIdError,
      DeleteLoansLoanIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteLoansLoanIdError,
    DeleteLoansLoanIdVariables
  >({
    mutationFn: (variables: DeleteLoansLoanIdVariables) =>
      fetchDeleteLoansLoanId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostLoansLoanIdReturnPathParams = {
  loanId: string;
};

export type PostLoansLoanIdReturnError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanIdReturnVariables = {
  pathParams: PostLoansLoanIdReturnPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Mark a loan as returned. This will update items availability.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoansLoanIdReturn = (
  variables: PostLoansLoanIdReturnVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostLoansLoanIdReturnError,
    undefined,
    {},
    {},
    PostLoansLoanIdReturnPathParams
  >({ url: "/loans/{loanId}/return", method: "post", ...variables, signal });

/**
 * Mark a loan as returned. This will update items availability.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoansLoanIdReturn = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostLoansLoanIdReturnError,
      PostLoansLoanIdReturnVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostLoansLoanIdReturnError,
    PostLoansLoanIdReturnVariables
  >({
    mutationFn: (variables: PostLoansLoanIdReturnVariables) =>
      fetchPostLoansLoanIdReturn(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostLoansLoanIdExtendPathParams = {
  loanId: string;
};

export type PostLoansLoanIdExtendError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostLoansLoanIdExtendVariables = {
  body?: Schemas.LoanExtend;
  pathParams: PostLoansLoanIdExtendPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * A new `end` date or an extended `duration` can be provided. If the two are provided, only `end` will be used.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const fetchPostLoansLoanIdExtend = (
  variables: PostLoansLoanIdExtendVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostLoansLoanIdExtendError,
    Schemas.LoanExtend,
    {},
    {},
    PostLoansLoanIdExtendPathParams
  >({ url: "/loans/{loanId}/extend", method: "post", ...variables, signal });

/**
 * A new `end` date or an extended `duration` can be provided. If the two are provided, only `end` will be used.
 *
 * **The user must be a member of the loaner group_manager to use this endpoint**
 */
export const usePostLoansLoanIdExtend = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostLoansLoanIdExtendError,
      PostLoansLoanIdExtendVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostLoansLoanIdExtendError,
    PostLoansLoanIdExtendVariables
  >({
    mutationFn: (variables: PostLoansLoanIdExtendVariables) =>
      fetchPostLoansLoanIdExtend(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetFlappybirdScoresError = Fetcher.ErrorWrapper<undefined>;

export type GetFlappybirdScoresResponse = Schemas.FlappyBirdScoreInDB[];

export type GetFlappybirdScoresVariables = HyperionContext["fetcherOptions"];

/**
 * Return the leaderboard
 */
export const fetchGetFlappybirdScores = (
  variables: GetFlappybirdScoresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetFlappybirdScoresResponse,
    GetFlappybirdScoresError,
    undefined,
    {},
    {},
    {}
  >({ url: "/flappybird/scores", method: "get", ...variables, signal });

/**
 * Return the leaderboard
 */
export function getFlappybirdScoresQuery(
  variables: GetFlappybirdScoresVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetFlappybirdScoresResponse>;
};

export function getFlappybirdScoresQuery(
  variables: GetFlappybirdScoresVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetFlappybirdScoresResponse>)
    | reactQuery.SkipToken;
};

export function getFlappybirdScoresQuery(
  variables: GetFlappybirdScoresVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/flappybird/scores",
      operationId: "getFlappybirdScores",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetFlappybirdScores(variables, signal),
  };
}

/**
 * Return the leaderboard
 */
export const useSuspenseGetFlappybirdScores = <
  TData = GetFlappybirdScoresResponse,
>(
  variables: GetFlappybirdScoresVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFlappybirdScoresResponse,
      GetFlappybirdScoresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetFlappybirdScoresResponse,
    GetFlappybirdScoresError,
    TData
  >({
    ...getFlappybirdScoresQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the leaderboard
 */
export const useGetFlappybirdScores = <TData = GetFlappybirdScoresResponse,>(
  variables: GetFlappybirdScoresVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetFlappybirdScoresResponse,
      GetFlappybirdScoresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetFlappybirdScoresResponse,
    GetFlappybirdScoresError,
    TData
  >({
    ...getFlappybirdScoresQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostFlappybirdScoresError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostFlappybirdScoresVariables = {
  body: Schemas.FlappyBirdScoreBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostFlappybirdScores = (
  variables: PostFlappybirdScoresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.FlappyBirdScoreBase,
    PostFlappybirdScoresError,
    Schemas.FlappyBirdScoreBase,
    {},
    {},
    {}
  >({ url: "/flappybird/scores", method: "post", ...variables, signal });

export const usePostFlappybirdScores = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.FlappyBirdScoreBase,
      PostFlappybirdScoresError,
      PostFlappybirdScoresVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.FlappyBirdScoreBase,
    PostFlappybirdScoresError,
    PostFlappybirdScoresVariables
  >({
    mutationFn: (variables: PostFlappybirdScoresVariables) =>
      fetchPostFlappybirdScores(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetFlappybirdScoresMeError = Fetcher.ErrorWrapper<undefined>;

export type GetFlappybirdScoresMeVariables = HyperionContext["fetcherOptions"];

export const fetchGetFlappybirdScoresMe = (
  variables: GetFlappybirdScoresMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.FlappyBirdScoreCompleteFeedBack,
    GetFlappybirdScoresMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/flappybird/scores/me", method: "get", ...variables, signal });

export function getFlappybirdScoresMeQuery(
  variables: GetFlappybirdScoresMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.FlappyBirdScoreCompleteFeedBack>;
};

export function getFlappybirdScoresMeQuery(
  variables: GetFlappybirdScoresMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.FlappyBirdScoreCompleteFeedBack>)
    | reactQuery.SkipToken;
};

export function getFlappybirdScoresMeQuery(
  variables: GetFlappybirdScoresMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/flappybird/scores/me",
      operationId: "getFlappybirdScoresMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetFlappybirdScoresMe(variables, signal),
  };
}

export const useSuspenseGetFlappybirdScoresMe = <
  TData = Schemas.FlappyBirdScoreCompleteFeedBack,
>(
  variables: GetFlappybirdScoresMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FlappyBirdScoreCompleteFeedBack,
      GetFlappybirdScoresMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.FlappyBirdScoreCompleteFeedBack,
    GetFlappybirdScoresMeError,
    TData
  >({
    ...getFlappybirdScoresMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetFlappybirdScoresMe = <
  TData = Schemas.FlappyBirdScoreCompleteFeedBack,
>(
  variables: GetFlappybirdScoresMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.FlappyBirdScoreCompleteFeedBack,
      GetFlappybirdScoresMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.FlappyBirdScoreCompleteFeedBack,
    GetFlappybirdScoresMeError,
    TData
  >({
    ...getFlappybirdScoresMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DeleteFlappybirdScoresTargetedUserIdPathParams = {
  targetedUserId: string;
};

export type DeleteFlappybirdScoresTargetedUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteFlappybirdScoresTargetedUserIdVariables = {
  pathParams: DeleteFlappybirdScoresTargetedUserIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteFlappybirdScoresTargetedUserId = (
  variables: DeleteFlappybirdScoresTargetedUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteFlappybirdScoresTargetedUserIdError,
    undefined,
    {},
    {},
    DeleteFlappybirdScoresTargetedUserIdPathParams
  >({
    url: "/flappybird/scores/{targetedUserId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteFlappybirdScoresTargetedUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteFlappybirdScoresTargetedUserIdError,
      DeleteFlappybirdScoresTargetedUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteFlappybirdScoresTargetedUserIdError,
    DeleteFlappybirdScoresTargetedUserIdVariables
  >({
    mutationFn: (variables: DeleteFlappybirdScoresTargetedUserIdVariables) =>
      fetchDeleteFlappybirdScoresTargetedUserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionSportsError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionSportsResponse = Schemas.Sport[];

export type GetCompetitionSportsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSports = (
  variables: GetCompetitionSportsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionSportsResponse,
    GetCompetitionSportsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/sports", method: "get", ...variables, signal });

export function getCompetitionSportsQuery(
  variables: GetCompetitionSportsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCompetitionSportsResponse>;
};

export function getCompetitionSportsQuery(
  variables: GetCompetitionSportsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionSportsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionSportsQuery(
  variables: GetCompetitionSportsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/sports",
      operationId: "getCompetitionSports",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSports(variables, signal),
  };
}

export const useSuspenseGetCompetitionSports = <
  TData = GetCompetitionSportsResponse,
>(
  variables: GetCompetitionSportsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSportsResponse,
      GetCompetitionSportsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionSportsResponse,
    GetCompetitionSportsError,
    TData
  >({
    ...getCompetitionSportsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSports = <TData = GetCompetitionSportsResponse,>(
  variables: GetCompetitionSportsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSportsResponse,
      GetCompetitionSportsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionSportsResponse,
    GetCompetitionSportsError,
    TData
  >({
    ...getCompetitionSportsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionSportsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionSportsVariables = {
  body: Schemas.SportBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionSports = (
  variables: PostCompetitionSportsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Sport,
    PostCompetitionSportsError,
    Schemas.SportBase,
    {},
    {},
    {}
  >({ url: "/competition/sports", method: "post", ...variables, signal });

export const usePostCompetitionSports = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Sport,
      PostCompetitionSportsError,
      PostCompetitionSportsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Sport,
    PostCompetitionSportsError,
    PostCompetitionSportsVariables
  >({
    mutationFn: (variables: PostCompetitionSportsVariables) =>
      fetchPostCompetitionSports(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchCompetitionSportsSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type PatchCompetitionSportsSportIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionSportsSportIdVariables = {
  body?: Schemas.SportEdit;
  pathParams: PatchCompetitionSportsSportIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionSportsSportId = (
  variables: PatchCompetitionSportsSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionSportsSportIdError,
    Schemas.SportEdit,
    {},
    {},
    PatchCompetitionSportsSportIdPathParams
  >({
    url: "/competition/sports/{sportId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionSportsSportId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionSportsSportIdError,
      PatchCompetitionSportsSportIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionSportsSportIdError,
    PatchCompetitionSportsSportIdVariables
  >({
    mutationFn: (variables: PatchCompetitionSportsSportIdVariables) =>
      fetchPatchCompetitionSportsSportId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCompetitionSportsSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type DeleteCompetitionSportsSportIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionSportsSportIdVariables = {
  pathParams: DeleteCompetitionSportsSportIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionSportsSportId = (
  variables: DeleteCompetitionSportsSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionSportsSportIdError,
    undefined,
    {},
    {},
    DeleteCompetitionSportsSportIdPathParams
  >({
    url: "/competition/sports/{sportId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionSportsSportId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionSportsSportIdError,
      DeleteCompetitionSportsSportIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionSportsSportIdError,
    DeleteCompetitionSportsSportIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionSportsSportIdVariables) =>
      fetchDeleteCompetitionSportsSportId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionEditionsError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionEditionsResponse = Schemas.CompetitionEdition[];

export type GetCompetitionEditionsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCompetitionEditions = (
  variables: GetCompetitionEditionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionEditionsResponse,
    GetCompetitionEditionsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/editions", method: "get", ...variables, signal });

export function getCompetitionEditionsQuery(
  variables: GetCompetitionEditionsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCompetitionEditionsResponse>;
};

export function getCompetitionEditionsQuery(
  variables: GetCompetitionEditionsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionEditionsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionEditionsQuery(
  variables: GetCompetitionEditionsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/editions",
      operationId: "getCompetitionEditions",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionEditions(variables, signal),
  };
}

export const useSuspenseGetCompetitionEditions = <
  TData = GetCompetitionEditionsResponse,
>(
  variables: GetCompetitionEditionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionEditionsResponse,
      GetCompetitionEditionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionEditionsResponse,
    GetCompetitionEditionsError,
    TData
  >({
    ...getCompetitionEditionsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionEditions = <
  TData = GetCompetitionEditionsResponse,
>(
  variables: GetCompetitionEditionsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionEditionsResponse,
      GetCompetitionEditionsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionEditionsResponse,
    GetCompetitionEditionsError,
    TData
  >({
    ...getCompetitionEditionsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionEditionsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionEditionsVariables = {
  body: Schemas.CompetitionEditionBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionEditions = (
  variables: PostCompetitionEditionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CompetitionEdition,
    PostCompetitionEditionsError,
    Schemas.CompetitionEditionBase,
    {},
    {},
    {}
  >({ url: "/competition/editions", method: "post", ...variables, signal });

export const usePostCompetitionEditions = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CompetitionEdition,
      PostCompetitionEditionsError,
      PostCompetitionEditionsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CompetitionEdition,
    PostCompetitionEditionsError,
    PostCompetitionEditionsVariables
  >({
    mutationFn: (variables: PostCompetitionEditionsVariables) =>
      fetchPostCompetitionEditions(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionEditionsActiveError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionEditionsActiveVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get the currently active competition edition.
 * Returns None if no edition is active.
 */
export const fetchGetCompetitionEditionsActive = (
  variables: GetCompetitionEditionsActiveVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CompetitionEdition | null,
    GetCompetitionEditionsActiveError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/competition/editions/active",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the currently active competition edition.
 * Returns None if no edition is active.
 */
export function getCompetitionEditionsActiveQuery(
  variables: GetCompetitionEditionsActiveVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.CompetitionEdition | null>;
};

export function getCompetitionEditionsActiveQuery(
  variables: GetCompetitionEditionsActiveVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CompetitionEdition | null>)
    | reactQuery.SkipToken;
};

export function getCompetitionEditionsActiveQuery(
  variables: GetCompetitionEditionsActiveVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/editions/active",
      operationId: "getCompetitionEditionsActive",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionEditionsActive(variables, signal),
  };
}

/**
 * Get the currently active competition edition.
 * Returns None if no edition is active.
 */
export const useSuspenseGetCompetitionEditionsActive = <
  TData = Schemas.CompetitionEdition | null,
>(
  variables: GetCompetitionEditionsActiveVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CompetitionEdition | null,
      GetCompetitionEditionsActiveError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CompetitionEdition | null,
    GetCompetitionEditionsActiveError,
    TData
  >({
    ...getCompetitionEditionsActiveQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the currently active competition edition.
 * Returns None if no edition is active.
 */
export const useGetCompetitionEditionsActive = <
  TData = Schemas.CompetitionEdition | null,
>(
  variables: GetCompetitionEditionsActiveVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CompetitionEdition | null,
      GetCompetitionEditionsActiveError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CompetitionEdition | null,
    GetCompetitionEditionsActiveError,
    TData
  >({
    ...getCompetitionEditionsActiveQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionEditionsEditionIdActivatePathParams = {
  /**
   * @format uuid
   */
  editionId: string;
};

export type PostCompetitionEditionsEditionIdActivateError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCompetitionEditionsEditionIdActivateVariables = {
  pathParams: PostCompetitionEditionsEditionIdActivatePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Activate a competition edition.
 * If another edition is already active, it will be deactivated.
 */
export const fetchPostCompetitionEditionsEditionIdActivate = (
  variables: PostCompetitionEditionsEditionIdActivateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCompetitionEditionsEditionIdActivateError,
    undefined,
    {},
    {},
    PostCompetitionEditionsEditionIdActivatePathParams
  >({
    url: "/competition/editions/{editionId}/activate",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Activate a competition edition.
 * If another edition is already active, it will be deactivated.
 */
export const usePostCompetitionEditionsEditionIdActivate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCompetitionEditionsEditionIdActivateError,
      PostCompetitionEditionsEditionIdActivateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCompetitionEditionsEditionIdActivateError,
    PostCompetitionEditionsEditionIdActivateVariables
  >({
    mutationFn: (
      variables: PostCompetitionEditionsEditionIdActivateVariables,
    ) =>
      fetchPostCompetitionEditionsEditionIdActivate(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCompetitionEditionsEditionIdInscriptionPathParams = {
  /**
   * @format uuid
   */
  editionId: string;
};

export type PostCompetitionEditionsEditionIdInscriptionError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCompetitionEditionsEditionIdInscriptionVariables = {
  body?: boolean;
  pathParams: PostCompetitionEditionsEditionIdInscriptionPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Enable inscription for a competition edition.
 * The edition must already be active.
 */
export const fetchPostCompetitionEditionsEditionIdInscription = (
  variables: PostCompetitionEditionsEditionIdInscriptionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCompetitionEditionsEditionIdInscriptionError,
    boolean,
    {},
    {},
    PostCompetitionEditionsEditionIdInscriptionPathParams
  >({
    url: "/competition/editions/{editionId}/inscription",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Enable inscription for a competition edition.
 * The edition must already be active.
 */
export const usePostCompetitionEditionsEditionIdInscription = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCompetitionEditionsEditionIdInscriptionError,
      PostCompetitionEditionsEditionIdInscriptionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCompetitionEditionsEditionIdInscriptionError,
    PostCompetitionEditionsEditionIdInscriptionVariables
  >({
    mutationFn: (
      variables: PostCompetitionEditionsEditionIdInscriptionVariables,
    ) =>
      fetchPostCompetitionEditionsEditionIdInscription(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCompetitionEditionsEditionIdPathParams = {
  /**
   * @format uuid
   */
  editionId: string;
};

export type PatchCompetitionEditionsEditionIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionEditionsEditionIdVariables = {
  body?: Schemas.CompetitionEditionEdit;
  pathParams: PatchCompetitionEditionsEditionIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionEditionsEditionId = (
  variables: PatchCompetitionEditionsEditionIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionEditionsEditionIdError,
    Schemas.CompetitionEditionEdit,
    {},
    {},
    PatchCompetitionEditionsEditionIdPathParams
  >({
    url: "/competition/editions/{editionId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionEditionsEditionId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionEditionsEditionIdError,
      PatchCompetitionEditionsEditionIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionEditionsEditionIdError,
    PatchCompetitionEditionsEditionIdVariables
  >({
    mutationFn: (variables: PatchCompetitionEditionsEditionIdVariables) =>
      fetchPatchCompetitionEditionsEditionId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionUsersError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionUsersResponse = Schemas.CompetitionUser[];

export type GetCompetitionUsersVariables = HyperionContext["fetcherOptions"];

/**
 * Get all competition users for the current edition.
 */
export const fetchGetCompetitionUsers = (
  variables: GetCompetitionUsersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionUsersResponse,
    GetCompetitionUsersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/users", method: "get", ...variables, signal });

/**
 * Get all competition users for the current edition.
 */
export function getCompetitionUsersQuery(
  variables: GetCompetitionUsersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCompetitionUsersResponse>;
};

export function getCompetitionUsersQuery(
  variables: GetCompetitionUsersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionUsersResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionUsersQuery(
  variables: GetCompetitionUsersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/users",
      operationId: "getCompetitionUsers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionUsers(variables, signal),
  };
}

/**
 * Get all competition users for the current edition.
 */
export const useSuspenseGetCompetitionUsers = <
  TData = GetCompetitionUsersResponse,
>(
  variables: GetCompetitionUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersResponse,
      GetCompetitionUsersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionUsersResponse,
    GetCompetitionUsersError,
    TData
  >({
    ...getCompetitionUsersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all competition users for the current edition.
 */
export const useGetCompetitionUsers = <TData = GetCompetitionUsersResponse,>(
  variables: GetCompetitionUsersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersResponse,
      GetCompetitionUsersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionUsersResponse,
    GetCompetitionUsersError,
    TData
  >({
    ...getCompetitionUsersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionUsersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionUsersVariables = {
  body: Schemas.CompetitionUserBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a competition user for the current edition.
 * The user must exist in the core users database.
 */
export const fetchPostCompetitionUsers = (
  variables: PostCompetitionUsersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CompetitionUserSimple,
    PostCompetitionUsersError,
    Schemas.CompetitionUserBase,
    {},
    {},
    {}
  >({ url: "/competition/users", method: "post", ...variables, signal });

/**
 * Create a competition user for the current edition.
 * The user must exist in the core users database.
 */
export const usePostCompetitionUsers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CompetitionUserSimple,
      PostCompetitionUsersError,
      PostCompetitionUsersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CompetitionUserSimple,
    PostCompetitionUsersError,
    PostCompetitionUsersVariables
  >({
    mutationFn: (variables: PostCompetitionUsersVariables) =>
      fetchPostCompetitionUsers(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionUsersMeVariables = HyperionContext["fetcherOptions"];

/**
 * Get the competition user for the current edition.
 * This is the user making the request.
 */
export const fetchGetCompetitionUsersMe = (
  variables: GetCompetitionUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CompetitionUser,
    GetCompetitionUsersMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/users/me", method: "get", ...variables, signal });

/**
 * Get the competition user for the current edition.
 * This is the user making the request.
 */
export function getCompetitionUsersMeQuery(
  variables: GetCompetitionUsersMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CompetitionUser>;
};

export function getCompetitionUsersMeQuery(
  variables: GetCompetitionUsersMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CompetitionUser>)
    | reactQuery.SkipToken;
};

export function getCompetitionUsersMeQuery(
  variables: GetCompetitionUsersMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/users/me",
      operationId: "getCompetitionUsersMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionUsersMe(variables, signal),
  };
}

/**
 * Get the competition user for the current edition.
 * This is the user making the request.
 */
export const useSuspenseGetCompetitionUsersMe = <
  TData = Schemas.CompetitionUser,
>(
  variables: GetCompetitionUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CompetitionUser,
      GetCompetitionUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CompetitionUser,
    GetCompetitionUsersMeError,
    TData
  >({
    ...getCompetitionUsersMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the competition user for the current edition.
 * This is the user making the request.
 */
export const useGetCompetitionUsersMe = <TData = Schemas.CompetitionUser,>(
  variables: GetCompetitionUsersMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CompetitionUser,
      GetCompetitionUsersMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CompetitionUser,
    GetCompetitionUsersMeError,
    TData
  >({
    ...getCompetitionUsersMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCompetitionUsersMeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionUsersMeVariables = {
  body?: Schemas.CompetitionUserEdit;
} & HyperionContext["fetcherOptions"];

/**
 * Edit the current user's competition user for the current edition.
 * The user must exist in the core users database.
 */
export const fetchPatchCompetitionUsersMe = (
  variables: PatchCompetitionUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionUsersMeError,
    Schemas.CompetitionUserEdit,
    {},
    {},
    {}
  >({ url: "/competition/users/me", method: "patch", ...variables, signal });

/**
 * Edit the current user's competition user for the current edition.
 * The user must exist in the core users database.
 */
export const usePatchCompetitionUsersMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionUsersMeError,
      PatchCompetitionUsersMeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionUsersMeError,
    PatchCompetitionUsersMeVariables
  >({
    mutationFn: (variables: PatchCompetitionUsersMeVariables) =>
      fetchPatchCompetitionUsersMe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionUsersUserIdPathParams = {
  userId: string;
};

export type GetCompetitionUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionUsersUserIdVariables = {
  pathParams: GetCompetitionUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a competition user by their user ID for the current edition.
 */
export const fetchGetCompetitionUsersUserId = (
  variables: GetCompetitionUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CompetitionUser,
    GetCompetitionUsersUserIdError,
    undefined,
    {},
    {},
    GetCompetitionUsersUserIdPathParams
  >({
    url: "/competition/users/{userId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a competition user by their user ID for the current edition.
 */
export function getCompetitionUsersUserIdQuery(
  variables: GetCompetitionUsersUserIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CompetitionUser>;
};

export function getCompetitionUsersUserIdQuery(
  variables: GetCompetitionUsersUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CompetitionUser>)
    | reactQuery.SkipToken;
};

export function getCompetitionUsersUserIdQuery(
  variables: GetCompetitionUsersUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/users/{userId}",
      operationId: "getCompetitionUsersUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionUsersUserId(variables, signal),
  };
}

/**
 * Get a competition user by their user ID for the current edition.
 */
export const useSuspenseGetCompetitionUsersUserId = <
  TData = Schemas.CompetitionUser,
>(
  variables: GetCompetitionUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CompetitionUser,
      GetCompetitionUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CompetitionUser,
    GetCompetitionUsersUserIdError,
    TData
  >({
    ...getCompetitionUsersUserIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a competition user by their user ID for the current edition.
 */
export const useGetCompetitionUsersUserId = <TData = Schemas.CompetitionUser,>(
  variables: GetCompetitionUsersUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CompetitionUser,
      GetCompetitionUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CompetitionUser,
    GetCompetitionUsersUserIdError,
    TData
  >({
    ...getCompetitionUsersUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCompetitionUsersUserIdPathParams = {
  userId: string;
};

export type PatchCompetitionUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionUsersUserIdVariables = {
  body?: Schemas.CompetitionUserEdit;
  pathParams: PatchCompetitionUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a competition user for the current edition.
 * The user must exist in the core users database.
 */
export const fetchPatchCompetitionUsersUserId = (
  variables: PatchCompetitionUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionUsersUserIdError,
    Schemas.CompetitionUserEdit,
    {},
    {},
    PatchCompetitionUsersUserIdPathParams
  >({
    url: "/competition/users/{userId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a competition user for the current edition.
 * The user must exist in the core users database.
 */
export const usePatchCompetitionUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionUsersUserIdError,
      PatchCompetitionUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionUsersUserIdError,
    PatchCompetitionUsersUserIdVariables
  >({
    mutationFn: (variables: PatchCompetitionUsersUserIdVariables) =>
      fetchPatchCompetitionUsersUserId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionGroupsGroupPathParams = {
  group: Schemas.CompetitionGroupType;
};

export type GetCompetitionGroupsGroupError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionGroupsGroupResponse = Schemas.UserGroupMembership[];

export type GetCompetitionGroupsGroupVariables = {
  pathParams: GetCompetitionGroupsGroupPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get all users in a specific competition group for the current edition.
 */
export const fetchGetCompetitionGroupsGroup = (
  variables: GetCompetitionGroupsGroupVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionGroupsGroupResponse,
    GetCompetitionGroupsGroupError,
    undefined,
    {},
    {},
    GetCompetitionGroupsGroupPathParams
  >({
    url: "/competition/groups/{group}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all users in a specific competition group for the current edition.
 */
export function getCompetitionGroupsGroupQuery(
  variables: GetCompetitionGroupsGroupVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionGroupsGroupResponse>;
};

export function getCompetitionGroupsGroupQuery(
  variables: GetCompetitionGroupsGroupVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionGroupsGroupResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionGroupsGroupQuery(
  variables: GetCompetitionGroupsGroupVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/groups/{group}",
      operationId: "getCompetitionGroupsGroup",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionGroupsGroup(variables, signal),
  };
}

/**
 * Get all users in a specific competition group for the current edition.
 */
export const useSuspenseGetCompetitionGroupsGroup = <
  TData = GetCompetitionGroupsGroupResponse,
>(
  variables: GetCompetitionGroupsGroupVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionGroupsGroupResponse,
      GetCompetitionGroupsGroupError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionGroupsGroupResponse,
    GetCompetitionGroupsGroupError,
    TData
  >({
    ...getCompetitionGroupsGroupQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all users in a specific competition group for the current edition.
 */
export const useGetCompetitionGroupsGroup = <
  TData = GetCompetitionGroupsGroupResponse,
>(
  variables: GetCompetitionGroupsGroupVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionGroupsGroupResponse,
      GetCompetitionGroupsGroupError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionGroupsGroupResponse,
    GetCompetitionGroupsGroupError,
    TData
  >({
    ...getCompetitionGroupsGroupQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionUsersMeGroupsError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionUsersMeGroupsResponse = Schemas.UserGroupMembership[];

export type GetCompetitionUsersMeGroupsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get all groups the current user is a member of in the current edition.
 * This is the user making the request.
 */
export const fetchGetCompetitionUsersMeGroups = (
  variables: GetCompetitionUsersMeGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionUsersMeGroupsResponse,
    GetCompetitionUsersMeGroupsError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/competition/users/me/groups",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all groups the current user is a member of in the current edition.
 * This is the user making the request.
 */
export function getCompetitionUsersMeGroupsQuery(
  variables: GetCompetitionUsersMeGroupsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionUsersMeGroupsResponse>;
};

export function getCompetitionUsersMeGroupsQuery(
  variables: GetCompetitionUsersMeGroupsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionUsersMeGroupsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionUsersMeGroupsQuery(
  variables: GetCompetitionUsersMeGroupsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/users/me/groups",
      operationId: "getCompetitionUsersMeGroups",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionUsersMeGroups(variables, signal),
  };
}

/**
 * Get all groups the current user is a member of in the current edition.
 * This is the user making the request.
 */
export const useSuspenseGetCompetitionUsersMeGroups = <
  TData = GetCompetitionUsersMeGroupsResponse,
>(
  variables: GetCompetitionUsersMeGroupsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersMeGroupsResponse,
      GetCompetitionUsersMeGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionUsersMeGroupsResponse,
    GetCompetitionUsersMeGroupsError,
    TData
  >({
    ...getCompetitionUsersMeGroupsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all groups the current user is a member of in the current edition.
 * This is the user making the request.
 */
export const useGetCompetitionUsersMeGroups = <
  TData = GetCompetitionUsersMeGroupsResponse,
>(
  variables: GetCompetitionUsersMeGroupsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersMeGroupsResponse,
      GetCompetitionUsersMeGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionUsersMeGroupsResponse,
    GetCompetitionUsersMeGroupsError,
    TData
  >({
    ...getCompetitionUsersMeGroupsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionUsersUserIdGroupsPathParams = {
  userId: string;
};

export type GetCompetitionUsersUserIdGroupsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionUsersUserIdGroupsResponse =
  Schemas.UserGroupMembership[];

export type GetCompetitionUsersUserIdGroupsVariables = {
  pathParams: GetCompetitionUsersUserIdGroupsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get all groups a user is a member of in the current edition.
 */
export const fetchGetCompetitionUsersUserIdGroups = (
  variables: GetCompetitionUsersUserIdGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionUsersUserIdGroupsResponse,
    GetCompetitionUsersUserIdGroupsError,
    undefined,
    {},
    {},
    GetCompetitionUsersUserIdGroupsPathParams
  >({
    url: "/competition/users/{userId}/groups",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all groups a user is a member of in the current edition.
 */
export function getCompetitionUsersUserIdGroupsQuery(
  variables: GetCompetitionUsersUserIdGroupsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionUsersUserIdGroupsResponse>;
};

export function getCompetitionUsersUserIdGroupsQuery(
  variables: GetCompetitionUsersUserIdGroupsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionUsersUserIdGroupsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionUsersUserIdGroupsQuery(
  variables: GetCompetitionUsersUserIdGroupsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/users/{userId}/groups",
      operationId: "getCompetitionUsersUserIdGroups",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionUsersUserIdGroups(variables, signal),
  };
}

/**
 * Get all groups a user is a member of in the current edition.
 */
export const useSuspenseGetCompetitionUsersUserIdGroups = <
  TData = GetCompetitionUsersUserIdGroupsResponse,
>(
  variables: GetCompetitionUsersUserIdGroupsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersUserIdGroupsResponse,
      GetCompetitionUsersUserIdGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionUsersUserIdGroupsResponse,
    GetCompetitionUsersUserIdGroupsError,
    TData
  >({
    ...getCompetitionUsersUserIdGroupsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all groups a user is a member of in the current edition.
 */
export const useGetCompetitionUsersUserIdGroups = <
  TData = GetCompetitionUsersUserIdGroupsResponse,
>(
  variables: GetCompetitionUsersUserIdGroupsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersUserIdGroupsResponse,
      GetCompetitionUsersUserIdGroupsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionUsersUserIdGroupsResponse,
    GetCompetitionUsersUserIdGroupsError,
    TData
  >({
    ...getCompetitionUsersUserIdGroupsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionGroupsGroupUsersUserIdPathParams = {
  group: Schemas.CompetitionGroupType;
  userId: string;
};

export type PostCompetitionGroupsGroupUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionGroupsGroupUsersUserIdVariables = {
  pathParams: PostCompetitionGroupsGroupUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionGroupsGroupUsersUserId = (
  variables: PostCompetitionGroupsGroupUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.UserGroupMembership,
    PostCompetitionGroupsGroupUsersUserIdError,
    undefined,
    {},
    {},
    PostCompetitionGroupsGroupUsersUserIdPathParams
  >({
    url: "/competition/groups/{group}/users/{userId}",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCompetitionGroupsGroupUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserGroupMembership,
      PostCompetitionGroupsGroupUsersUserIdError,
      PostCompetitionGroupsGroupUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.UserGroupMembership,
    PostCompetitionGroupsGroupUsersUserIdError,
    PostCompetitionGroupsGroupUsersUserIdVariables
  >({
    mutationFn: (variables: PostCompetitionGroupsGroupUsersUserIdVariables) =>
      fetchPostCompetitionGroupsGroupUsersUserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionGroupsGroupUsersUserIdPathParams = {
  group: Schemas.CompetitionGroupType;
  userId: string;
};

export type DeleteCompetitionGroupsGroupUsersUserIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCompetitionGroupsGroupUsersUserIdVariables = {
  pathParams: DeleteCompetitionGroupsGroupUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionGroupsGroupUsersUserId = (
  variables: DeleteCompetitionGroupsGroupUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionGroupsGroupUsersUserIdError,
    undefined,
    {},
    {},
    DeleteCompetitionGroupsGroupUsersUserIdPathParams
  >({
    url: "/competition/groups/{group}/users/{userId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionGroupsGroupUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionGroupsGroupUsersUserIdError,
      DeleteCompetitionGroupsGroupUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionGroupsGroupUsersUserIdError,
    DeleteCompetitionGroupsGroupUsersUserIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionGroupsGroupUsersUserIdVariables) =>
      fetchDeleteCompetitionGroupsGroupUsersUserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionSchoolsError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionSchoolsResponse = Schemas.SchoolExtension[];

export type GetCompetitionSchoolsVariables = HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSchools = (
  variables: GetCompetitionSchoolsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionSchoolsResponse,
    GetCompetitionSchoolsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/schools", method: "get", ...variables, signal });

export function getCompetitionSchoolsQuery(
  variables: GetCompetitionSchoolsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCompetitionSchoolsResponse>;
};

export function getCompetitionSchoolsQuery(
  variables: GetCompetitionSchoolsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionSchoolsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionSchoolsQuery(
  variables: GetCompetitionSchoolsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/schools",
      operationId: "getCompetitionSchools",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSchools(variables, signal),
  };
}

export const useSuspenseGetCompetitionSchools = <
  TData = GetCompetitionSchoolsResponse,
>(
  variables: GetCompetitionSchoolsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSchoolsResponse,
      GetCompetitionSchoolsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionSchoolsResponse,
    GetCompetitionSchoolsError,
    TData
  >({
    ...getCompetitionSchoolsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSchools = <
  TData = GetCompetitionSchoolsResponse,
>(
  variables: GetCompetitionSchoolsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSchoolsResponse,
      GetCompetitionSchoolsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionSchoolsResponse,
    GetCompetitionSchoolsError,
    TData
  >({
    ...getCompetitionSchoolsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionSchoolsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionSchoolsVariables = {
  body: Schemas.SchoolExtensionBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionSchools = (
  variables: PostCompetitionSchoolsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SchoolExtensionBase,
    PostCompetitionSchoolsError,
    Schemas.SchoolExtensionBase,
    {},
    {},
    {}
  >({ url: "/competition/schools", method: "post", ...variables, signal });

export const usePostCompetitionSchools = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SchoolExtensionBase,
      PostCompetitionSchoolsError,
      PostCompetitionSchoolsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SchoolExtensionBase,
    PostCompetitionSchoolsError,
    PostCompetitionSchoolsVariables
  >({
    mutationFn: (variables: PostCompetitionSchoolsVariables) =>
      fetchPostCompetitionSchools(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type GetCompetitionSchoolsSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionSchoolsSchoolIdVariables = {
  pathParams: GetCompetitionSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSchoolsSchoolId = (
  variables: GetCompetitionSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SchoolExtensionComplete,
    GetCompetitionSchoolsSchoolIdError,
    undefined,
    {},
    {},
    GetCompetitionSchoolsSchoolIdPathParams
  >({
    url: "/competition/schools/{schoolId}",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionSchoolsSchoolIdQuery(
  variables: GetCompetitionSchoolsSchoolIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SchoolExtensionComplete>;
};

export function getCompetitionSchoolsSchoolIdQuery(
  variables: GetCompetitionSchoolsSchoolIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.SchoolExtensionComplete>)
    | reactQuery.SkipToken;
};

export function getCompetitionSchoolsSchoolIdQuery(
  variables: GetCompetitionSchoolsSchoolIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/schools/{schoolId}",
      operationId: "getCompetitionSchoolsSchoolId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSchoolsSchoolId(variables, signal),
  };
}

export const useSuspenseGetCompetitionSchoolsSchoolId = <
  TData = Schemas.SchoolExtensionComplete,
>(
  variables: GetCompetitionSchoolsSchoolIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SchoolExtensionComplete,
      GetCompetitionSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SchoolExtensionComplete,
    GetCompetitionSchoolsSchoolIdError,
    TData
  >({
    ...getCompetitionSchoolsSchoolIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSchoolsSchoolId = <
  TData = Schemas.SchoolExtensionComplete,
>(
  variables: GetCompetitionSchoolsSchoolIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SchoolExtensionComplete,
      GetCompetitionSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.SchoolExtensionComplete,
    GetCompetitionSchoolsSchoolIdError,
    TData
  >({
    ...getCompetitionSchoolsSchoolIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCompetitionSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type PatchCompetitionSchoolsSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionSchoolsSchoolIdVariables = {
  body?: Schemas.SchoolExtensionEdit;
  pathParams: PatchCompetitionSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionSchoolsSchoolId = (
  variables: PatchCompetitionSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionSchoolsSchoolIdError,
    Schemas.SchoolExtensionEdit,
    {},
    {},
    PatchCompetitionSchoolsSchoolIdPathParams
  >({
    url: "/competition/schools/{schoolId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionSchoolsSchoolId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionSchoolsSchoolIdError,
      PatchCompetitionSchoolsSchoolIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionSchoolsSchoolIdError,
    PatchCompetitionSchoolsSchoolIdVariables
  >({
    mutationFn: (variables: PatchCompetitionSchoolsSchoolIdVariables) =>
      fetchPatchCompetitionSchoolsSchoolId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type DeleteCompetitionSchoolsSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionSchoolsSchoolIdVariables = {
  pathParams: DeleteCompetitionSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionSchoolsSchoolId = (
  variables: DeleteCompetitionSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionSchoolsSchoolIdError,
    undefined,
    {},
    {},
    DeleteCompetitionSchoolsSchoolIdPathParams
  >({
    url: "/competition/schools/{schoolId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionSchoolsSchoolId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionSchoolsSchoolIdError,
      DeleteCompetitionSchoolsSchoolIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionSchoolsSchoolIdError,
    DeleteCompetitionSchoolsSchoolIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionSchoolsSchoolIdVariables) =>
      fetchDeleteCompetitionSchoolsSchoolId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCompetitionSchoolsSchoolIdGeneralQuotaPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type PostCompetitionSchoolsSchoolIdGeneralQuotaError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCompetitionSchoolsSchoolIdGeneralQuotaVariables = {
  body?: Schemas.SchoolGeneralQuotaBase;
  pathParams: PostCompetitionSchoolsSchoolIdGeneralQuotaPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionSchoolsSchoolIdGeneralQuota = (
  variables: PostCompetitionSchoolsSchoolIdGeneralQuotaVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SchoolGeneralQuota,
    PostCompetitionSchoolsSchoolIdGeneralQuotaError,
    Schemas.SchoolGeneralQuotaBase,
    {},
    {},
    PostCompetitionSchoolsSchoolIdGeneralQuotaPathParams
  >({
    url: "/competition/schools/{schoolId}/general-quota",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCompetitionSchoolsSchoolIdGeneralQuota = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SchoolGeneralQuota,
      PostCompetitionSchoolsSchoolIdGeneralQuotaError,
      PostCompetitionSchoolsSchoolIdGeneralQuotaVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SchoolGeneralQuota,
    PostCompetitionSchoolsSchoolIdGeneralQuotaError,
    PostCompetitionSchoolsSchoolIdGeneralQuotaVariables
  >({
    mutationFn: (
      variables: PostCompetitionSchoolsSchoolIdGeneralQuotaVariables,
    ) =>
      fetchPostCompetitionSchoolsSchoolIdGeneralQuota(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCompetitionSchoolsSchoolIdGeneralQuotaPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type PatchCompetitionSchoolsSchoolIdGeneralQuotaError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCompetitionSchoolsSchoolIdGeneralQuotaVariables = {
  body?: Schemas.SchoolGeneralQuotaBase;
  pathParams: PatchCompetitionSchoolsSchoolIdGeneralQuotaPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionSchoolsSchoolIdGeneralQuota = (
  variables: PatchCompetitionSchoolsSchoolIdGeneralQuotaVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionSchoolsSchoolIdGeneralQuotaError,
    Schemas.SchoolGeneralQuotaBase,
    {},
    {},
    PatchCompetitionSchoolsSchoolIdGeneralQuotaPathParams
  >({
    url: "/competition/schools/{schoolId}/general-quota",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionSchoolsSchoolIdGeneralQuota = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionSchoolsSchoolIdGeneralQuotaError,
      PatchCompetitionSchoolsSchoolIdGeneralQuotaVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionSchoolsSchoolIdGeneralQuotaError,
    PatchCompetitionSchoolsSchoolIdGeneralQuotaVariables
  >({
    mutationFn: (
      variables: PatchCompetitionSchoolsSchoolIdGeneralQuotaVariables,
    ) =>
      fetchPatchCompetitionSchoolsSchoolIdGeneralQuota(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionSportsSportIdQuotasPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type GetCompetitionSportsSportIdQuotasError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionSportsSportIdQuotasResponse = Schemas.SportQuota[];

export type GetCompetitionSportsSportIdQuotasVariables = {
  pathParams: GetCompetitionSportsSportIdQuotasPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSportsSportIdQuotas = (
  variables: GetCompetitionSportsSportIdQuotasVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionSportsSportIdQuotasResponse,
    GetCompetitionSportsSportIdQuotasError,
    undefined,
    {},
    {},
    GetCompetitionSportsSportIdQuotasPathParams
  >({
    url: "/competition/sports/{sportId}/quotas",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionSportsSportIdQuotasQuery(
  variables: GetCompetitionSportsSportIdQuotasVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionSportsSportIdQuotasResponse>;
};

export function getCompetitionSportsSportIdQuotasQuery(
  variables: GetCompetitionSportsSportIdQuotasVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionSportsSportIdQuotasResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionSportsSportIdQuotasQuery(
  variables: GetCompetitionSportsSportIdQuotasVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/sports/{sportId}/quotas",
      operationId: "getCompetitionSportsSportIdQuotas",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSportsSportIdQuotas(variables, signal),
  };
}

export const useSuspenseGetCompetitionSportsSportIdQuotas = <
  TData = GetCompetitionSportsSportIdQuotasResponse,
>(
  variables: GetCompetitionSportsSportIdQuotasVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSportsSportIdQuotasResponse,
      GetCompetitionSportsSportIdQuotasError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionSportsSportIdQuotasResponse,
    GetCompetitionSportsSportIdQuotasError,
    TData
  >({
    ...getCompetitionSportsSportIdQuotasQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSportsSportIdQuotas = <
  TData = GetCompetitionSportsSportIdQuotasResponse,
>(
  variables: GetCompetitionSportsSportIdQuotasVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSportsSportIdQuotasResponse,
      GetCompetitionSportsSportIdQuotasError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionSportsSportIdQuotasResponse,
    GetCompetitionSportsSportIdQuotasError,
    TData
  >({
    ...getCompetitionSportsSportIdQuotasQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionSchoolsSchoolIdQuotasPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type GetCompetitionSchoolsSchoolIdQuotasError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionSchoolsSchoolIdQuotasResponse = Schemas.SportQuota[];

export type GetCompetitionSchoolsSchoolIdQuotasVariables = {
  pathParams: GetCompetitionSchoolsSchoolIdQuotasPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSchoolsSchoolIdQuotas = (
  variables: GetCompetitionSchoolsSchoolIdQuotasVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionSchoolsSchoolIdQuotasResponse,
    GetCompetitionSchoolsSchoolIdQuotasError,
    undefined,
    {},
    {},
    GetCompetitionSchoolsSchoolIdQuotasPathParams
  >({
    url: "/competition/schools/{schoolId}/quotas",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionSchoolsSchoolIdQuotasQuery(
  variables: GetCompetitionSchoolsSchoolIdQuotasVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionSchoolsSchoolIdQuotasResponse>;
};

export function getCompetitionSchoolsSchoolIdQuotasQuery(
  variables:
    | GetCompetitionSchoolsSchoolIdQuotasVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionSchoolsSchoolIdQuotasResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionSchoolsSchoolIdQuotasQuery(
  variables:
    | GetCompetitionSchoolsSchoolIdQuotasVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/schools/{schoolId}/quotas",
      operationId: "getCompetitionSchoolsSchoolIdQuotas",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSchoolsSchoolIdQuotas(variables, signal),
  };
}

export const useSuspenseGetCompetitionSchoolsSchoolIdQuotas = <
  TData = GetCompetitionSchoolsSchoolIdQuotasResponse,
>(
  variables: GetCompetitionSchoolsSchoolIdQuotasVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSchoolsSchoolIdQuotasResponse,
      GetCompetitionSchoolsSchoolIdQuotasError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionSchoolsSchoolIdQuotasResponse,
    GetCompetitionSchoolsSchoolIdQuotasError,
    TData
  >({
    ...getCompetitionSchoolsSchoolIdQuotasQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSchoolsSchoolIdQuotas = <
  TData = GetCompetitionSchoolsSchoolIdQuotasResponse,
>(
  variables:
    | GetCompetitionSchoolsSchoolIdQuotasVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSchoolsSchoolIdQuotasResponse,
      GetCompetitionSchoolsSchoolIdQuotasError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionSchoolsSchoolIdQuotasResponse,
    GetCompetitionSchoolsSchoolIdQuotasError,
    TData
  >({
    ...getCompetitionSchoolsSchoolIdQuotasQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
  /**
   * @format uuid
   */
  sportId: string;
};

export type PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables = {
  body: Schemas.SportQuotaInfo;
  pathParams: PostCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionSchoolsSchoolIdSportsSportIdQuotas = (
  variables: PostCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
    Schemas.SportQuotaInfo,
    {},
    {},
    PostCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams
  >({
    url: "/competition/schools/{schoolId}/sports/{sportId}/quotas",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCompetitionSchoolsSchoolIdSportsSportIdQuotas = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
      PostCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
    PostCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables
  >({
    mutationFn: (
      variables: PostCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables,
    ) =>
      fetchPostCompetitionSchoolsSchoolIdSportsSportIdQuotas(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
  /**
   * @format uuid
   */
  sportId: string;
};

export type PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables = {
  body?: Schemas.SportQuotaEdit;
  pathParams: PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionSchoolsSchoolIdSportsSportIdQuotas = (
  variables: PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
    Schemas.SportQuotaEdit,
    {},
    {},
    PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams
  >({
    url: "/competition/schools/{schoolId}/sports/{sportId}/quotas",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionSchoolsSchoolIdSportsSportIdQuotas = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
      PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
    PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables
  >({
    mutationFn: (
      variables: PatchCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables,
    ) =>
      fetchPatchCompetitionSchoolsSchoolIdSportsSportIdQuotas(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
  /**
   * @format uuid
   */
  sportId: string;
};

export type DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables = {
  pathParams: DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionSchoolsSchoolIdSportsSportIdQuotas = (
  variables: DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
    undefined,
    {},
    {},
    DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasPathParams
  >({
    url: "/competition/schools/{schoolId}/sports/{sportId}/quotas",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionSchoolsSchoolIdSportsSportIdQuotas = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
      DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasError,
    DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables
  >({
    mutationFn: (
      variables: DeleteCompetitionSchoolsSchoolIdSportsSportIdQuotasVariables,
    ) =>
      fetchDeleteCompetitionSchoolsSchoolIdSportsSportIdQuotas(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionTeamsSportsSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type GetCompetitionTeamsSportsSportIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionTeamsSportsSportIdResponse = Schemas.TeamComplete[];

export type GetCompetitionTeamsSportsSportIdVariables = {
  pathParams: GetCompetitionTeamsSportsSportIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionTeamsSportsSportId = (
  variables: GetCompetitionTeamsSportsSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionTeamsSportsSportIdResponse,
    GetCompetitionTeamsSportsSportIdError,
    undefined,
    {},
    {},
    GetCompetitionTeamsSportsSportIdPathParams
  >({
    url: "/competition/teams/sports/{sportId}",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionTeamsSportsSportIdQuery(
  variables: GetCompetitionTeamsSportsSportIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionTeamsSportsSportIdResponse>;
};

export function getCompetitionTeamsSportsSportIdQuery(
  variables: GetCompetitionTeamsSportsSportIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionTeamsSportsSportIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionTeamsSportsSportIdQuery(
  variables: GetCompetitionTeamsSportsSportIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/teams/sports/{sportId}",
      operationId: "getCompetitionTeamsSportsSportId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionTeamsSportsSportId(variables, signal),
  };
}

export const useSuspenseGetCompetitionTeamsSportsSportId = <
  TData = GetCompetitionTeamsSportsSportIdResponse,
>(
  variables: GetCompetitionTeamsSportsSportIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionTeamsSportsSportIdResponse,
      GetCompetitionTeamsSportsSportIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionTeamsSportsSportIdResponse,
    GetCompetitionTeamsSportsSportIdError,
    TData
  >({
    ...getCompetitionTeamsSportsSportIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionTeamsSportsSportId = <
  TData = GetCompetitionTeamsSportsSportIdResponse,
>(
  variables: GetCompetitionTeamsSportsSportIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionTeamsSportsSportIdResponse,
      GetCompetitionTeamsSportsSportIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionTeamsSportsSportIdResponse,
    GetCompetitionTeamsSportsSportIdError,
    TData
  >({
    ...getCompetitionTeamsSportsSportIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionTeamsSportsSportIdSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
  /**
   * @format uuid
   */
  sportId: string;
};

export type GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse =
  Schemas.TeamComplete[];

export type GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables = {
  pathParams: GetCompetitionTeamsSportsSportIdSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionTeamsSportsSportIdSchoolsSchoolId = (
  variables: GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError,
    undefined,
    {},
    {},
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdPathParams
  >({
    url: "/competition/teams/sports/{sportId}/schools/{schoolId}",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionTeamsSportsSportIdSchoolsSchoolIdQuery(
  variables: GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse>;
};

export function getCompetitionTeamsSportsSportIdSchoolsSchoolIdQuery(
  variables:
    | GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionTeamsSportsSportIdSchoolsSchoolIdQuery(
  variables:
    | GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/teams/sports/{sportId}/schools/{schoolId}",
      operationId: "getCompetitionTeamsSportsSportIdSchoolsSchoolId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionTeamsSportsSportIdSchoolsSchoolId(
              variables,
              signal,
            ),
  };
}

export const useSuspenseGetCompetitionTeamsSportsSportIdSchoolsSchoolId = <
  TData = GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
>(
  variables: GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
      GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError,
    TData
  >({
    ...getCompetitionTeamsSportsSportIdSchoolsSchoolIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionTeamsSportsSportIdSchoolsSchoolId = <
  TData = GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
>(
  variables:
    | GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
      GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdResponse,
    GetCompetitionTeamsSportsSportIdSchoolsSchoolIdError,
    TData
  >({
    ...getCompetitionTeamsSportsSportIdSchoolsSchoolIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionTeamsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionTeamsVariables = {
  body: Schemas.TeamInfo;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionTeams = (
  variables: PostCompetitionTeamsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Team,
    PostCompetitionTeamsError,
    Schemas.TeamInfo,
    {},
    {},
    {}
  >({ url: "/competition/teams", method: "post", ...variables, signal });

export const usePostCompetitionTeams = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Team,
      PostCompetitionTeamsError,
      PostCompetitionTeamsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Team,
    PostCompetitionTeamsError,
    PostCompetitionTeamsVariables
  >({
    mutationFn: (variables: PostCompetitionTeamsVariables) =>
      fetchPostCompetitionTeams(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchCompetitionTeamsTeamIdPathParams = {
  /**
   * @format uuid
   */
  teamId: string;
};

export type PatchCompetitionTeamsTeamIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionTeamsTeamIdVariables = {
  body?: Schemas.TeamEdit;
  pathParams: PatchCompetitionTeamsTeamIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionTeamsTeamId = (
  variables: PatchCompetitionTeamsTeamIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionTeamsTeamIdError,
    Schemas.TeamEdit,
    {},
    {},
    PatchCompetitionTeamsTeamIdPathParams
  >({
    url: "/competition/teams/{teamId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionTeamsTeamId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionTeamsTeamIdError,
      PatchCompetitionTeamsTeamIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionTeamsTeamIdError,
    PatchCompetitionTeamsTeamIdVariables
  >({
    mutationFn: (variables: PatchCompetitionTeamsTeamIdVariables) =>
      fetchPatchCompetitionTeamsTeamId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCompetitionTeamsTeamIdPathParams = {
  /**
   * @format uuid
   */
  teamId: string;
};

export type DeleteCompetitionTeamsTeamIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionTeamsTeamIdVariables = {
  pathParams: DeleteCompetitionTeamsTeamIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionTeamsTeamId = (
  variables: DeleteCompetitionTeamsTeamIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionTeamsTeamIdError,
    undefined,
    {},
    {},
    DeleteCompetitionTeamsTeamIdPathParams
  >({
    url: "/competition/teams/{teamId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionTeamsTeamId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionTeamsTeamIdError,
      DeleteCompetitionTeamsTeamIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionTeamsTeamIdError,
    DeleteCompetitionTeamsTeamIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionTeamsTeamIdVariables) =>
      fetchDeleteCompetitionTeamsTeamId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionParticipantsMeError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionParticipantsMeVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetCompetitionParticipantsMe = (
  variables: GetCompetitionParticipantsMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.ParticipantComplete,
    GetCompetitionParticipantsMeError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/competition/participants/me",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionParticipantsMeQuery(
  variables: GetCompetitionParticipantsMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ParticipantComplete>;
};

export function getCompetitionParticipantsMeQuery(
  variables: GetCompetitionParticipantsMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ParticipantComplete>)
    | reactQuery.SkipToken;
};

export function getCompetitionParticipantsMeQuery(
  variables: GetCompetitionParticipantsMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/participants/me",
      operationId: "getCompetitionParticipantsMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionParticipantsMe(variables, signal),
  };
}

export const useSuspenseGetCompetitionParticipantsMe = <
  TData = Schemas.ParticipantComplete,
>(
  variables: GetCompetitionParticipantsMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ParticipantComplete,
      GetCompetitionParticipantsMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ParticipantComplete,
    GetCompetitionParticipantsMeError,
    TData
  >({
    ...getCompetitionParticipantsMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionParticipantsMe = <
  TData = Schemas.ParticipantComplete,
>(
  variables: GetCompetitionParticipantsMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ParticipantComplete,
      GetCompetitionParticipantsMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.ParticipantComplete,
    GetCompetitionParticipantsMeError,
    TData
  >({
    ...getCompetitionParticipantsMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionParticipantsSportsSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type GetCompetitionParticipantsSportsSportIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCompetitionParticipantsSportsSportIdResponse =
  Schemas.ParticipantComplete[];

export type GetCompetitionParticipantsSportsSportIdVariables = {
  pathParams: GetCompetitionParticipantsSportsSportIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionParticipantsSportsSportId = (
  variables: GetCompetitionParticipantsSportsSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionParticipantsSportsSportIdResponse,
    GetCompetitionParticipantsSportsSportIdError,
    undefined,
    {},
    {},
    GetCompetitionParticipantsSportsSportIdPathParams
  >({
    url: "/competition/participants/sports/{sportId}",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionParticipantsSportsSportIdQuery(
  variables: GetCompetitionParticipantsSportsSportIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionParticipantsSportsSportIdResponse>;
};

export function getCompetitionParticipantsSportsSportIdQuery(
  variables:
    | GetCompetitionParticipantsSportsSportIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionParticipantsSportsSportIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionParticipantsSportsSportIdQuery(
  variables:
    | GetCompetitionParticipantsSportsSportIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/participants/sports/{sportId}",
      operationId: "getCompetitionParticipantsSportsSportId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionParticipantsSportsSportId(variables, signal),
  };
}

export const useSuspenseGetCompetitionParticipantsSportsSportId = <
  TData = GetCompetitionParticipantsSportsSportIdResponse,
>(
  variables: GetCompetitionParticipantsSportsSportIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionParticipantsSportsSportIdResponse,
      GetCompetitionParticipantsSportsSportIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionParticipantsSportsSportIdResponse,
    GetCompetitionParticipantsSportsSportIdError,
    TData
  >({
    ...getCompetitionParticipantsSportsSportIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionParticipantsSportsSportId = <
  TData = GetCompetitionParticipantsSportsSportIdResponse,
>(
  variables:
    | GetCompetitionParticipantsSportsSportIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionParticipantsSportsSportIdResponse,
      GetCompetitionParticipantsSportsSportIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionParticipantsSportsSportIdResponse,
    GetCompetitionParticipantsSportsSportIdError,
    TData
  >({
    ...getCompetitionParticipantsSportsSportIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionParticipantsSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type GetCompetitionParticipantsSchoolsSchoolIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetCompetitionParticipantsSchoolsSchoolIdResponse =
  Schemas.ParticipantComplete[];

export type GetCompetitionParticipantsSchoolsSchoolIdVariables = {
  pathParams: GetCompetitionParticipantsSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionParticipantsSchoolsSchoolId = (
  variables: GetCompetitionParticipantsSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionParticipantsSchoolsSchoolIdResponse,
    GetCompetitionParticipantsSchoolsSchoolIdError,
    undefined,
    {},
    {},
    GetCompetitionParticipantsSchoolsSchoolIdPathParams
  >({
    url: "/competition/participants/schools/{schoolId}",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionParticipantsSchoolsSchoolIdQuery(
  variables: GetCompetitionParticipantsSchoolsSchoolIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionParticipantsSchoolsSchoolIdResponse>;
};

export function getCompetitionParticipantsSchoolsSchoolIdQuery(
  variables:
    | GetCompetitionParticipantsSchoolsSchoolIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionParticipantsSchoolsSchoolIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionParticipantsSchoolsSchoolIdQuery(
  variables:
    | GetCompetitionParticipantsSchoolsSchoolIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/participants/schools/{schoolId}",
      operationId: "getCompetitionParticipantsSchoolsSchoolId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionParticipantsSchoolsSchoolId(variables, signal),
  };
}

export const useSuspenseGetCompetitionParticipantsSchoolsSchoolId = <
  TData = GetCompetitionParticipantsSchoolsSchoolIdResponse,
>(
  variables: GetCompetitionParticipantsSchoolsSchoolIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionParticipantsSchoolsSchoolIdResponse,
      GetCompetitionParticipantsSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionParticipantsSchoolsSchoolIdResponse,
    GetCompetitionParticipantsSchoolsSchoolIdError,
    TData
  >({
    ...getCompetitionParticipantsSchoolsSchoolIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionParticipantsSchoolsSchoolId = <
  TData = GetCompetitionParticipantsSchoolsSchoolIdResponse,
>(
  variables:
    | GetCompetitionParticipantsSchoolsSchoolIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionParticipantsSchoolsSchoolIdResponse,
      GetCompetitionParticipantsSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionParticipantsSchoolsSchoolIdResponse,
    GetCompetitionParticipantsSchoolsSchoolIdError,
    TData
  >({
    ...getCompetitionParticipantsSchoolsSchoolIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionSportsSportIdParticipatePathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type PostCompetitionSportsSportIdParticipateError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCompetitionSportsSportIdParticipateVariables = {
  body?: Schemas.ParticipantInfo;
  pathParams: PostCompetitionSportsSportIdParticipatePathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionSportsSportIdParticipate = (
  variables: PostCompetitionSportsSportIdParticipateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Participant,
    PostCompetitionSportsSportIdParticipateError,
    Schemas.ParticipantInfo,
    {},
    {},
    PostCompetitionSportsSportIdParticipatePathParams
  >({
    url: "/competition/sports/{sportId}/participate",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCompetitionSportsSportIdParticipate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Participant,
      PostCompetitionSportsSportIdParticipateError,
      PostCompetitionSportsSportIdParticipateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Participant,
    PostCompetitionSportsSportIdParticipateError,
    PostCompetitionSportsSportIdParticipateVariables
  >({
    mutationFn: (variables: PostCompetitionSportsSportIdParticipateVariables) =>
      fetchPostCompetitionSportsSportIdParticipate(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCompetitionParticipantsUserIdSportsSportIdValidatePathParams =
  {
    userId: string;
    /**
     * @format uuid
     */
    sportId: string;
  };

export type PatchCompetitionParticipantsUserIdSportsSportIdValidateError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCompetitionParticipantsUserIdSportsSportIdValidateVariables = {
  pathParams: PatchCompetitionParticipantsUserIdSportsSportIdValidatePathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionParticipantsUserIdSportsSportIdValidate = (
  variables: PatchCompetitionParticipantsUserIdSportsSportIdValidateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionParticipantsUserIdSportsSportIdValidateError,
    undefined,
    {},
    {},
    PatchCompetitionParticipantsUserIdSportsSportIdValidatePathParams
  >({
    url: "/competition/participants/{userId}/sports/{sportId}/validate",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionParticipantsUserIdSportsSportIdValidate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionParticipantsUserIdSportsSportIdValidateError,
      PatchCompetitionParticipantsUserIdSportsSportIdValidateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionParticipantsUserIdSportsSportIdValidateError,
    PatchCompetitionParticipantsUserIdSportsSportIdValidateVariables
  >({
    mutationFn: (
      variables: PatchCompetitionParticipantsUserIdSportsSportIdValidateVariables,
    ) =>
      fetchPatchCompetitionParticipantsUserIdSportsSportIdValidate(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCompetitionParticipantsUserIdSportsSportIdInvalidatePathParams =
  {
    userId: string;
    /**
     * @format uuid
     */
    sportId: string;
  };

export type PatchCompetitionParticipantsUserIdSportsSportIdInvalidateError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCompetitionParticipantsUserIdSportsSportIdInvalidateVariables =
  {
    pathParams: PatchCompetitionParticipantsUserIdSportsSportIdInvalidatePathParams;
  } & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionParticipantsUserIdSportsSportIdInvalidate = (
  variables: PatchCompetitionParticipantsUserIdSportsSportIdInvalidateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionParticipantsUserIdSportsSportIdInvalidateError,
    undefined,
    {},
    {},
    PatchCompetitionParticipantsUserIdSportsSportIdInvalidatePathParams
  >({
    url: "/competition/participants/{userId}/sports/{sportId}/invalidate",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionParticipantsUserIdSportsSportIdInvalidate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionParticipantsUserIdSportsSportIdInvalidateError,
      PatchCompetitionParticipantsUserIdSportsSportIdInvalidateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionParticipantsUserIdSportsSportIdInvalidateError,
    PatchCompetitionParticipantsUserIdSportsSportIdInvalidateVariables
  >({
    mutationFn: (
      variables: PatchCompetitionParticipantsUserIdSportsSportIdInvalidateVariables,
    ) =>
      fetchPatchCompetitionParticipantsUserIdSportsSportIdInvalidate(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionParticipantsUserIdSportsSportIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  sportId: string;
};

export type DeleteCompetitionParticipantsUserIdSportsSportIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCompetitionParticipantsUserIdSportsSportIdVariables = {
  pathParams: DeleteCompetitionParticipantsUserIdSportsSportIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionParticipantsUserIdSportsSportId = (
  variables: DeleteCompetitionParticipantsUserIdSportsSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionParticipantsUserIdSportsSportIdError,
    undefined,
    {},
    {},
    DeleteCompetitionParticipantsUserIdSportsSportIdPathParams
  >({
    url: "/competition/participants/{userId}/sports/{sportId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionParticipantsUserIdSportsSportId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionParticipantsUserIdSportsSportIdError,
      DeleteCompetitionParticipantsUserIdSportsSportIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionParticipantsUserIdSportsSportIdError,
    DeleteCompetitionParticipantsUserIdSportsSportIdVariables
  >({
    mutationFn: (
      variables: DeleteCompetitionParticipantsUserIdSportsSportIdVariables,
    ) =>
      fetchDeleteCompetitionParticipantsUserIdSportsSportId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionLocationsError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionLocationsResponse = Schemas.Location[];

export type GetCompetitionLocationsVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetCompetitionLocations = (
  variables: GetCompetitionLocationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionLocationsResponse,
    GetCompetitionLocationsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/locations", method: "get", ...variables, signal });

export function getCompetitionLocationsQuery(
  variables: GetCompetitionLocationsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionLocationsResponse>;
};

export function getCompetitionLocationsQuery(
  variables: GetCompetitionLocationsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionLocationsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionLocationsQuery(
  variables: GetCompetitionLocationsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/locations",
      operationId: "getCompetitionLocations",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionLocations(variables, signal),
  };
}

export const useSuspenseGetCompetitionLocations = <
  TData = GetCompetitionLocationsResponse,
>(
  variables: GetCompetitionLocationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionLocationsResponse,
      GetCompetitionLocationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionLocationsResponse,
    GetCompetitionLocationsError,
    TData
  >({
    ...getCompetitionLocationsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionLocations = <
  TData = GetCompetitionLocationsResponse,
>(
  variables: GetCompetitionLocationsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionLocationsResponse,
      GetCompetitionLocationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionLocationsResponse,
    GetCompetitionLocationsError,
    TData
  >({
    ...getCompetitionLocationsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionLocationsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionLocationsVariables = {
  body: Schemas.LocationBase;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionLocations = (
  variables: PostCompetitionLocationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Location,
    PostCompetitionLocationsError,
    Schemas.LocationBase,
    {},
    {},
    {}
  >({ url: "/competition/locations", method: "post", ...variables, signal });

export const usePostCompetitionLocations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Location,
      PostCompetitionLocationsError,
      PostCompetitionLocationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Location,
    PostCompetitionLocationsError,
    PostCompetitionLocationsVariables
  >({
    mutationFn: (variables: PostCompetitionLocationsVariables) =>
      fetchPostCompetitionLocations(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCompetitionLocationsLocationIdPathParams = {
  /**
   * @format uuid
   */
  locationId: string;
};

export type GetCompetitionLocationsLocationIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionLocationsLocationIdVariables = {
  pathParams: GetCompetitionLocationsLocationIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionLocationsLocationId = (
  variables: GetCompetitionLocationsLocationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.LocationComplete,
    GetCompetitionLocationsLocationIdError,
    undefined,
    {},
    {},
    GetCompetitionLocationsLocationIdPathParams
  >({
    url: "/competition/locations/{locationId}",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionLocationsLocationIdQuery(
  variables: GetCompetitionLocationsLocationIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.LocationComplete>;
};

export function getCompetitionLocationsLocationIdQuery(
  variables: GetCompetitionLocationsLocationIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.LocationComplete>)
    | reactQuery.SkipToken;
};

export function getCompetitionLocationsLocationIdQuery(
  variables: GetCompetitionLocationsLocationIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/locations/{locationId}",
      operationId: "getCompetitionLocationsLocationId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionLocationsLocationId(variables, signal),
  };
}

export const useSuspenseGetCompetitionLocationsLocationId = <
  TData = Schemas.LocationComplete,
>(
  variables: GetCompetitionLocationsLocationIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LocationComplete,
      GetCompetitionLocationsLocationIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.LocationComplete,
    GetCompetitionLocationsLocationIdError,
    TData
  >({
    ...getCompetitionLocationsLocationIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionLocationsLocationId = <
  TData = Schemas.LocationComplete,
>(
  variables: GetCompetitionLocationsLocationIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.LocationComplete,
      GetCompetitionLocationsLocationIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.LocationComplete,
    GetCompetitionLocationsLocationIdError,
    TData
  >({
    ...getCompetitionLocationsLocationIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCompetitionLocationsLocationIdPathParams = {
  /**
   * @format uuid
   */
  locationId: string;
};

export type PatchCompetitionLocationsLocationIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionLocationsLocationIdVariables = {
  body?: Schemas.LocationEdit;
  pathParams: PatchCompetitionLocationsLocationIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionLocationsLocationId = (
  variables: PatchCompetitionLocationsLocationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionLocationsLocationIdError,
    Schemas.LocationEdit,
    {},
    {},
    PatchCompetitionLocationsLocationIdPathParams
  >({
    url: "/competition/locations/{locationId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionLocationsLocationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionLocationsLocationIdError,
      PatchCompetitionLocationsLocationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionLocationsLocationIdError,
    PatchCompetitionLocationsLocationIdVariables
  >({
    mutationFn: (variables: PatchCompetitionLocationsLocationIdVariables) =>
      fetchPatchCompetitionLocationsLocationId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionLocationsLocationIdPathParams = {
  /**
   * @format uuid
   */
  locationId: string;
};

export type DeleteCompetitionLocationsLocationIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionLocationsLocationIdVariables = {
  pathParams: DeleteCompetitionLocationsLocationIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionLocationsLocationId = (
  variables: DeleteCompetitionLocationsLocationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionLocationsLocationIdError,
    undefined,
    {},
    {},
    DeleteCompetitionLocationsLocationIdPathParams
  >({
    url: "/competition/locations/{locationId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionLocationsLocationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionLocationsLocationIdError,
      DeleteCompetitionLocationsLocationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionLocationsLocationIdError,
    DeleteCompetitionLocationsLocationIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionLocationsLocationIdVariables) =>
      fetchDeleteCompetitionLocationsLocationId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionSportsSportIdMatchesPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type GetCompetitionSportsSportIdMatchesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionSportsSportIdMatchesResponse = Schemas.Match[];

export type GetCompetitionSportsSportIdMatchesVariables = {
  pathParams: GetCompetitionSportsSportIdMatchesPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSportsSportIdMatches = (
  variables: GetCompetitionSportsSportIdMatchesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionSportsSportIdMatchesResponse,
    GetCompetitionSportsSportIdMatchesError,
    undefined,
    {},
    {},
    GetCompetitionSportsSportIdMatchesPathParams
  >({
    url: "/competition/sports/{sportId}/matches",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionSportsSportIdMatchesQuery(
  variables: GetCompetitionSportsSportIdMatchesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionSportsSportIdMatchesResponse>;
};

export function getCompetitionSportsSportIdMatchesQuery(
  variables: GetCompetitionSportsSportIdMatchesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionSportsSportIdMatchesResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionSportsSportIdMatchesQuery(
  variables: GetCompetitionSportsSportIdMatchesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/sports/{sportId}/matches",
      operationId: "getCompetitionSportsSportIdMatches",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSportsSportIdMatches(variables, signal),
  };
}

export const useSuspenseGetCompetitionSportsSportIdMatches = <
  TData = GetCompetitionSportsSportIdMatchesResponse,
>(
  variables: GetCompetitionSportsSportIdMatchesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSportsSportIdMatchesResponse,
      GetCompetitionSportsSportIdMatchesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionSportsSportIdMatchesResponse,
    GetCompetitionSportsSportIdMatchesError,
    TData
  >({
    ...getCompetitionSportsSportIdMatchesQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSportsSportIdMatches = <
  TData = GetCompetitionSportsSportIdMatchesResponse,
>(
  variables: GetCompetitionSportsSportIdMatchesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSportsSportIdMatchesResponse,
      GetCompetitionSportsSportIdMatchesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionSportsSportIdMatchesResponse,
    GetCompetitionSportsSportIdMatchesError,
    TData
  >({
    ...getCompetitionSportsSportIdMatchesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionSportsSportIdMatchesPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type PostCompetitionSportsSportIdMatchesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionSportsSportIdMatchesVariables = {
  body: Schemas.MatchBase;
  pathParams: PostCompetitionSportsSportIdMatchesPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPostCompetitionSportsSportIdMatches = (
  variables: PostCompetitionSportsSportIdMatchesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Match,
    PostCompetitionSportsSportIdMatchesError,
    Schemas.MatchBase,
    {},
    {},
    PostCompetitionSportsSportIdMatchesPathParams
  >({
    url: "/competition/sports/{sportId}/matches",
    method: "post",
    ...variables,
    signal,
  });

export const usePostCompetitionSportsSportIdMatches = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Match,
      PostCompetitionSportsSportIdMatchesError,
      PostCompetitionSportsSportIdMatchesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Match,
    PostCompetitionSportsSportIdMatchesError,
    PostCompetitionSportsSportIdMatchesVariables
  >({
    mutationFn: (variables: PostCompetitionSportsSportIdMatchesVariables) =>
      fetchPostCompetitionSportsSportIdMatches(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionSchoolsSchoolIdMatchesPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type GetCompetitionSchoolsSchoolIdMatchesQueryParams = {
  /**
   * @format uuid
   */
  sport_id: string;
};

export type GetCompetitionSchoolsSchoolIdMatchesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionSchoolsSchoolIdMatchesResponse = Schemas.Match[];

export type GetCompetitionSchoolsSchoolIdMatchesVariables = {
  pathParams: GetCompetitionSchoolsSchoolIdMatchesPathParams;
  queryParams: GetCompetitionSchoolsSchoolIdMatchesQueryParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCompetitionSchoolsSchoolIdMatches = (
  variables: GetCompetitionSchoolsSchoolIdMatchesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionSchoolsSchoolIdMatchesResponse,
    GetCompetitionSchoolsSchoolIdMatchesError,
    undefined,
    {},
    GetCompetitionSchoolsSchoolIdMatchesQueryParams,
    GetCompetitionSchoolsSchoolIdMatchesPathParams
  >({
    url: "/competition/schools/{schoolId}/matches",
    method: "get",
    ...variables,
    signal,
  });

export function getCompetitionSchoolsSchoolIdMatchesQuery(
  variables: GetCompetitionSchoolsSchoolIdMatchesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionSchoolsSchoolIdMatchesResponse>;
};

export function getCompetitionSchoolsSchoolIdMatchesQuery(
  variables:
    | GetCompetitionSchoolsSchoolIdMatchesVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionSchoolsSchoolIdMatchesResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionSchoolsSchoolIdMatchesQuery(
  variables:
    | GetCompetitionSchoolsSchoolIdMatchesVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/schools/{schoolId}/matches",
      operationId: "getCompetitionSchoolsSchoolIdMatches",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionSchoolsSchoolIdMatches(variables, signal),
  };
}

export const useSuspenseGetCompetitionSchoolsSchoolIdMatches = <
  TData = GetCompetitionSchoolsSchoolIdMatchesResponse,
>(
  variables: GetCompetitionSchoolsSchoolIdMatchesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSchoolsSchoolIdMatchesResponse,
      GetCompetitionSchoolsSchoolIdMatchesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionSchoolsSchoolIdMatchesResponse,
    GetCompetitionSchoolsSchoolIdMatchesError,
    TData
  >({
    ...getCompetitionSchoolsSchoolIdMatchesQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionSchoolsSchoolIdMatches = <
  TData = GetCompetitionSchoolsSchoolIdMatchesResponse,
>(
  variables:
    | GetCompetitionSchoolsSchoolIdMatchesVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionSchoolsSchoolIdMatchesResponse,
      GetCompetitionSchoolsSchoolIdMatchesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionSchoolsSchoolIdMatchesResponse,
    GetCompetitionSchoolsSchoolIdMatchesError,
    TData
  >({
    ...getCompetitionSchoolsSchoolIdMatchesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCompetitionMatchesMatchIdPathParams = {
  /**
   * @format uuid
   */
  matchId: string;
};

export type PatchCompetitionMatchesMatchIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionMatchesMatchIdVariables = {
  body?: Schemas.MatchEdit;
  pathParams: PatchCompetitionMatchesMatchIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchPatchCompetitionMatchesMatchId = (
  variables: PatchCompetitionMatchesMatchIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionMatchesMatchIdError,
    Schemas.MatchEdit,
    {},
    {},
    PatchCompetitionMatchesMatchIdPathParams
  >({
    url: "/competition/matches/{matchId}",
    method: "patch",
    ...variables,
    signal,
  });

export const usePatchCompetitionMatchesMatchId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionMatchesMatchIdError,
      PatchCompetitionMatchesMatchIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionMatchesMatchIdError,
    PatchCompetitionMatchesMatchIdVariables
  >({
    mutationFn: (variables: PatchCompetitionMatchesMatchIdVariables) =>
      fetchPatchCompetitionMatchesMatchId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCompetitionMatchesMatchIdPathParams = {
  /**
   * @format uuid
   */
  matchId: string;
};

export type DeleteCompetitionMatchesMatchIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionMatchesMatchIdVariables = {
  pathParams: DeleteCompetitionMatchesMatchIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteCompetitionMatchesMatchId = (
  variables: DeleteCompetitionMatchesMatchIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionMatchesMatchIdError,
    undefined,
    {},
    {},
    DeleteCompetitionMatchesMatchIdPathParams
  >({
    url: "/competition/matches/{matchId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteCompetitionMatchesMatchId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionMatchesMatchIdError,
      DeleteCompetitionMatchesMatchIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionMatchesMatchIdError,
    DeleteCompetitionMatchesMatchIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionMatchesMatchIdVariables) =>
      fetchDeleteCompetitionMatchesMatchId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionPodiumsGlobalError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionPodiumsGlobalResponse = Schemas.SchoolResult[];

export type GetCompetitionPodiumsGlobalVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get the global podiums for the current edition.
 */
export const fetchGetCompetitionPodiumsGlobal = (
  variables: GetCompetitionPodiumsGlobalVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionPodiumsGlobalResponse,
    GetCompetitionPodiumsGlobalError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/competition/podiums/global",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the global podiums for the current edition.
 */
export function getCompetitionPodiumsGlobalQuery(
  variables: GetCompetitionPodiumsGlobalVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionPodiumsGlobalResponse>;
};

export function getCompetitionPodiumsGlobalQuery(
  variables: GetCompetitionPodiumsGlobalVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionPodiumsGlobalResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionPodiumsGlobalQuery(
  variables: GetCompetitionPodiumsGlobalVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/podiums/global",
      operationId: "getCompetitionPodiumsGlobal",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionPodiumsGlobal(variables, signal),
  };
}

/**
 * Get the global podiums for the current edition.
 */
export const useSuspenseGetCompetitionPodiumsGlobal = <
  TData = GetCompetitionPodiumsGlobalResponse,
>(
  variables: GetCompetitionPodiumsGlobalVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPodiumsGlobalResponse,
      GetCompetitionPodiumsGlobalError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionPodiumsGlobalResponse,
    GetCompetitionPodiumsGlobalError,
    TData
  >({
    ...getCompetitionPodiumsGlobalQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the global podiums for the current edition.
 */
export const useGetCompetitionPodiumsGlobal = <
  TData = GetCompetitionPodiumsGlobalResponse,
>(
  variables: GetCompetitionPodiumsGlobalVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPodiumsGlobalResponse,
      GetCompetitionPodiumsGlobalError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionPodiumsGlobalResponse,
    GetCompetitionPodiumsGlobalError,
    TData
  >({
    ...getCompetitionPodiumsGlobalQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionPodiumsSportSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type GetCompetitionPodiumsSportSportIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionPodiumsSportSportIdResponse =
  Schemas.TeamSportResultComplete[];

export type GetCompetitionPodiumsSportSportIdVariables = {
  pathParams: GetCompetitionPodiumsSportSportIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the podiums for a specific sport in the current edition.
 */
export const fetchGetCompetitionPodiumsSportSportId = (
  variables: GetCompetitionPodiumsSportSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionPodiumsSportSportIdResponse,
    GetCompetitionPodiumsSportSportIdError,
    undefined,
    {},
    {},
    GetCompetitionPodiumsSportSportIdPathParams
  >({
    url: "/competition/podiums/sport/{sportId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the podiums for a specific sport in the current edition.
 */
export function getCompetitionPodiumsSportSportIdQuery(
  variables: GetCompetitionPodiumsSportSportIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionPodiumsSportSportIdResponse>;
};

export function getCompetitionPodiumsSportSportIdQuery(
  variables: GetCompetitionPodiumsSportSportIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionPodiumsSportSportIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionPodiumsSportSportIdQuery(
  variables: GetCompetitionPodiumsSportSportIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/podiums/sport/{sportId}",
      operationId: "getCompetitionPodiumsSportSportId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionPodiumsSportSportId(variables, signal),
  };
}

/**
 * Get the podiums for a specific sport in the current edition.
 */
export const useSuspenseGetCompetitionPodiumsSportSportId = <
  TData = GetCompetitionPodiumsSportSportIdResponse,
>(
  variables: GetCompetitionPodiumsSportSportIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPodiumsSportSportIdResponse,
      GetCompetitionPodiumsSportSportIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionPodiumsSportSportIdResponse,
    GetCompetitionPodiumsSportSportIdError,
    TData
  >({
    ...getCompetitionPodiumsSportSportIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the podiums for a specific sport in the current edition.
 */
export const useGetCompetitionPodiumsSportSportId = <
  TData = GetCompetitionPodiumsSportSportIdResponse,
>(
  variables: GetCompetitionPodiumsSportSportIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPodiumsSportSportIdResponse,
      GetCompetitionPodiumsSportSportIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionPodiumsSportSportIdResponse,
    GetCompetitionPodiumsSportSportIdError,
    TData
  >({
    ...getCompetitionPodiumsSportSportIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionPodiumsSportSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type PostCompetitionPodiumsSportSportIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionPodiumsSportSportIdResponse =
  Schemas.TeamSportResult[];

export type PostCompetitionPodiumsSportSportIdVariables = {
  body: Schemas.SportPodiumRankings;
  pathParams: PostCompetitionPodiumsSportSportIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create or update the podium for a specific sport in the current edition.
 */
export const fetchPostCompetitionPodiumsSportSportId = (
  variables: PostCompetitionPodiumsSportSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    PostCompetitionPodiumsSportSportIdResponse,
    PostCompetitionPodiumsSportSportIdError,
    Schemas.SportPodiumRankings,
    {},
    {},
    PostCompetitionPodiumsSportSportIdPathParams
  >({
    url: "/competition/podiums/sport/{sportId}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create or update the podium for a specific sport in the current edition.
 */
export const usePostCompetitionPodiumsSportSportId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      PostCompetitionPodiumsSportSportIdResponse,
      PostCompetitionPodiumsSportSportIdError,
      PostCompetitionPodiumsSportSportIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    PostCompetitionPodiumsSportSportIdResponse,
    PostCompetitionPodiumsSportSportIdError,
    PostCompetitionPodiumsSportSportIdVariables
  >({
    mutationFn: (variables: PostCompetitionPodiumsSportSportIdVariables) =>
      fetchPostCompetitionPodiumsSportSportId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionPodiumsSportSportIdPathParams = {
  /**
   * @format uuid
   */
  sportId: string;
};

export type DeleteCompetitionPodiumsSportSportIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionPodiumsSportSportIdVariables = {
  pathParams: DeleteCompetitionPodiumsSportSportIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete the podium for a specific sport in the current edition.
 */
export const fetchDeleteCompetitionPodiumsSportSportId = (
  variables: DeleteCompetitionPodiumsSportSportIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionPodiumsSportSportIdError,
    undefined,
    {},
    {},
    DeleteCompetitionPodiumsSportSportIdPathParams
  >({
    url: "/competition/podiums/sport/{sportId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete the podium for a specific sport in the current edition.
 */
export const useDeleteCompetitionPodiumsSportSportId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionPodiumsSportSportIdError,
      DeleteCompetitionPodiumsSportSportIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionPodiumsSportSportIdError,
    DeleteCompetitionPodiumsSportSportIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionPodiumsSportSportIdVariables) =>
      fetchDeleteCompetitionPodiumsSportSportId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionPodiumsSchoolSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type GetCompetitionPodiumsSchoolSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionPodiumsSchoolSchoolIdResponse =
  Schemas.TeamSportResultComplete[];

export type GetCompetitionPodiumsSchoolSchoolIdVariables = {
  pathParams: GetCompetitionPodiumsSchoolSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the podiums for a specific school in the current edition.
 */
export const fetchGetCompetitionPodiumsSchoolSchoolId = (
  variables: GetCompetitionPodiumsSchoolSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionPodiumsSchoolSchoolIdResponse,
    GetCompetitionPodiumsSchoolSchoolIdError,
    undefined,
    {},
    {},
    GetCompetitionPodiumsSchoolSchoolIdPathParams
  >({
    url: "/competition/podiums/school/{schoolId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the podiums for a specific school in the current edition.
 */
export function getCompetitionPodiumsSchoolSchoolIdQuery(
  variables: GetCompetitionPodiumsSchoolSchoolIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionPodiumsSchoolSchoolIdResponse>;
};

export function getCompetitionPodiumsSchoolSchoolIdQuery(
  variables:
    | GetCompetitionPodiumsSchoolSchoolIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionPodiumsSchoolSchoolIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionPodiumsSchoolSchoolIdQuery(
  variables:
    | GetCompetitionPodiumsSchoolSchoolIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/podiums/school/{schoolId}",
      operationId: "getCompetitionPodiumsSchoolSchoolId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionPodiumsSchoolSchoolId(variables, signal),
  };
}

/**
 * Get the podiums for a specific school in the current edition.
 */
export const useSuspenseGetCompetitionPodiumsSchoolSchoolId = <
  TData = GetCompetitionPodiumsSchoolSchoolIdResponse,
>(
  variables: GetCompetitionPodiumsSchoolSchoolIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPodiumsSchoolSchoolIdResponse,
      GetCompetitionPodiumsSchoolSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionPodiumsSchoolSchoolIdResponse,
    GetCompetitionPodiumsSchoolSchoolIdError,
    TData
  >({
    ...getCompetitionPodiumsSchoolSchoolIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the podiums for a specific school in the current edition.
 */
export const useGetCompetitionPodiumsSchoolSchoolId = <
  TData = GetCompetitionPodiumsSchoolSchoolIdResponse,
>(
  variables:
    | GetCompetitionPodiumsSchoolSchoolIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPodiumsSchoolSchoolIdResponse,
      GetCompetitionPodiumsSchoolSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionPodiumsSchoolSchoolIdResponse,
    GetCompetitionPodiumsSchoolSchoolIdError,
    TData
  >({
    ...getCompetitionPodiumsSchoolSchoolIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCompetitionProductsError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionProductsResponse =
  Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductComplete[];

export type GetCompetitionProductsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all products.
 */
export const fetchGetCompetitionProducts = (
  variables: GetCompetitionProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionProductsResponse,
    GetCompetitionProductsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/products", method: "get", ...variables, signal });

/**
 * Get all products.
 */
export function getCompetitionProductsQuery(
  variables: GetCompetitionProductsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCompetitionProductsResponse>;
};

export function getCompetitionProductsQuery(
  variables: GetCompetitionProductsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionProductsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionProductsQuery(
  variables: GetCompetitionProductsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/products",
      operationId: "getCompetitionProducts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionProducts(variables, signal),
  };
}

/**
 * Get all products.
 */
export const useSuspenseGetCompetitionProducts = <
  TData = GetCompetitionProductsResponse,
>(
  variables: GetCompetitionProductsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionProductsResponse,
      GetCompetitionProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionProductsResponse,
    GetCompetitionProductsError,
    TData
  >({
    ...getCompetitionProductsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all products.
 */
export const useGetCompetitionProducts = <
  TData = GetCompetitionProductsResponse,
>(
  variables: GetCompetitionProductsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionProductsResponse,
      GetCompetitionProductsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionProductsResponse,
    GetCompetitionProductsError,
    TData
  >({
    ...getCompetitionProductsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionProductsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionProductsVariables = {
  body: Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a product.
 */
export const fetchPostCompetitionProducts = (
  variables: PostCompetitionProductsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductComplete,
    PostCompetitionProductsError,
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductBase,
    {},
    {},
    {}
  >({ url: "/competition/products", method: "post", ...variables, signal });

/**
 * Create a product.
 */
export const usePostCompetitionProducts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductComplete,
      PostCompetitionProductsError,
      PostCompetitionProductsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductComplete,
    PostCompetitionProductsError,
    PostCompetitionProductsVariables
  >({
    mutationFn: (variables: PostCompetitionProductsVariables) =>
      fetchPostCompetitionProducts(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchCompetitionProductsProductIdPathParams = {
  /**
   * @format uuid
   */
  productId: string;
};

export type PatchCompetitionProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCompetitionProductsProductIdVariables = {
  body?: Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductEdit;
  pathParams: PatchCompetitionProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPatchCompetitionProductsProductId = (
  variables: PatchCompetitionProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionProductsProductIdError,
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductEdit,
    {},
    {},
    PatchCompetitionProductsProductIdPathParams
  >({
    url: "/competition/products/{productId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePatchCompetitionProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionProductsProductIdError,
      PatchCompetitionProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionProductsProductIdError,
    PatchCompetitionProductsProductIdVariables
  >({
    mutationFn: (variables: PatchCompetitionProductsProductIdVariables) =>
      fetchPatchCompetitionProductsProductId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionProductsProductIdPathParams = {
  /**
   * @format uuid
   */
  productId: string;
};

export type DeleteCompetitionProductsProductIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCompetitionProductsProductIdVariables = {
  pathParams: DeleteCompetitionProductsProductIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCompetitionProductsProductId = (
  variables: DeleteCompetitionProductsProductIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionProductsProductIdError,
    undefined,
    {},
    {},
    DeleteCompetitionProductsProductIdPathParams
  >({
    url: "/competition/products/{productId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a product.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useDeleteCompetitionProductsProductId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionProductsProductIdError,
      DeleteCompetitionProductsProductIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionProductsProductIdError,
    DeleteCompetitionProductsProductIdVariables
  >({
    mutationFn: (variables: DeleteCompetitionProductsProductIdVariables) =>
      fetchDeleteCompetitionProductsProductId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionProductsAvailableError =
  Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionProductsAvailableResponse =
  Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantComplete[];

export type GetCompetitionProductsAvailableVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get all available product variants of the current edition for this user.
 */
export const fetchGetCompetitionProductsAvailable = (
  variables: GetCompetitionProductsAvailableVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionProductsAvailableResponse,
    GetCompetitionProductsAvailableError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/competition/products/available",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all available product variants of the current edition for this user.
 */
export function getCompetitionProductsAvailableQuery(
  variables: GetCompetitionProductsAvailableVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionProductsAvailableResponse>;
};

export function getCompetitionProductsAvailableQuery(
  variables: GetCompetitionProductsAvailableVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionProductsAvailableResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionProductsAvailableQuery(
  variables: GetCompetitionProductsAvailableVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/products/available",
      operationId: "getCompetitionProductsAvailable",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionProductsAvailable(variables, signal),
  };
}

/**
 * Get all available product variants of the current edition for this user.
 */
export const useSuspenseGetCompetitionProductsAvailable = <
  TData = GetCompetitionProductsAvailableResponse,
>(
  variables: GetCompetitionProductsAvailableVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionProductsAvailableResponse,
      GetCompetitionProductsAvailableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionProductsAvailableResponse,
    GetCompetitionProductsAvailableError,
    TData
  >({
    ...getCompetitionProductsAvailableQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all available product variants of the current edition for this user.
 */
export const useGetCompetitionProductsAvailable = <
  TData = GetCompetitionProductsAvailableResponse,
>(
  variables: GetCompetitionProductsAvailableVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionProductsAvailableResponse,
      GetCompetitionProductsAvailableError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionProductsAvailableResponse,
    GetCompetitionProductsAvailableError,
    TData
  >({
    ...getCompetitionProductsAvailableQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionProductsProductIdVariantsPathParams = {
  /**
   * @format uuid
   */
  productId: string;
};

export type PostCompetitionProductsProductIdVariantsError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostCompetitionProductsProductIdVariantsVariables = {
  body: Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantBase;
  pathParams: PostCompetitionProductsProductIdVariantsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPostCompetitionProductsProductIdVariants = (
  variables: PostCompetitionProductsProductIdVariantsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantComplete,
    PostCompetitionProductsProductIdVariantsError,
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantBase,
    {},
    {},
    PostCompetitionProductsProductIdVariantsPathParams
  >({
    url: "/competition/products/{productId}/variants",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePostCompetitionProductsProductIdVariants = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantComplete,
      PostCompetitionProductsProductIdVariantsError,
      PostCompetitionProductsProductIdVariantsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantComplete,
    PostCompetitionProductsProductIdVariantsError,
    PostCompetitionProductsProductIdVariantsVariables
  >({
    mutationFn: (
      variables: PostCompetitionProductsProductIdVariantsVariables,
    ) =>
      fetchPostCompetitionProductsProductIdVariants(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchCompetitionProductsVariantsVariantIdPathParams = {
  /**
   * @format uuid
   */
  variantId: string;
};

export type PatchCompetitionProductsVariantsVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCompetitionProductsVariantsVariantIdVariables = {
  body?: Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantEdit;
  pathParams: PatchCompetitionProductsVariantsVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchPatchCompetitionProductsVariantsVariantId = (
  variables: PatchCompetitionProductsVariantsVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCompetitionProductsVariantsVariantIdError,
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionProductVariantEdit,
    {},
    {},
    PatchCompetitionProductsVariantsVariantIdPathParams
  >({
    url: "/competition/products/variants/{variantId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const usePatchCompetitionProductsVariantsVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCompetitionProductsVariantsVariantIdError,
      PatchCompetitionProductsVariantsVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCompetitionProductsVariantsVariantIdError,
    PatchCompetitionProductsVariantsVariantIdVariables
  >({
    mutationFn: (
      variables: PatchCompetitionProductsVariantsVariantIdVariables,
    ) =>
      fetchPatchCompetitionProductsVariantsVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionProductsVariantsVariantIdPathParams = {
  /**
   * @format uuid
   */
  variantId: string;
};

export type DeleteCompetitionProductsVariantsVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCompetitionProductsVariantsVariantIdVariables = {
  pathParams: DeleteCompetitionProductsVariantsVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCompetitionProductsVariantsVariantId = (
  variables: DeleteCompetitionProductsVariantsVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionProductsVariantsVariantIdError,
    undefined,
    {},
    {},
    DeleteCompetitionProductsVariantsVariantIdPathParams
  >({
    url: "/competition/products/variants/{variantId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a product variant.
 *
 * **User must be part of the seller's group to use this endpoint**
 */
export const useDeleteCompetitionProductsVariantsVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionProductsVariantsVariantIdError,
      DeleteCompetitionProductsVariantsVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionProductsVariantsVariantIdError,
    DeleteCompetitionProductsVariantsVariantIdVariables
  >({
    mutationFn: (
      variables: DeleteCompetitionProductsVariantsVariantIdVariables,
    ) =>
      fetchDeleteCompetitionProductsVariantsVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionPurchasesUsersUserIdPathParams = {
  userId: string;
};

export type GetCompetitionPurchasesUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionPurchasesUsersUserIdResponse = Schemas.Purchase[];

export type GetCompetitionPurchasesUsersUserIdVariables = {
  pathParams: GetCompetitionPurchasesUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const fetchGetCompetitionPurchasesUsersUserId = (
  variables: GetCompetitionPurchasesUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionPurchasesUsersUserIdResponse,
    GetCompetitionPurchasesUsersUserIdError,
    undefined,
    {},
    {},
    GetCompetitionPurchasesUsersUserIdPathParams
  >({
    url: "/competition/purchases/users/{userId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export function getCompetitionPurchasesUsersUserIdQuery(
  variables: GetCompetitionPurchasesUsersUserIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionPurchasesUsersUserIdResponse>;
};

export function getCompetitionPurchasesUsersUserIdQuery(
  variables: GetCompetitionPurchasesUsersUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionPurchasesUsersUserIdResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionPurchasesUsersUserIdQuery(
  variables: GetCompetitionPurchasesUsersUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/purchases/users/{userId}",
      operationId: "getCompetitionPurchasesUsersUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionPurchasesUsersUserId(variables, signal),
  };
}

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCompetitionPurchasesUsersUserId = <
  TData = GetCompetitionPurchasesUsersUserIdResponse,
>(
  variables: GetCompetitionPurchasesUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPurchasesUsersUserIdResponse,
      GetCompetitionPurchasesUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionPurchasesUsersUserIdResponse,
    GetCompetitionPurchasesUsersUserIdError,
    TData
  >({
    ...getCompetitionPurchasesUsersUserIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's purchases.
 *
 * **User must get his own purchases or be CDR Admin to use this endpoint**
 */
export const useGetCompetitionPurchasesUsersUserId = <
  TData = GetCompetitionPurchasesUsersUserIdResponse,
>(
  variables: GetCompetitionPurchasesUsersUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPurchasesUsersUserIdResponse,
      GetCompetitionPurchasesUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionPurchasesUsersUserIdResponse,
    GetCompetitionPurchasesUsersUserIdError,
    TData
  >({
    ...getCompetitionPurchasesUsersUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionPurchasesUsersUserIdPathParams = {
  userId: string;
};

export type PostCompetitionPurchasesUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionPurchasesUsersUserIdVariables = {
  body: Schemas.AppModulesSportCompetitionSchemasSportCompetitionPurchaseBase;
  pathParams: PostCompetitionPurchasesUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const fetchPostCompetitionPurchasesUsersUserId = (
  variables: PostCompetitionPurchasesUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Purchase,
    PostCompetitionPurchasesUsersUserIdError,
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionPurchaseBase,
    {},
    {},
    PostCompetitionPurchasesUsersUserIdPathParams
  >({
    url: "/competition/purchases/users/{userId}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const usePostCompetitionPurchasesUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Purchase,
      PostCompetitionPurchasesUsersUserIdError,
      PostCompetitionPurchasesUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Purchase,
    PostCompetitionPurchasesUsersUserIdError,
    PostCompetitionPurchasesUsersUserIdVariables
  >({
    mutationFn: (variables: PostCompetitionPurchasesUsersUserIdVariables) =>
      fetchPostCompetitionPurchasesUsersUserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionPurchasesMeError = Fetcher.ErrorWrapper<undefined>;

export type GetCompetitionPurchasesMeResponse = Schemas.Purchase[];

export type GetCompetitionPurchasesMeVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetCompetitionPurchasesMe = (
  variables: GetCompetitionPurchasesMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionPurchasesMeResponse,
    GetCompetitionPurchasesMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/purchases/me", method: "get", ...variables, signal });

export function getCompetitionPurchasesMeQuery(
  variables: GetCompetitionPurchasesMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionPurchasesMeResponse>;
};

export function getCompetitionPurchasesMeQuery(
  variables: GetCompetitionPurchasesMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCompetitionPurchasesMeResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionPurchasesMeQuery(
  variables: GetCompetitionPurchasesMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/purchases/me",
      operationId: "getCompetitionPurchasesMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionPurchasesMe(variables, signal),
  };
}

export const useSuspenseGetCompetitionPurchasesMe = <
  TData = GetCompetitionPurchasesMeResponse,
>(
  variables: GetCompetitionPurchasesMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPurchasesMeResponse,
      GetCompetitionPurchasesMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionPurchasesMeResponse,
    GetCompetitionPurchasesMeError,
    TData
  >({
    ...getCompetitionPurchasesMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCompetitionPurchasesMe = <
  TData = GetCompetitionPurchasesMeResponse,
>(
  variables: GetCompetitionPurchasesMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionPurchasesMeResponse,
      GetCompetitionPurchasesMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionPurchasesMeResponse,
    GetCompetitionPurchasesMeError,
    TData
  >({
    ...getCompetitionPurchasesMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedPathParams =
  {
    userId: string;
    /**
     * @format uuid
     */
    productVariantId: string;
  };

export type PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedQueryParams =
  {
    validated: boolean;
  };

export type PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedVariables =
  {
    pathParams: PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedPathParams;
    queryParams: PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedQueryParams;
  } & HyperionContext["fetcherOptions"];

/**
 * Validate a purchase.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPatchCompetitionUsersUserIdPurchasesProductVariantIdValidated =
  (
    variables: PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedVariables,
    signal?: AbortSignal,
  ) =>
    hyperionFetch<
      undefined,
      PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedError,
      undefined,
      {},
      PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedQueryParams,
      PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedPathParams
    >({
      url: "/competition/users/{userId}/purchases/{productVariantId}/validated",
      method: "patch",
      ...variables,
      signal,
    });

/**
 * Validate a purchase.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePatchCompetitionUsersUserIdPurchasesProductVariantIdValidated =
  (
    options?: Omit<
      reactQuery.UseMutationOptions<
        undefined,
        PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedError,
        PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedVariables
      >,
      "mutationFn"
    >,
  ) => {
    const { fetcherOptions } = useHyperionContext();
    return reactQuery.useMutation<
      undefined,
      PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedError,
      PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedVariables
    >({
      mutationFn: (
        variables: PatchCompetitionUsersUserIdPurchasesProductVariantIdValidatedVariables,
      ) =>
        fetchPatchCompetitionUsersUserIdPurchasesProductVariantIdValidated(
          deepMerge(fetcherOptions, variables),
        ),
      ...options,
    });
  };

export type DeleteCompetitionUsersUserIdPurchasesProductVariantIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  productVariantId: string;
};

export type DeleteCompetitionUsersUserIdPurchasesProductVariantIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCompetitionUsersUserIdPurchasesProductVariantIdVariables = {
  pathParams: DeleteCompetitionUsersUserIdPurchasesProductVariantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const fetchDeleteCompetitionUsersUserIdPurchasesProductVariantId = (
  variables: DeleteCompetitionUsersUserIdPurchasesProductVariantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionUsersUserIdPurchasesProductVariantIdError,
    undefined,
    {},
    {},
    DeleteCompetitionUsersUserIdPurchasesProductVariantIdPathParams
  >({
    url: "/competition/users/{userId}/purchases/{productVariantId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a purchase.
 *
 * **User must create a purchase for themself and for an online available product or be part of the seller's group to use this endpoint**
 */
export const useDeleteCompetitionUsersUserIdPurchasesProductVariantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionUsersUserIdPurchasesProductVariantIdError,
      DeleteCompetitionUsersUserIdPurchasesProductVariantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionUsersUserIdPurchasesProductVariantIdError,
    DeleteCompetitionUsersUserIdPurchasesProductVariantIdVariables
  >({
    mutationFn: (
      variables: DeleteCompetitionUsersUserIdPurchasesProductVariantIdVariables,
    ) =>
      fetchDeleteCompetitionUsersUserIdPurchasesProductVariantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetCompetitionUsersUserIdPaymentsPathParams = {
  userId: string;
};

export type GetCompetitionUsersUserIdPaymentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCompetitionUsersUserIdPaymentsResponse =
  Schemas.AppModulesSportCompetitionSchemasSportCompetitionPaymentComplete[];

export type GetCompetitionUsersUserIdPaymentsVariables = {
  pathParams: GetCompetitionUsersUserIdPaymentsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const fetchGetCompetitionUsersUserIdPayments = (
  variables: GetCompetitionUsersUserIdPaymentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCompetitionUsersUserIdPaymentsResponse,
    GetCompetitionUsersUserIdPaymentsError,
    undefined,
    {},
    {},
    GetCompetitionUsersUserIdPaymentsPathParams
  >({
    url: "/competition/users/{userId}/payments",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export function getCompetitionUsersUserIdPaymentsQuery(
  variables: GetCompetitionUsersUserIdPaymentsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCompetitionUsersUserIdPaymentsResponse>;
};

export function getCompetitionUsersUserIdPaymentsQuery(
  variables: GetCompetitionUsersUserIdPaymentsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCompetitionUsersUserIdPaymentsResponse>)
    | reactQuery.SkipToken;
};

export function getCompetitionUsersUserIdPaymentsQuery(
  variables: GetCompetitionUsersUserIdPaymentsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/competition/users/{userId}/payments",
      operationId: "getCompetitionUsersUserIdPayments",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCompetitionUsersUserIdPayments(variables, signal),
  };
}

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const useSuspenseGetCompetitionUsersUserIdPayments = <
  TData = GetCompetitionUsersUserIdPaymentsResponse,
>(
  variables: GetCompetitionUsersUserIdPaymentsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersUserIdPaymentsResponse,
      GetCompetitionUsersUserIdPaymentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCompetitionUsersUserIdPaymentsResponse,
    GetCompetitionUsersUserIdPaymentsError,
    TData
  >({
    ...getCompetitionUsersUserIdPaymentsQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a user's payments.
 *
 * **User must get his own payments or be CDR Admin to use this endpoint**
 */
export const useGetCompetitionUsersUserIdPayments = <
  TData = GetCompetitionUsersUserIdPaymentsResponse,
>(
  variables: GetCompetitionUsersUserIdPaymentsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCompetitionUsersUserIdPaymentsResponse,
      GetCompetitionUsersUserIdPaymentsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCompetitionUsersUserIdPaymentsResponse,
    GetCompetitionUsersUserIdPaymentsError,
    TData
  >({
    ...getCompetitionUsersUserIdPaymentsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCompetitionUsersUserIdPaymentsPathParams = {
  userId: string;
};

export type PostCompetitionUsersUserIdPaymentsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCompetitionUsersUserIdPaymentsVariables = {
  body: Schemas.AppModulesSportCompetitionSchemasSportCompetitionPaymentBase;
  pathParams: PostCompetitionUsersUserIdPaymentsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchPostCompetitionUsersUserIdPayments = (
  variables: PostCompetitionUsersUserIdPaymentsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionPaymentComplete,
    PostCompetitionUsersUserIdPaymentsError,
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionPaymentBase,
    {},
    {},
    PostCompetitionUsersUserIdPaymentsPathParams
  >({
    url: "/competition/users/{userId}/payments",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const usePostCompetitionUsersUserIdPayments = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppModulesSportCompetitionSchemasSportCompetitionPaymentComplete,
      PostCompetitionUsersUserIdPaymentsError,
      PostCompetitionUsersUserIdPaymentsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppModulesSportCompetitionSchemasSportCompetitionPaymentComplete,
    PostCompetitionUsersUserIdPaymentsError,
    PostCompetitionUsersUserIdPaymentsVariables
  >({
    mutationFn: (variables: PostCompetitionUsersUserIdPaymentsVariables) =>
      fetchPostCompetitionUsersUserIdPayments(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteCompetitionUsersUserIdPaymentsPaymentIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  paymentId: string;
};

export type DeleteCompetitionUsersUserIdPaymentsPaymentIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteCompetitionUsersUserIdPaymentsPaymentIdVariables = {
  pathParams: DeleteCompetitionUsersUserIdPaymentsPaymentIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const fetchDeleteCompetitionUsersUserIdPaymentsPaymentId = (
  variables: DeleteCompetitionUsersUserIdPaymentsPaymentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCompetitionUsersUserIdPaymentsPaymentIdError,
    undefined,
    {},
    {},
    DeleteCompetitionUsersUserIdPaymentsPaymentIdPathParams
  >({
    url: "/competition/users/{userId}/payments/{paymentId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove a payment.
 *
 * **User must be CDR Admin to use this endpoint**
 */
export const useDeleteCompetitionUsersUserIdPaymentsPaymentId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCompetitionUsersUserIdPaymentsPaymentIdError,
      DeleteCompetitionUsersUserIdPaymentsPaymentIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCompetitionUsersUserIdPaymentsPaymentIdError,
    DeleteCompetitionUsersUserIdPaymentsPaymentIdVariables
  >({
    mutationFn: (
      variables: DeleteCompetitionUsersUserIdPaymentsPaymentIdVariables,
    ) =>
      fetchDeleteCompetitionUsersUserIdPaymentsPaymentId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCompetitionPayError = Fetcher.ErrorWrapper<undefined>;

export type PostCompetitionPayVariables = HyperionContext["fetcherOptions"];

/**
 * Get payment url
 */
export const fetchPostCompetitionPay = (
  variables: PostCompetitionPayVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PaymentUrl,
    PostCompetitionPayError,
    undefined,
    {},
    {},
    {}
  >({ url: "/competition/pay", method: "post", ...variables, signal });

/**
 * Get payment url
 */
export const usePostCompetitionPay = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaymentUrl,
      PostCompetitionPayError,
      PostCompetitionPayVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PaymentUrl,
    PostCompetitionPayError,
    PostCompetitionPayVariables
  >({
    mutationFn: (variables: PostCompetitionPayVariables) =>
      fetchPostCompetitionPay(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAdvertAdvertisersError = Fetcher.ErrorWrapper<undefined>;

export type GetAdvertAdvertisersResponse = Schemas.AdvertiserComplete[];

export type GetAdvertAdvertisersVariables = HyperionContext["fetcherOptions"];

/**
 * Get existing advertisers.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdvertisers = (
  variables: GetAdvertAdvertisersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAdvertAdvertisersResponse,
    GetAdvertAdvertisersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/advert/advertisers", method: "get", ...variables, signal });

/**
 * Get existing advertisers.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getAdvertAdvertisersQuery(
  variables: GetAdvertAdvertisersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAdvertAdvertisersResponse>;
};

export function getAdvertAdvertisersQuery(
  variables: GetAdvertAdvertisersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAdvertAdvertisersResponse>)
    | reactQuery.SkipToken;
};

export function getAdvertAdvertisersQuery(
  variables: GetAdvertAdvertisersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/advert/advertisers",
      operationId: "getAdvertAdvertisers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAdvertAdvertisers(variables, signal),
  };
}

/**
 * Get existing advertisers.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetAdvertAdvertisers = <
  TData = GetAdvertAdvertisersResponse,
>(
  variables: GetAdvertAdvertisersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertAdvertisersResponse,
      GetAdvertAdvertisersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAdvertAdvertisersResponse,
    GetAdvertAdvertisersError,
    TData
  >({
    ...getAdvertAdvertisersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get existing advertisers.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdvertisers = <TData = GetAdvertAdvertisersResponse,>(
  variables: GetAdvertAdvertisersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertAdvertisersResponse,
      GetAdvertAdvertisersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAdvertAdvertisersResponse,
    GetAdvertAdvertisersError,
    TData
  >({
    ...getAdvertAdvertisersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAdvertAdvertisersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAdvertAdvertisersVariables = {
  body: Schemas.AdvertiserBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new advertiser.
 *
 * Each advertiser is associated with a `manager_group`. Users belonging to this group are able to manage the adverts related to the advertiser.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostAdvertAdvertisers = (
  variables: PostAdvertAdvertisersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AdvertiserComplete,
    PostAdvertAdvertisersError,
    Schemas.AdvertiserBase,
    {},
    {},
    {}
  >({ url: "/advert/advertisers", method: "post", ...variables, signal });

/**
 * Create a new advertiser.
 *
 * Each advertiser is associated with a `manager_group`. Users belonging to this group are able to manage the adverts related to the advertiser.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostAdvertAdvertisers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AdvertiserComplete,
      PostAdvertAdvertisersError,
      PostAdvertAdvertisersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AdvertiserComplete,
    PostAdvertAdvertisersError,
    PostAdvertAdvertisersVariables
  >({
    mutationFn: (variables: PostAdvertAdvertisersVariables) =>
      fetchPostAdvertAdvertisers(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteAdvertAdvertisersAdvertiserIdPathParams = {
  advertiserId: string;
};

export type DeleteAdvertAdvertisersAdvertiserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAdvertAdvertisersAdvertiserIdVariables = {
  pathParams: DeleteAdvertAdvertisersAdvertiserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an advertiser. All adverts associated with the advertiser will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteAdvertAdvertisersAdvertiserId = (
  variables: DeleteAdvertAdvertisersAdvertiserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAdvertAdvertisersAdvertiserIdError,
    undefined,
    {},
    {},
    DeleteAdvertAdvertisersAdvertiserIdPathParams
  >({
    url: "/advert/advertisers/{advertiserId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an advertiser. All adverts associated with the advertiser will also be deleted from the database.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteAdvertAdvertisersAdvertiserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAdvertAdvertisersAdvertiserIdError,
      DeleteAdvertAdvertisersAdvertiserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAdvertAdvertisersAdvertiserIdError,
    DeleteAdvertAdvertisersAdvertiserIdVariables
  >({
    mutationFn: (variables: DeleteAdvertAdvertisersAdvertiserIdVariables) =>
      fetchDeleteAdvertAdvertisersAdvertiserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchAdvertAdvertisersAdvertiserIdPathParams = {
  advertiserId: string;
};

export type PatchAdvertAdvertisersAdvertiserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAdvertAdvertisersAdvertiserIdVariables = {
  body?: Schemas.AdvertiserUpdate;
  pathParams: PatchAdvertAdvertisersAdvertiserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update an advertiser
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchAdvertAdvertisersAdvertiserId = (
  variables: PatchAdvertAdvertisersAdvertiserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAdvertAdvertisersAdvertiserIdError,
    Schemas.AdvertiserUpdate,
    {},
    {},
    PatchAdvertAdvertisersAdvertiserIdPathParams
  >({
    url: "/advert/advertisers/{advertiserId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update an advertiser
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchAdvertAdvertisersAdvertiserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAdvertAdvertisersAdvertiserIdError,
      PatchAdvertAdvertisersAdvertiserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAdvertAdvertisersAdvertiserIdError,
    PatchAdvertAdvertisersAdvertiserIdVariables
  >({
    mutationFn: (variables: PatchAdvertAdvertisersAdvertiserIdVariables) =>
      fetchPatchAdvertAdvertisersAdvertiserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetAdvertMeAdvertisersError = Fetcher.ErrorWrapper<undefined>;

export type GetAdvertMeAdvertisersResponse = Schemas.AdvertiserComplete[];

export type GetAdvertMeAdvertisersVariables = HyperionContext["fetcherOptions"];

/**
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertMeAdvertisers = (
  variables: GetAdvertMeAdvertisersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAdvertMeAdvertisersResponse,
    GetAdvertMeAdvertisersError,
    undefined,
    {},
    {},
    {}
  >({ url: "/advert/me/advertisers", method: "get", ...variables, signal });

/**
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getAdvertMeAdvertisersQuery(
  variables: GetAdvertMeAdvertisersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAdvertMeAdvertisersResponse>;
};

export function getAdvertMeAdvertisersQuery(
  variables: GetAdvertMeAdvertisersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAdvertMeAdvertisersResponse>)
    | reactQuery.SkipToken;
};

export function getAdvertMeAdvertisersQuery(
  variables: GetAdvertMeAdvertisersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/advert/me/advertisers",
      operationId: "getAdvertMeAdvertisers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAdvertMeAdvertisers(variables, signal),
  };
}

/**
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetAdvertMeAdvertisers = <
  TData = GetAdvertMeAdvertisersResponse,
>(
  variables: GetAdvertMeAdvertisersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertMeAdvertisersResponse,
      GetAdvertMeAdvertisersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAdvertMeAdvertisersResponse,
    GetAdvertMeAdvertisersError,
    TData
  >({
    ...getAdvertMeAdvertisersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all advertisers the current user can manage.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertMeAdvertisers = <
  TData = GetAdvertMeAdvertisersResponse,
>(
  variables: GetAdvertMeAdvertisersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertMeAdvertisersResponse,
      GetAdvertMeAdvertisersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAdvertMeAdvertisersResponse,
    GetAdvertMeAdvertisersError,
    TData
  >({
    ...getAdvertMeAdvertisersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetAdvertAdvertsQueryParams = {
  advertisers?: string[];
};

export type GetAdvertAdvertsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAdvertAdvertsResponse = Schemas.AdvertReturnComplete[];

export type GetAdvertAdvertsVariables = {
  queryParams?: GetAdvertAdvertsQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdverts = (
  variables: GetAdvertAdvertsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetAdvertAdvertsResponse,
    GetAdvertAdvertsError,
    undefined,
    {},
    GetAdvertAdvertsQueryParams,
    {}
  >({ url: "/advert/adverts", method: "get", ...variables, signal });

/**
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getAdvertAdvertsQuery(variables: GetAdvertAdvertsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetAdvertAdvertsResponse>;
};

export function getAdvertAdvertsQuery(
  variables: GetAdvertAdvertsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetAdvertAdvertsResponse>)
    | reactQuery.SkipToken;
};

export function getAdvertAdvertsQuery(
  variables: GetAdvertAdvertsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/advert/adverts",
      operationId: "getAdvertAdverts",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAdvertAdverts(variables, signal),
  };
}

/**
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetAdvertAdverts = <TData = GetAdvertAdvertsResponse,>(
  variables: GetAdvertAdvertsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertAdvertsResponse,
      GetAdvertAdvertsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetAdvertAdvertsResponse,
    GetAdvertAdvertsError,
    TData
  >({
    ...getAdvertAdvertsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get existing adverts. If advertisers optional parameter is used, search adverts by advertisers
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdverts = <TData = GetAdvertAdvertsResponse,>(
  variables: GetAdvertAdvertsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetAdvertAdvertsResponse,
      GetAdvertAdvertsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetAdvertAdvertsResponse,
    GetAdvertAdvertsError,
    TData
  >({
    ...getAdvertAdvertsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAdvertAdvertsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAdvertAdvertsVariables = {
  body: Schemas.AdvertBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const fetchPostAdvertAdverts = (
  variables: PostAdvertAdvertsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AdvertReturnComplete,
    PostAdvertAdvertsError,
    Schemas.AdvertBase,
    {},
    {},
    {}
  >({ url: "/advert/adverts", method: "post", ...variables, signal });

/**
 * Create a new advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const usePostAdvertAdverts = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AdvertReturnComplete,
      PostAdvertAdvertsError,
      PostAdvertAdvertsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AdvertReturnComplete,
    PostAdvertAdvertsError,
    PostAdvertAdvertsVariables
  >({
    mutationFn: (variables: PostAdvertAdvertsVariables) =>
      fetchPostAdvertAdverts(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAdvertAdvertsAdvertIdPathParams = {
  advertId: string;
};

export type GetAdvertAdvertsAdvertIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAdvertAdvertsAdvertIdVariables = {
  pathParams: GetAdvertAdvertsAdvertIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdvertsAdvertId = (
  variables: GetAdvertAdvertsAdvertIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AdvertReturnComplete,
    GetAdvertAdvertsAdvertIdError,
    undefined,
    {},
    {},
    GetAdvertAdvertsAdvertIdPathParams
  >({ url: "/advert/adverts/{advertId}", method: "get", ...variables, signal });

/**
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getAdvertAdvertsAdvertIdQuery(
  variables: GetAdvertAdvertsAdvertIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AdvertReturnComplete>;
};

export function getAdvertAdvertsAdvertIdQuery(
  variables: GetAdvertAdvertsAdvertIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AdvertReturnComplete>)
    | reactQuery.SkipToken;
};

export function getAdvertAdvertsAdvertIdQuery(
  variables: GetAdvertAdvertsAdvertIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/advert/adverts/{advertId}",
      operationId: "getAdvertAdvertsAdvertId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAdvertAdvertsAdvertId(variables, signal),
  };
}

/**
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetAdvertAdvertsAdvertId = <
  TData = Schemas.AdvertReturnComplete,
>(
  variables: GetAdvertAdvertsAdvertIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AdvertReturnComplete,
      GetAdvertAdvertsAdvertIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.AdvertReturnComplete,
    GetAdvertAdvertsAdvertIdError,
    TData
  >({
    ...getAdvertAdvertsAdvertIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdvertsAdvertId = <
  TData = Schemas.AdvertReturnComplete,
>(
  variables: GetAdvertAdvertsAdvertIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AdvertReturnComplete,
      GetAdvertAdvertsAdvertIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.AdvertReturnComplete,
    GetAdvertAdvertsAdvertIdError,
    TData
  >({
    ...getAdvertAdvertsAdvertIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchAdvertAdvertsAdvertIdPathParams = {
  advertId: string;
};

export type PatchAdvertAdvertsAdvertIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchAdvertAdvertsAdvertIdVariables = {
  body?: Schemas.AdvertUpdate;
  pathParams: PatchAdvertAdvertsAdvertIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit an advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const fetchPatchAdvertAdvertsAdvertId = (
  variables: PatchAdvertAdvertsAdvertIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchAdvertAdvertsAdvertIdError,
    Schemas.AdvertUpdate,
    {},
    {},
    PatchAdvertAdvertsAdvertIdPathParams
  >({
    url: "/advert/adverts/{advertId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit an advert
 *
 * **The user must be a member of the advertiser group_manager to use this endpoint**
 */
export const usePatchAdvertAdvertsAdvertId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchAdvertAdvertsAdvertIdError,
      PatchAdvertAdvertsAdvertIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchAdvertAdvertsAdvertIdError,
    PatchAdvertAdvertsAdvertIdVariables
  >({
    mutationFn: (variables: PatchAdvertAdvertsAdvertIdVariables) =>
      fetchPatchAdvertAdvertsAdvertId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteAdvertAdvertsAdvertIdPathParams = {
  advertId: string;
};

export type DeleteAdvertAdvertsAdvertIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteAdvertAdvertsAdvertIdVariables = {
  pathParams: DeleteAdvertAdvertsAdvertIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an advert
 *
 * **The user must be admin or a member of the advertiser group_manager to use this endpoint**
 */
export const fetchDeleteAdvertAdvertsAdvertId = (
  variables: DeleteAdvertAdvertsAdvertIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteAdvertAdvertsAdvertIdError,
    undefined,
    {},
    {},
    DeleteAdvertAdvertsAdvertIdPathParams
  >({
    url: "/advert/adverts/{advertId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an advert
 *
 * **The user must be admin or a member of the advertiser group_manager to use this endpoint**
 */
export const useDeleteAdvertAdvertsAdvertId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteAdvertAdvertsAdvertIdError,
      DeleteAdvertAdvertsAdvertIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteAdvertAdvertsAdvertIdError,
    DeleteAdvertAdvertsAdvertIdVariables
  >({
    mutationFn: (variables: DeleteAdvertAdvertsAdvertIdVariables) =>
      fetchDeleteAdvertAdvertsAdvertId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAdvertAdvertsAdvertIdPicturePathParams = {
  advertId: string;
};

export type GetAdvertAdvertsAdvertIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAdvertAdvertsAdvertIdPictureVariables = {
  pathParams: GetAdvertAdvertsAdvertIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetAdvertAdvertsAdvertIdPicture = (
  variables: GetAdvertAdvertsAdvertIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetAdvertAdvertsAdvertIdPictureError,
    undefined,
    {},
    {},
    GetAdvertAdvertsAdvertIdPicturePathParams
  >({
    url: "/advert/adverts/{advertId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getAdvertAdvertsAdvertIdPictureQuery(
  variables: GetAdvertAdvertsAdvertIdPictureVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getAdvertAdvertsAdvertIdPictureQuery(
  variables: GetAdvertAdvertsAdvertIdPictureVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getAdvertAdvertsAdvertIdPictureQuery(
  variables: GetAdvertAdvertsAdvertIdPictureVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/advert/adverts/{advertId}/picture",
      operationId: "getAdvertAdvertsAdvertIdPicture",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAdvertAdvertsAdvertIdPicture(variables, signal),
  };
}

/**
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetAdvertAdvertsAdvertIdPicture = <TData = undefined,>(
  variables: GetAdvertAdvertsAdvertIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetAdvertAdvertsAdvertIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetAdvertAdvertsAdvertIdPictureError,
    TData
  >({
    ...getAdvertAdvertsAdvertIdPictureQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the image of an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetAdvertAdvertsAdvertIdPicture = <TData = undefined,>(
  variables: GetAdvertAdvertsAdvertIdPictureVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetAdvertAdvertsAdvertIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetAdvertAdvertsAdvertIdPictureError,
    TData
  >({
    ...getAdvertAdvertsAdvertIdPictureQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAdvertAdvertsAdvertIdPicturePathParams = {
  advertId: string;
};

export type PostAdvertAdvertsAdvertIdPictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAdvertAdvertsAdvertIdPictureVariables = {
  body: Schemas.BodyCreateAdvertImageAdvertAdvertsAdvertIdPicturePost;
  pathParams: PostAdvertAdvertsAdvertIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Add an image to an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostAdvertAdvertsAdvertIdPicture = (
  variables: PostAdvertAdvertsAdvertIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostAdvertAdvertsAdvertIdPictureError,
    Schemas.BodyCreateAdvertImageAdvertAdvertsAdvertIdPicturePost,
    {},
    {},
    PostAdvertAdvertsAdvertIdPicturePathParams
  >({
    url: "/advert/adverts/{advertId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add an image to an advert
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostAdvertAdvertsAdvertIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostAdvertAdvertsAdvertIdPictureError,
      PostAdvertAdvertsAdvertIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostAdvertAdvertsAdvertIdPictureError,
    PostAdvertAdvertsAdvertIdPictureVariables
  >({
    mutationFn: (variables: PostAdvertAdvertsAdvertIdPictureVariables) =>
      fetchPostAdvertAdvertsAdvertIdPicture(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetPhonebookAssociationsError = Fetcher.ErrorWrapper<undefined>;

export type GetPhonebookAssociationsResponse = Schemas.AssociationComplete[];

export type GetPhonebookAssociationsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all associations from database as a list of AssociationComplete schemas
 */
export const fetchGetPhonebookAssociations = (
  variables: GetPhonebookAssociationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetPhonebookAssociationsResponse,
    GetPhonebookAssociationsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/phonebook/associations/", method: "get", ...variables, signal });

/**
 * Return all associations from database as a list of AssociationComplete schemas
 */
export function getPhonebookAssociationsQuery(
  variables: GetPhonebookAssociationsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetPhonebookAssociationsResponse>;
};

export function getPhonebookAssociationsQuery(
  variables: GetPhonebookAssociationsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetPhonebookAssociationsResponse>)
    | reactQuery.SkipToken;
};

export function getPhonebookAssociationsQuery(
  variables: GetPhonebookAssociationsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/associations/",
      operationId: "getPhonebookAssociations",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookAssociations(variables, signal),
  };
}

/**
 * Return all associations from database as a list of AssociationComplete schemas
 */
export const useSuspenseGetPhonebookAssociations = <
  TData = GetPhonebookAssociationsResponse,
>(
  variables: GetPhonebookAssociationsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsResponse,
      GetPhonebookAssociationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetPhonebookAssociationsResponse,
    GetPhonebookAssociationsError,
    TData
  >({
    ...getPhonebookAssociationsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all associations from database as a list of AssociationComplete schemas
 */
export const useGetPhonebookAssociations = <
  TData = GetPhonebookAssociationsResponse,
>(
  variables: GetPhonebookAssociationsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsResponse,
      GetPhonebookAssociationsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetPhonebookAssociationsResponse,
    GetPhonebookAssociationsError,
    TData
  >({
    ...getPhonebookAssociationsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostPhonebookAssociationsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhonebookAssociationsVariables = {
  body: Schemas.AssociationBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new Association by giving an AssociationBase scheme
 *
 * **This endpoint is only usable by CAA, BDE**
 */
export const fetchPostPhonebookAssociations = (
  variables: PostPhonebookAssociationsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AssociationComplete,
    PostPhonebookAssociationsError,
    Schemas.AssociationBase,
    {},
    {},
    {}
  >({ url: "/phonebook/associations/", method: "post", ...variables, signal });

/**
 * Create a new Association by giving an AssociationBase scheme
 *
 * **This endpoint is only usable by CAA, BDE**
 */
export const usePostPhonebookAssociations = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AssociationComplete,
      PostPhonebookAssociationsError,
      PostPhonebookAssociationsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AssociationComplete,
    PostPhonebookAssociationsError,
    PostPhonebookAssociationsVariables
  >({
    mutationFn: (variables: PostPhonebookAssociationsVariables) =>
      fetchPostPhonebookAssociations(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetPhonebookRoletagsError = Fetcher.ErrorWrapper<undefined>;

export type GetPhonebookRoletagsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all available role tags from RoleTags enum.
 */
export const fetchGetPhonebookRoletags = (
  variables: GetPhonebookRoletagsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RoleTagsReturn,
    GetPhonebookRoletagsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/phonebook/roletags", method: "get", ...variables, signal });

/**
 * Return all available role tags from RoleTags enum.
 */
export function getPhonebookRoletagsQuery(
  variables: GetPhonebookRoletagsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RoleTagsReturn>;
};

export function getPhonebookRoletagsQuery(
  variables: GetPhonebookRoletagsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RoleTagsReturn>)
    | reactQuery.SkipToken;
};

export function getPhonebookRoletagsQuery(
  variables: GetPhonebookRoletagsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/roletags",
      operationId: "getPhonebookRoletags",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookRoletags(variables, signal),
  };
}

/**
 * Return all available role tags from RoleTags enum.
 */
export const useSuspenseGetPhonebookRoletags = <
  TData = Schemas.RoleTagsReturn,
>(
  variables: GetPhonebookRoletagsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RoleTagsReturn,
      GetPhonebookRoletagsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RoleTagsReturn,
    GetPhonebookRoletagsError,
    TData
  >({
    ...getPhonebookRoletagsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all available role tags from RoleTags enum.
 */
export const useGetPhonebookRoletags = <TData = Schemas.RoleTagsReturn,>(
  variables: GetPhonebookRoletagsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RoleTagsReturn,
      GetPhonebookRoletagsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RoleTagsReturn,
    GetPhonebookRoletagsError,
    TData
  >({
    ...getPhonebookRoletagsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetPhonebookAssociationsKindsError =
  Fetcher.ErrorWrapper<undefined>;

export type GetPhonebookAssociationsKindsVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return all available kinds of from Kinds enum.
 */
export const fetchGetPhonebookAssociationsKinds = (
  variables: GetPhonebookAssociationsKindsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.KindsReturn,
    GetPhonebookAssociationsKindsError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/phonebook/associations/kinds",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all available kinds of from Kinds enum.
 */
export function getPhonebookAssociationsKindsQuery(
  variables: GetPhonebookAssociationsKindsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.KindsReturn>;
};

export function getPhonebookAssociationsKindsQuery(
  variables: GetPhonebookAssociationsKindsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.KindsReturn>)
    | reactQuery.SkipToken;
};

export function getPhonebookAssociationsKindsQuery(
  variables: GetPhonebookAssociationsKindsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/associations/kinds",
      operationId: "getPhonebookAssociationsKinds",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookAssociationsKinds(variables, signal),
  };
}

/**
 * Return all available kinds of from Kinds enum.
 */
export const useSuspenseGetPhonebookAssociationsKinds = <
  TData = Schemas.KindsReturn,
>(
  variables: GetPhonebookAssociationsKindsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.KindsReturn,
      GetPhonebookAssociationsKindsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.KindsReturn,
    GetPhonebookAssociationsKindsError,
    TData
  >({
    ...getPhonebookAssociationsKindsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all available kinds of from Kinds enum.
 */
export const useGetPhonebookAssociationsKinds = <TData = Schemas.KindsReturn,>(
  variables: GetPhonebookAssociationsKindsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.KindsReturn,
      GetPhonebookAssociationsKindsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.KindsReturn,
    GetPhonebookAssociationsKindsError,
    TData
  >({
    ...getPhonebookAssociationsKindsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchPhonebookAssociationsAssociationIdPathParams = {
  associationId: string;
};

export type PatchPhonebookAssociationsAssociationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchPhonebookAssociationsAssociationIdVariables = {
  body?: Schemas.AssociationEdit;
  pathParams: PatchPhonebookAssociationsAssociationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update an Association
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchPatchPhonebookAssociationsAssociationId = (
  variables: PatchPhonebookAssociationsAssociationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhonebookAssociationsAssociationIdError,
    Schemas.AssociationEdit,
    {},
    {},
    PatchPhonebookAssociationsAssociationIdPathParams
  >({
    url: "/phonebook/associations/{associationId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update an Association
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const usePatchPhonebookAssociationsAssociationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhonebookAssociationsAssociationIdError,
      PatchPhonebookAssociationsAssociationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhonebookAssociationsAssociationIdError,
    PatchPhonebookAssociationsAssociationIdVariables
  >({
    mutationFn: (variables: PatchPhonebookAssociationsAssociationIdVariables) =>
      fetchPatchPhonebookAssociationsAssociationId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeletePhonebookAssociationsAssociationIdPathParams = {
  associationId: string;
};

export type DeletePhonebookAssociationsAssociationIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeletePhonebookAssociationsAssociationIdVariables = {
  pathParams: DeletePhonebookAssociationsAssociationIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete an Association
 *
 * [!] Memberships linked to association_id will be deleted too
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const fetchDeletePhonebookAssociationsAssociationId = (
  variables: DeletePhonebookAssociationsAssociationIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeletePhonebookAssociationsAssociationIdError,
    undefined,
    {},
    {},
    DeletePhonebookAssociationsAssociationIdPathParams
  >({
    url: "/phonebook/associations/{associationId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete an Association
 *
 * [!] Memberships linked to association_id will be deleted too
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const useDeletePhonebookAssociationsAssociationId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeletePhonebookAssociationsAssociationIdError,
      DeletePhonebookAssociationsAssociationIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeletePhonebookAssociationsAssociationIdError,
    DeletePhonebookAssociationsAssociationIdVariables
  >({
    mutationFn: (
      variables: DeletePhonebookAssociationsAssociationIdVariables,
    ) =>
      fetchDeletePhonebookAssociationsAssociationId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchPhonebookAssociationsAssociationIdGroupsPathParams = {
  associationId: string;
};

export type PatchPhonebookAssociationsAssociationIdGroupsError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchPhonebookAssociationsAssociationIdGroupsVariables = {
  body?: Schemas.AssociationGroupsEdit;
  pathParams: PatchPhonebookAssociationsAssociationIdGroupsPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update the groups associated with an Association
 *
 * **This endpoint is only usable by Admins (not BDE and CAA)**
 */
export const fetchPatchPhonebookAssociationsAssociationIdGroups = (
  variables: PatchPhonebookAssociationsAssociationIdGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhonebookAssociationsAssociationIdGroupsError,
    Schemas.AssociationGroupsEdit,
    {},
    {},
    PatchPhonebookAssociationsAssociationIdGroupsPathParams
  >({
    url: "/phonebook/associations/{associationId}/groups",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update the groups associated with an Association
 *
 * **This endpoint is only usable by Admins (not BDE and CAA)**
 */
export const usePatchPhonebookAssociationsAssociationIdGroups = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhonebookAssociationsAssociationIdGroupsError,
      PatchPhonebookAssociationsAssociationIdGroupsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhonebookAssociationsAssociationIdGroupsError,
    PatchPhonebookAssociationsAssociationIdGroupsVariables
  >({
    mutationFn: (
      variables: PatchPhonebookAssociationsAssociationIdGroupsVariables,
    ) =>
      fetchPatchPhonebookAssociationsAssociationIdGroups(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchPhonebookAssociationsAssociationIdDeactivatePathParams = {
  associationId: string;
};

export type PatchPhonebookAssociationsAssociationIdDeactivateError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchPhonebookAssociationsAssociationIdDeactivateVariables = {
  pathParams: PatchPhonebookAssociationsAssociationIdDeactivatePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Deactivate an Association
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const fetchPatchPhonebookAssociationsAssociationIdDeactivate = (
  variables: PatchPhonebookAssociationsAssociationIdDeactivateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhonebookAssociationsAssociationIdDeactivateError,
    undefined,
    {},
    {},
    PatchPhonebookAssociationsAssociationIdDeactivatePathParams
  >({
    url: "/phonebook/associations/{associationId}/deactivate",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Deactivate an Association
 *
 * **This endpoint is only usable by CAA and BDE**
 */
export const usePatchPhonebookAssociationsAssociationIdDeactivate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhonebookAssociationsAssociationIdDeactivateError,
      PatchPhonebookAssociationsAssociationIdDeactivateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhonebookAssociationsAssociationIdDeactivateError,
    PatchPhonebookAssociationsAssociationIdDeactivateVariables
  >({
    mutationFn: (
      variables: PatchPhonebookAssociationsAssociationIdDeactivateVariables,
    ) =>
      fetchPatchPhonebookAssociationsAssociationIdDeactivate(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetPhonebookAssociationsAssociationIdMembersPathParams = {
  associationId: string;
};

export type GetPhonebookAssociationsAssociationIdMembersError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPhonebookAssociationsAssociationIdMembersResponse =
  Schemas.MemberComplete[];

export type GetPhonebookAssociationsAssociationIdMembersVariables = {
  pathParams: GetPhonebookAssociationsAssociationIdMembersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the list of MemberComplete of an Association.
 */
export const fetchGetPhonebookAssociationsAssociationIdMembers = (
  variables: GetPhonebookAssociationsAssociationIdMembersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetPhonebookAssociationsAssociationIdMembersResponse,
    GetPhonebookAssociationsAssociationIdMembersError,
    undefined,
    {},
    {},
    GetPhonebookAssociationsAssociationIdMembersPathParams
  >({
    url: "/phonebook/associations/{associationId}/members/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the list of MemberComplete of an Association.
 */
export function getPhonebookAssociationsAssociationIdMembersQuery(
  variables: GetPhonebookAssociationsAssociationIdMembersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetPhonebookAssociationsAssociationIdMembersResponse>;
};

export function getPhonebookAssociationsAssociationIdMembersQuery(
  variables:
    | GetPhonebookAssociationsAssociationIdMembersVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetPhonebookAssociationsAssociationIdMembersResponse>)
    | reactQuery.SkipToken;
};

export function getPhonebookAssociationsAssociationIdMembersQuery(
  variables:
    | GetPhonebookAssociationsAssociationIdMembersVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/associations/{associationId}/members/",
      operationId: "getPhonebookAssociationsAssociationIdMembers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookAssociationsAssociationIdMembers(
              variables,
              signal,
            ),
  };
}

/**
 * Return the list of MemberComplete of an Association.
 */
export const useSuspenseGetPhonebookAssociationsAssociationIdMembers = <
  TData = GetPhonebookAssociationsAssociationIdMembersResponse,
>(
  variables: GetPhonebookAssociationsAssociationIdMembersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsAssociationIdMembersResponse,
      GetPhonebookAssociationsAssociationIdMembersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetPhonebookAssociationsAssociationIdMembersResponse,
    GetPhonebookAssociationsAssociationIdMembersError,
    TData
  >({
    ...getPhonebookAssociationsAssociationIdMembersQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the list of MemberComplete of an Association.
 */
export const useGetPhonebookAssociationsAssociationIdMembers = <
  TData = GetPhonebookAssociationsAssociationIdMembersResponse,
>(
  variables:
    | GetPhonebookAssociationsAssociationIdMembersVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsAssociationIdMembersResponse,
      GetPhonebookAssociationsAssociationIdMembersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetPhonebookAssociationsAssociationIdMembersResponse,
    GetPhonebookAssociationsAssociationIdMembersError,
    TData
  >({
    ...getPhonebookAssociationsAssociationIdMembersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetPhonebookAssociationsAssociationIdMembersMandateYearPathParams =
  {
    associationId: string;
    mandateYear: number;
  };

export type GetPhonebookAssociationsAssociationIdMembersMandateYearError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPhonebookAssociationsAssociationIdMembersMandateYearResponse =
  Schemas.MemberComplete[];

export type GetPhonebookAssociationsAssociationIdMembersMandateYearVariables = {
  pathParams: GetPhonebookAssociationsAssociationIdMembersMandateYearPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export const fetchGetPhonebookAssociationsAssociationIdMembersMandateYear = (
  variables: GetPhonebookAssociationsAssociationIdMembersMandateYearVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
    GetPhonebookAssociationsAssociationIdMembersMandateYearError,
    undefined,
    {},
    {},
    GetPhonebookAssociationsAssociationIdMembersMandateYearPathParams
  >({
    url: "/phonebook/associations/{associationId}/members/{mandateYear}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export function getPhonebookAssociationsAssociationIdMembersMandateYearQuery(
  variables: GetPhonebookAssociationsAssociationIdMembersMandateYearVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetPhonebookAssociationsAssociationIdMembersMandateYearResponse>;
};

export function getPhonebookAssociationsAssociationIdMembersMandateYearQuery(
  variables:
    | GetPhonebookAssociationsAssociationIdMembersMandateYearVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetPhonebookAssociationsAssociationIdMembersMandateYearResponse>)
    | reactQuery.SkipToken;
};

export function getPhonebookAssociationsAssociationIdMembersMandateYearQuery(
  variables:
    | GetPhonebookAssociationsAssociationIdMembersMandateYearVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/associations/{associationId}/members/{mandateYear}",
      operationId: "getPhonebookAssociationsAssociationIdMembersMandateYear",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookAssociationsAssociationIdMembersMandateYear(
              variables,
              signal,
            ),
  };
}

/**
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export const useSuspenseGetPhonebookAssociationsAssociationIdMembersMandateYear =
  <TData = GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,>(
    variables: GetPhonebookAssociationsAssociationIdMembersMandateYearVariables,
    options?: Omit<
      reactQuery.UseQueryOptions<
        GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
        GetPhonebookAssociationsAssociationIdMembersMandateYearError,
        TData
      >,
      "queryKey" | "queryFn" | "initialData"
    >,
  ) => {
    const { queryOptions, fetcherOptions } = useHyperionContext(options);
    return reactQuery.useSuspenseQuery<
      GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
      GetPhonebookAssociationsAssociationIdMembersMandateYearError,
      TData
    >({
      ...getPhonebookAssociationsAssociationIdMembersMandateYearQuery(
        deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    });
  };

/**
 * Return the list of MemberComplete of an Association with given mandate_year.
 */
export const useGetPhonebookAssociationsAssociationIdMembersMandateYear = <
  TData = GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
>(
  variables:
    | GetPhonebookAssociationsAssociationIdMembersMandateYearVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
      GetPhonebookAssociationsAssociationIdMembersMandateYearError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetPhonebookAssociationsAssociationIdMembersMandateYearResponse,
    GetPhonebookAssociationsAssociationIdMembersMandateYearError,
    TData
  >({
    ...getPhonebookAssociationsAssociationIdMembersMandateYearQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetPhonebookMemberUserIdPathParams = {
  userId: string;
};

export type GetPhonebookMemberUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetPhonebookMemberUserIdVariables = {
  pathParams: GetPhonebookMemberUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return MemberComplete for given user_id.
 */
export const fetchGetPhonebookMemberUserId = (
  variables: GetPhonebookMemberUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.MemberComplete,
    GetPhonebookMemberUserIdError,
    undefined,
    {},
    {},
    GetPhonebookMemberUserIdPathParams
  >({ url: "/phonebook/member/{userId}", method: "get", ...variables, signal });

/**
 * Return MemberComplete for given user_id.
 */
export function getPhonebookMemberUserIdQuery(
  variables: GetPhonebookMemberUserIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.MemberComplete>;
};

export function getPhonebookMemberUserIdQuery(
  variables: GetPhonebookMemberUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.MemberComplete>)
    | reactQuery.SkipToken;
};

export function getPhonebookMemberUserIdQuery(
  variables: GetPhonebookMemberUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/member/{userId}",
      operationId: "getPhonebookMemberUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookMemberUserId(variables, signal),
  };
}

/**
 * Return MemberComplete for given user_id.
 */
export const useSuspenseGetPhonebookMemberUserId = <
  TData = Schemas.MemberComplete,
>(
  variables: GetPhonebookMemberUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MemberComplete,
      GetPhonebookMemberUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.MemberComplete,
    GetPhonebookMemberUserIdError,
    TData
  >({
    ...getPhonebookMemberUserIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return MemberComplete for given user_id.
 */
export const useGetPhonebookMemberUserId = <TData = Schemas.MemberComplete,>(
  variables: GetPhonebookMemberUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.MemberComplete,
      GetPhonebookMemberUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.MemberComplete,
    GetPhonebookMemberUserIdError,
    TData
  >({
    ...getPhonebookMemberUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostPhonebookAssociationsMembershipsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostPhonebookAssociationsMembershipsVariables = {
  body: Schemas.AppModulesPhonebookSchemasPhonebookMembershipBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new Membership.
 * 'role_tags' are used to indicate if the members has a main role in the association (president, secretary ...) and 'role_name' is the display name for this membership
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchPostPhonebookAssociationsMemberships = (
  variables: PostPhonebookAssociationsMembershipsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.MembershipComplete,
    PostPhonebookAssociationsMembershipsError,
    Schemas.AppModulesPhonebookSchemasPhonebookMembershipBase,
    {},
    {},
    {}
  >({
    url: "/phonebook/associations/memberships",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new Membership.
 * 'role_tags' are used to indicate if the members has a main role in the association (president, secretary ...) and 'role_name' is the display name for this membership
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const usePostPhonebookAssociationsMemberships = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MembershipComplete,
      PostPhonebookAssociationsMembershipsError,
      PostPhonebookAssociationsMembershipsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.MembershipComplete,
    PostPhonebookAssociationsMembershipsError,
    PostPhonebookAssociationsMembershipsVariables
  >({
    mutationFn: (variables: PostPhonebookAssociationsMembershipsVariables) =>
      fetchPostPhonebookAssociationsMemberships(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchPhonebookAssociationsMembershipsMembershipIdPathParams = {
  membershipId: string;
};

export type PatchPhonebookAssociationsMembershipsMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchPhonebookAssociationsMembershipsMembershipIdVariables = {
  body?: Schemas.MembershipEdit;
  pathParams: PatchPhonebookAssociationsMembershipsMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a Membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchPatchPhonebookAssociationsMembershipsMembershipId = (
  variables: PatchPhonebookAssociationsMembershipsMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchPhonebookAssociationsMembershipsMembershipIdError,
    Schemas.MembershipEdit,
    {},
    {},
    PatchPhonebookAssociationsMembershipsMembershipIdPathParams
  >({
    url: "/phonebook/associations/memberships/{membershipId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a Membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const usePatchPhonebookAssociationsMembershipsMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchPhonebookAssociationsMembershipsMembershipIdError,
      PatchPhonebookAssociationsMembershipsMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchPhonebookAssociationsMembershipsMembershipIdError,
    PatchPhonebookAssociationsMembershipsMembershipIdVariables
  >({
    mutationFn: (
      variables: PatchPhonebookAssociationsMembershipsMembershipIdVariables,
    ) =>
      fetchPatchPhonebookAssociationsMembershipsMembershipId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeletePhonebookAssociationsMembershipsMembershipIdPathParams = {
  membershipId: string;
};

export type DeletePhonebookAssociationsMembershipsMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeletePhonebookAssociationsMembershipsMembershipIdVariables = {
  pathParams: DeletePhonebookAssociationsMembershipsMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const fetchDeletePhonebookAssociationsMembershipsMembershipId = (
  variables: DeletePhonebookAssociationsMembershipsMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeletePhonebookAssociationsMembershipsMembershipIdError,
    undefined,
    {},
    {},
    DeletePhonebookAssociationsMembershipsMembershipIdPathParams
  >({
    url: "/phonebook/associations/memberships/{membershipId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a membership.
 *
 * **This endpoint is only usable by CAA, BDE and association's president**
 */
export const useDeletePhonebookAssociationsMembershipsMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeletePhonebookAssociationsMembershipsMembershipIdError,
      DeletePhonebookAssociationsMembershipsMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeletePhonebookAssociationsMembershipsMembershipIdError,
    DeletePhonebookAssociationsMembershipsMembershipIdVariables
  >({
    mutationFn: (
      variables: DeletePhonebookAssociationsMembershipsMembershipIdVariables,
    ) =>
      fetchDeletePhonebookAssociationsMembershipsMembershipId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostPhonebookAssociationsAssociationIdPicturePathParams = {
  associationId: string;
};

export type PostPhonebookAssociationsAssociationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostPhonebookAssociationsAssociationIdPictureVariables = {
  body: Schemas.BodyCreateAssociationLogoPhonebookAssociationsAssociationIdPicturePost;
  pathParams: PostPhonebookAssociationsAssociationIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a logo for an Association.
 * **The user must be a member of the group CAA or BDE to use this endpoint**
 */
export const fetchPostPhonebookAssociationsAssociationIdPicture = (
  variables: PostPhonebookAssociationsAssociationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostPhonebookAssociationsAssociationIdPictureError,
    Schemas.BodyCreateAssociationLogoPhonebookAssociationsAssociationIdPicturePost,
    {},
    {},
    PostPhonebookAssociationsAssociationIdPicturePathParams
  >({
    url: "/phonebook/associations/{associationId}/picture",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a logo for an Association.
 * **The user must be a member of the group CAA or BDE to use this endpoint**
 */
export const usePostPhonebookAssociationsAssociationIdPicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostPhonebookAssociationsAssociationIdPictureError,
      PostPhonebookAssociationsAssociationIdPictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostPhonebookAssociationsAssociationIdPictureError,
    PostPhonebookAssociationsAssociationIdPictureVariables
  >({
    mutationFn: (
      variables: PostPhonebookAssociationsAssociationIdPictureVariables,
    ) =>
      fetchPostPhonebookAssociationsAssociationIdPicture(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetPhonebookAssociationsAssociationIdPicturePathParams = {
  associationId: string;
};

export type GetPhonebookAssociationsAssociationIdPictureError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetPhonebookAssociationsAssociationIdPictureVariables = {
  pathParams: GetPhonebookAssociationsAssociationIdPicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the logo of an Association.
 */
export const fetchGetPhonebookAssociationsAssociationIdPicture = (
  variables: GetPhonebookAssociationsAssociationIdPictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetPhonebookAssociationsAssociationIdPictureError,
    undefined,
    {},
    {},
    GetPhonebookAssociationsAssociationIdPicturePathParams
  >({
    url: "/phonebook/associations/{associationId}/picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the logo of an Association.
 */
export function getPhonebookAssociationsAssociationIdPictureQuery(
  variables: GetPhonebookAssociationsAssociationIdPictureVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getPhonebookAssociationsAssociationIdPictureQuery(
  variables:
    | GetPhonebookAssociationsAssociationIdPictureVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getPhonebookAssociationsAssociationIdPictureQuery(
  variables:
    | GetPhonebookAssociationsAssociationIdPictureVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/phonebook/associations/{associationId}/picture",
      operationId: "getPhonebookAssociationsAssociationIdPicture",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetPhonebookAssociationsAssociationIdPicture(
              variables,
              signal,
            ),
  };
}

/**
 * Get the logo of an Association.
 */
export const useSuspenseGetPhonebookAssociationsAssociationIdPicture = <
  TData = undefined,
>(
  variables: GetPhonebookAssociationsAssociationIdPictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetPhonebookAssociationsAssociationIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetPhonebookAssociationsAssociationIdPictureError,
    TData
  >({
    ...getPhonebookAssociationsAssociationIdPictureQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the logo of an Association.
 */
export const useGetPhonebookAssociationsAssociationIdPicture = <
  TData = undefined,
>(
  variables:
    | GetPhonebookAssociationsAssociationIdPictureVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetPhonebookAssociationsAssociationIdPictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetPhonebookAssociationsAssociationIdPictureError,
    TData
  >({
    ...getPhonebookAssociationsAssociationIdPictureQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetRaidParticipantsParticipantIdPathParams = {
  participantId: string;
};

export type GetRaidParticipantsParticipantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetRaidParticipantsParticipantIdVariables = {
  pathParams: GetRaidParticipantsParticipantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a participant by id
 */
export const fetchGetRaidParticipantsParticipantId = (
  variables: GetRaidParticipantsParticipantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidParticipant,
    GetRaidParticipantsParticipantIdError,
    undefined,
    {},
    {},
    GetRaidParticipantsParticipantIdPathParams
  >({
    url: "/raid/participants/{participantId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a participant by id
 */
export function getRaidParticipantsParticipantIdQuery(
  variables: GetRaidParticipantsParticipantIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RaidParticipant>;
};

export function getRaidParticipantsParticipantIdQuery(
  variables: GetRaidParticipantsParticipantIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaidParticipant>)
    | reactQuery.SkipToken;
};

export function getRaidParticipantsParticipantIdQuery(
  variables: GetRaidParticipantsParticipantIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/participants/{participantId}",
      operationId: "getRaidParticipantsParticipantId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRaidParticipantsParticipantId(variables, signal),
  };
}

/**
 * Get a participant by id
 */
export const useSuspenseGetRaidParticipantsParticipantId = <
  TData = Schemas.RaidParticipant,
>(
  variables: GetRaidParticipantsParticipantIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidParticipant,
      GetRaidParticipantsParticipantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaidParticipant,
    GetRaidParticipantsParticipantIdError,
    TData
  >({
    ...getRaidParticipantsParticipantIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a participant by id
 */
export const useGetRaidParticipantsParticipantId = <
  TData = Schemas.RaidParticipant,
>(
  variables: GetRaidParticipantsParticipantIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidParticipant,
      GetRaidParticipantsParticipantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RaidParticipant,
    GetRaidParticipantsParticipantIdError,
    TData
  >({
    ...getRaidParticipantsParticipantIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchRaidParticipantsParticipantIdPathParams = {
  participantId: string;
};

export type PatchRaidParticipantsParticipantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchRaidParticipantsParticipantIdVariables = {
  body?: Schemas.RaidParticipantUpdate;
  pathParams: PatchRaidParticipantsParticipantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a participant
 */
export const fetchPatchRaidParticipantsParticipantId = (
  variables: PatchRaidParticipantsParticipantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchRaidParticipantsParticipantIdError,
    Schemas.RaidParticipantUpdate,
    {},
    {},
    PatchRaidParticipantsParticipantIdPathParams
  >({
    url: "/raid/participants/{participantId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a participant
 */
export const usePatchRaidParticipantsParticipantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRaidParticipantsParticipantIdError,
      PatchRaidParticipantsParticipantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRaidParticipantsParticipantIdError,
    PatchRaidParticipantsParticipantIdVariables
  >({
    mutationFn: (variables: PatchRaidParticipantsParticipantIdVariables) =>
      fetchPatchRaidParticipantsParticipantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostRaidParticipantsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidParticipantsVariables = {
  body: Schemas.RaidParticipantBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a participant
 */
export const fetchPostRaidParticipants = (
  variables: PostRaidParticipantsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidParticipant,
    PostRaidParticipantsError,
    Schemas.RaidParticipantBase,
    {},
    {},
    {}
  >({ url: "/raid/participants", method: "post", ...variables, signal });

/**
 * Create a participant
 */
export const usePostRaidParticipants = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RaidParticipant,
      PostRaidParticipantsError,
      PostRaidParticipantsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RaidParticipant,
    PostRaidParticipantsError,
    PostRaidParticipantsVariables
  >({
    mutationFn: (variables: PostRaidParticipantsVariables) =>
      fetchPostRaidParticipants(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidTeamsError = Fetcher.ErrorWrapper<undefined>;

export type GetRaidTeamsResponse = Schemas.RaidTeamPreview[];

export type GetRaidTeamsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all teams
 */
export const fetchGetRaidTeams = (
  variables: GetRaidTeamsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetRaidTeamsResponse, GetRaidTeamsError, undefined, {}, {}, {}>(
    { url: "/raid/teams", method: "get", ...variables, signal },
  );

/**
 * Get all teams
 */
export function getRaidTeamsQuery(variables: GetRaidTeamsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetRaidTeamsResponse>;
};

export function getRaidTeamsQuery(
  variables: GetRaidTeamsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetRaidTeamsResponse>)
    | reactQuery.SkipToken;
};

export function getRaidTeamsQuery(
  variables: GetRaidTeamsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/teams",
      operationId: "getRaidTeams",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRaidTeams(variables, signal),
  };
}

/**
 * Get all teams
 */
export const useSuspenseGetRaidTeams = <TData = GetRaidTeamsResponse,>(
  variables: GetRaidTeamsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetRaidTeamsResponse, GetRaidTeamsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetRaidTeamsResponse,
    GetRaidTeamsError,
    TData
  >({
    ...getRaidTeamsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all teams
 */
export const useGetRaidTeams = <TData = GetRaidTeamsResponse,>(
  variables: GetRaidTeamsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetRaidTeamsResponse, GetRaidTeamsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetRaidTeamsResponse, GetRaidTeamsError, TData>({
    ...getRaidTeamsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostRaidTeamsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidTeamsVariables = {
  body: Schemas.RaidTeamBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a team
 */
export const fetchPostRaidTeams = (
  variables: PostRaidTeamsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidTeam,
    PostRaidTeamsError,
    Schemas.RaidTeamBase,
    {},
    {},
    {}
  >({ url: "/raid/teams", method: "post", ...variables, signal });

/**
 * Create a team
 */
export const usePostRaidTeams = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RaidTeam,
      PostRaidTeamsError,
      PostRaidTeamsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RaidTeam,
    PostRaidTeamsError,
    PostRaidTeamsVariables
  >({
    mutationFn: (variables: PostRaidTeamsVariables) =>
      fetchPostRaidTeams(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteRaidTeamsError = Fetcher.ErrorWrapper<undefined>;

export type DeleteRaidTeamsVariables = HyperionContext["fetcherOptions"];

/**
 * Delete all teams
 */
export const fetchDeleteRaidTeams = (
  variables: DeleteRaidTeamsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, DeleteRaidTeamsError, undefined, {}, {}, {}>({
    url: "/raid/teams",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete all teams
 */
export const useDeleteRaidTeams = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRaidTeamsError,
      DeleteRaidTeamsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRaidTeamsError,
    DeleteRaidTeamsVariables
  >({
    mutationFn: (variables: DeleteRaidTeamsVariables) =>
      fetchDeleteRaidTeams(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostRaidTeamsGeneratePdfError = Fetcher.ErrorWrapper<undefined>;

export type PostRaidTeamsGeneratePdfVariables =
  HyperionContext["fetcherOptions"];

/**
 * PDF are automatically generated when a team is created or updated.
 * This endpoint is used to regenerate all the PDFs.
 */
export const fetchPostRaidTeamsGeneratePdf = (
  variables: PostRaidTeamsGeneratePdfVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, PostRaidTeamsGeneratePdfError, undefined, {}, {}, {}>({
    url: "/raid/teams/generate-pdf",
    method: "post",
    ...variables,
    signal,
  });

/**
 * PDF are automatically generated when a team is created or updated.
 * This endpoint is used to regenerate all the PDFs.
 */
export const usePostRaidTeamsGeneratePdf = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostRaidTeamsGeneratePdfError,
      PostRaidTeamsGeneratePdfVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostRaidTeamsGeneratePdfError,
    PostRaidTeamsGeneratePdfVariables
  >({
    mutationFn: (variables: PostRaidTeamsGeneratePdfVariables) =>
      fetchPostRaidTeamsGeneratePdf(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidParticipantsParticipantIdTeamPathParams = {
  participantId: string;
};

export type GetRaidParticipantsParticipantIdTeamError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetRaidParticipantsParticipantIdTeamVariables = {
  pathParams: GetRaidParticipantsParticipantIdTeamPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a team by participant id
 */
export const fetchGetRaidParticipantsParticipantIdTeam = (
  variables: GetRaidParticipantsParticipantIdTeamVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidTeam,
    GetRaidParticipantsParticipantIdTeamError,
    undefined,
    {},
    {},
    GetRaidParticipantsParticipantIdTeamPathParams
  >({
    url: "/raid/participants/{participantId}/team",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get a team by participant id
 */
export function getRaidParticipantsParticipantIdTeamQuery(
  variables: GetRaidParticipantsParticipantIdTeamVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RaidTeam>;
};

export function getRaidParticipantsParticipantIdTeamQuery(
  variables:
    | GetRaidParticipantsParticipantIdTeamVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaidTeam>)
    | reactQuery.SkipToken;
};

export function getRaidParticipantsParticipantIdTeamQuery(
  variables:
    | GetRaidParticipantsParticipantIdTeamVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/participants/{participantId}/team",
      operationId: "getRaidParticipantsParticipantIdTeam",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRaidParticipantsParticipantIdTeam(variables, signal),
  };
}

/**
 * Get a team by participant id
 */
export const useSuspenseGetRaidParticipantsParticipantIdTeam = <
  TData = Schemas.RaidTeam,
>(
  variables: GetRaidParticipantsParticipantIdTeamVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidTeam,
      GetRaidParticipantsParticipantIdTeamError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaidTeam,
    GetRaidParticipantsParticipantIdTeamError,
    TData
  >({
    ...getRaidParticipantsParticipantIdTeamQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a team by participant id
 */
export const useGetRaidParticipantsParticipantIdTeam = <
  TData = Schemas.RaidTeam,
>(
  variables:
    | GetRaidParticipantsParticipantIdTeamVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidTeam,
      GetRaidParticipantsParticipantIdTeamError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RaidTeam,
    GetRaidParticipantsParticipantIdTeamError,
    TData
  >({
    ...getRaidParticipantsParticipantIdTeamQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetRaidTeamsTeamIdPathParams = {
  teamId: string;
};

export type GetRaidTeamsTeamIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetRaidTeamsTeamIdVariables = {
  pathParams: GetRaidTeamsTeamIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get a team by id
 */
export const fetchGetRaidTeamsTeamId = (
  variables: GetRaidTeamsTeamIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidTeam,
    GetRaidTeamsTeamIdError,
    undefined,
    {},
    {},
    GetRaidTeamsTeamIdPathParams
  >({ url: "/raid/teams/{teamId}", method: "get", ...variables, signal });

/**
 * Get a team by id
 */
export function getRaidTeamsTeamIdQuery(
  variables: GetRaidTeamsTeamIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RaidTeam>;
};

export function getRaidTeamsTeamIdQuery(
  variables: GetRaidTeamsTeamIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaidTeam>)
    | reactQuery.SkipToken;
};

export function getRaidTeamsTeamIdQuery(
  variables: GetRaidTeamsTeamIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/teams/{teamId}",
      operationId: "getRaidTeamsTeamId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRaidTeamsTeamId(variables, signal),
  };
}

/**
 * Get a team by id
 */
export const useSuspenseGetRaidTeamsTeamId = <TData = Schemas.RaidTeam,>(
  variables: GetRaidTeamsTeamIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidTeam,
      GetRaidTeamsTeamIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaidTeam,
    GetRaidTeamsTeamIdError,
    TData
  >({
    ...getRaidTeamsTeamIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get a team by id
 */
export const useGetRaidTeamsTeamId = <TData = Schemas.RaidTeam,>(
  variables: GetRaidTeamsTeamIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidTeam,
      GetRaidTeamsTeamIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.RaidTeam, GetRaidTeamsTeamIdError, TData>({
    ...getRaidTeamsTeamIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchRaidTeamsTeamIdPathParams = {
  teamId: string;
};

export type PatchRaidTeamsTeamIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchRaidTeamsTeamIdVariables = {
  body?: Schemas.RaidTeamUpdate;
  pathParams: PatchRaidTeamsTeamIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a team
 */
export const fetchPatchRaidTeamsTeamId = (
  variables: PatchRaidTeamsTeamIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchRaidTeamsTeamIdError,
    Schemas.RaidTeamUpdate,
    {},
    {},
    PatchRaidTeamsTeamIdPathParams
  >({ url: "/raid/teams/{teamId}", method: "patch", ...variables, signal });

/**
 * Update a team
 */
export const usePatchRaidTeamsTeamId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRaidTeamsTeamIdError,
      PatchRaidTeamsTeamIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRaidTeamsTeamIdError,
    PatchRaidTeamsTeamIdVariables
  >({
    mutationFn: (variables: PatchRaidTeamsTeamIdVariables) =>
      fetchPatchRaidTeamsTeamId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteRaidTeamsTeamIdPathParams = {
  teamId: string;
};

export type DeleteRaidTeamsTeamIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteRaidTeamsTeamIdVariables = {
  pathParams: DeleteRaidTeamsTeamIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a team
 */
export const fetchDeleteRaidTeamsTeamId = (
  variables: DeleteRaidTeamsTeamIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteRaidTeamsTeamIdError,
    undefined,
    {},
    {},
    DeleteRaidTeamsTeamIdPathParams
  >({ url: "/raid/teams/{teamId}", method: "delete", ...variables, signal });

/**
 * Delete a team
 */
export const useDeleteRaidTeamsTeamId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteRaidTeamsTeamIdError,
      DeleteRaidTeamsTeamIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteRaidTeamsTeamIdError,
    DeleteRaidTeamsTeamIdVariables
  >({
    mutationFn: (variables: DeleteRaidTeamsTeamIdVariables) =>
      fetchDeleteRaidTeamsTeamId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostRaidDocumentDocumentTypePathParams = {
  documentType: Schemas.DocumentType;
};

export type PostRaidDocumentDocumentTypeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidDocumentDocumentTypeVariables = {
  body: Schemas.BodyUploadDocumentRaidDocumentDocumentTypePost;
  pathParams: PostRaidDocumentDocumentTypePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a document
 */
export const fetchPostRaidDocumentDocumentType = (
  variables: PostRaidDocumentDocumentTypeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.DocumentCreation,
    PostRaidDocumentDocumentTypeError,
    Schemas.BodyUploadDocumentRaidDocumentDocumentTypePost,
    {},
    {},
    PostRaidDocumentDocumentTypePathParams
  >({
    url: "/raid/document/{documentType}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Upload a document
 */
export const usePostRaidDocumentDocumentType = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.DocumentCreation,
      PostRaidDocumentDocumentTypeError,
      PostRaidDocumentDocumentTypeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.DocumentCreation,
    PostRaidDocumentDocumentTypeError,
    PostRaidDocumentDocumentTypeVariables
  >({
    mutationFn: (variables: PostRaidDocumentDocumentTypeVariables) =>
      fetchPostRaidDocumentDocumentType(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidDocumentDocumentIdPathParams = {
  documentId: string;
};

export type GetRaidDocumentDocumentIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetRaidDocumentDocumentIdVariables = {
  pathParams: GetRaidDocumentDocumentIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Read a document
 */
export const fetchGetRaidDocumentDocumentId = (
  variables: GetRaidDocumentDocumentIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetRaidDocumentDocumentIdError,
    undefined,
    {},
    {},
    GetRaidDocumentDocumentIdPathParams
  >({
    url: "/raid/document/{documentId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Read a document
 */
export function getRaidDocumentDocumentIdQuery(
  variables: GetRaidDocumentDocumentIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getRaidDocumentDocumentIdQuery(
  variables: GetRaidDocumentDocumentIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getRaidDocumentDocumentIdQuery(
  variables: GetRaidDocumentDocumentIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/document/{documentId}",
      operationId: "getRaidDocumentDocumentId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRaidDocumentDocumentId(variables, signal),
  };
}

/**
 * Read a document
 */
export const useSuspenseGetRaidDocumentDocumentId = <TData = undefined,>(
  variables: GetRaidDocumentDocumentIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetRaidDocumentDocumentIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetRaidDocumentDocumentIdError,
    TData
  >({
    ...getRaidDocumentDocumentIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Read a document
 */
export const useGetRaidDocumentDocumentId = <TData = undefined,>(
  variables: GetRaidDocumentDocumentIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetRaidDocumentDocumentIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetRaidDocumentDocumentIdError, TData>({
    ...getRaidDocumentDocumentIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostRaidDocumentDocumentIdValidatePathParams = {
  documentId: string;
};

export type PostRaidDocumentDocumentIdValidateQueryParams = {
  validation: Schemas.DocumentValidation;
};

export type PostRaidDocumentDocumentIdValidateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidDocumentDocumentIdValidateVariables = {
  pathParams: PostRaidDocumentDocumentIdValidatePathParams;
  queryParams: PostRaidDocumentDocumentIdValidateQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Validate a document
 */
export const fetchPostRaidDocumentDocumentIdValidate = (
  variables: PostRaidDocumentDocumentIdValidateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostRaidDocumentDocumentIdValidateError,
    undefined,
    {},
    PostRaidDocumentDocumentIdValidateQueryParams,
    PostRaidDocumentDocumentIdValidatePathParams
  >({
    url: "/raid/document/{documentId}/validate",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Validate a document
 */
export const usePostRaidDocumentDocumentIdValidate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostRaidDocumentDocumentIdValidateError,
      PostRaidDocumentDocumentIdValidateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostRaidDocumentDocumentIdValidateError,
    PostRaidDocumentDocumentIdValidateVariables
  >({
    mutationFn: (variables: PostRaidDocumentDocumentIdValidateVariables) =>
      fetchPostRaidDocumentDocumentIdValidate(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostRaidSecurityFileQueryParams = {
  participant_id: string;
};

export type PostRaidSecurityFileError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidSecurityFileVariables = {
  body: Schemas.SecurityFileBase;
  queryParams: PostRaidSecurityFileQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Confirm security file
 */
export const fetchPostRaidSecurityFile = (
  variables: PostRaidSecurityFileVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.SecurityFile,
    PostRaidSecurityFileError,
    Schemas.SecurityFileBase,
    {},
    PostRaidSecurityFileQueryParams,
    {}
  >({ url: "/raid/security_file/", method: "post", ...variables, signal });

/**
 * Confirm security file
 */
export const usePostRaidSecurityFile = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.SecurityFile,
      PostRaidSecurityFileError,
      PostRaidSecurityFileVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.SecurityFile,
    PostRaidSecurityFileError,
    PostRaidSecurityFileVariables
  >({
    mutationFn: (variables: PostRaidSecurityFileVariables) =>
      fetchPostRaidSecurityFile(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostRaidParticipantParticipantIdPaymentPathParams = {
  participantId: string;
};

export type PostRaidParticipantParticipantIdPaymentError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostRaidParticipantParticipantIdPaymentVariables = {
  pathParams: PostRaidParticipantParticipantIdPaymentPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Confirm payment manually
 */
export const fetchPostRaidParticipantParticipantIdPayment = (
  variables: PostRaidParticipantParticipantIdPaymentVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostRaidParticipantParticipantIdPaymentError,
    undefined,
    {},
    {},
    PostRaidParticipantParticipantIdPaymentPathParams
  >({
    url: "/raid/participant/{participantId}/payment",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Confirm payment manually
 */
export const usePostRaidParticipantParticipantIdPayment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostRaidParticipantParticipantIdPaymentError,
      PostRaidParticipantParticipantIdPaymentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostRaidParticipantParticipantIdPaymentError,
    PostRaidParticipantParticipantIdPaymentVariables
  >({
    mutationFn: (variables: PostRaidParticipantParticipantIdPaymentVariables) =>
      fetchPostRaidParticipantParticipantIdPayment(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostRaidParticipantParticipantIdTShirtPaymentPathParams = {
  participantId: string;
};

export type PostRaidParticipantParticipantIdTShirtPaymentError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostRaidParticipantParticipantIdTShirtPaymentVariables = {
  pathParams: PostRaidParticipantParticipantIdTShirtPaymentPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Confirm T shirt payment
 */
export const fetchPostRaidParticipantParticipantIdTShirtPayment = (
  variables: PostRaidParticipantParticipantIdTShirtPaymentVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostRaidParticipantParticipantIdTShirtPaymentError,
    undefined,
    {},
    {},
    PostRaidParticipantParticipantIdTShirtPaymentPathParams
  >({
    url: "/raid/participant/{participantId}/t_shirt_payment",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Confirm T shirt payment
 */
export const usePostRaidParticipantParticipantIdTShirtPayment = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostRaidParticipantParticipantIdTShirtPaymentError,
      PostRaidParticipantParticipantIdTShirtPaymentVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostRaidParticipantParticipantIdTShirtPaymentError,
    PostRaidParticipantParticipantIdTShirtPaymentVariables
  >({
    mutationFn: (
      variables: PostRaidParticipantParticipantIdTShirtPaymentVariables,
    ) =>
      fetchPostRaidParticipantParticipantIdTShirtPayment(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostRaidParticipantParticipantIdHonourPathParams = {
  participantId: string;
};

export type PostRaidParticipantParticipantIdHonourError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidParticipantParticipantIdHonourVariables = {
  pathParams: PostRaidParticipantParticipantIdHonourPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Validate attestation on honour
 */
export const fetchPostRaidParticipantParticipantIdHonour = (
  variables: PostRaidParticipantParticipantIdHonourVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostRaidParticipantParticipantIdHonourError,
    undefined,
    {},
    {},
    PostRaidParticipantParticipantIdHonourPathParams
  >({
    url: "/raid/participant/{participantId}/honour",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Validate attestation on honour
 */
export const usePostRaidParticipantParticipantIdHonour = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostRaidParticipantParticipantIdHonourError,
      PostRaidParticipantParticipantIdHonourVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostRaidParticipantParticipantIdHonourError,
    PostRaidParticipantParticipantIdHonourVariables
  >({
    mutationFn: (variables: PostRaidParticipantParticipantIdHonourVariables) =>
      fetchPostRaidParticipantParticipantIdHonour(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostRaidTeamsTeamIdInvitePathParams = {
  teamId: string;
};

export type PostRaidTeamsTeamIdInviteError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidTeamsTeamIdInviteVariables = {
  pathParams: PostRaidTeamsTeamIdInvitePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create an invite token
 */
export const fetchPostRaidTeamsTeamIdInvite = (
  variables: PostRaidTeamsTeamIdInviteVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.InviteToken,
    PostRaidTeamsTeamIdInviteError,
    undefined,
    {},
    {},
    PostRaidTeamsTeamIdInvitePathParams
  >({
    url: "/raid/teams/{teamId}/invite",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create an invite token
 */
export const usePostRaidTeamsTeamIdInvite = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.InviteToken,
      PostRaidTeamsTeamIdInviteError,
      PostRaidTeamsTeamIdInviteVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.InviteToken,
    PostRaidTeamsTeamIdInviteError,
    PostRaidTeamsTeamIdInviteVariables
  >({
    mutationFn: (variables: PostRaidTeamsTeamIdInviteVariables) =>
      fetchPostRaidTeamsTeamIdInvite(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostRaidTeamsJoinTokenPathParams = {
  token: string;
};

export type PostRaidTeamsJoinTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidTeamsJoinTokenVariables = {
  pathParams: PostRaidTeamsJoinTokenPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Join a team
 */
export const fetchPostRaidTeamsJoinToken = (
  variables: PostRaidTeamsJoinTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostRaidTeamsJoinTokenError,
    undefined,
    {},
    {},
    PostRaidTeamsJoinTokenPathParams
  >({ url: "/raid/teams/join/{token}", method: "post", ...variables, signal });

/**
 * Join a team
 */
export const usePostRaidTeamsJoinToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostRaidTeamsJoinTokenError,
      PostRaidTeamsJoinTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostRaidTeamsJoinTokenError,
    PostRaidTeamsJoinTokenVariables
  >({
    mutationFn: (variables: PostRaidTeamsJoinTokenVariables) =>
      fetchPostRaidTeamsJoinToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostRaidTeamsTeamIdKickParticipantIdPathParams = {
  teamId: string;
  participantId: string;
};

export type PostRaidTeamsTeamIdKickParticipantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidTeamsTeamIdKickParticipantIdVariables = {
  pathParams: PostRaidTeamsTeamIdKickParticipantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Leave a team
 */
export const fetchPostRaidTeamsTeamIdKickParticipantId = (
  variables: PostRaidTeamsTeamIdKickParticipantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidTeam,
    PostRaidTeamsTeamIdKickParticipantIdError,
    undefined,
    {},
    {},
    PostRaidTeamsTeamIdKickParticipantIdPathParams
  >({
    url: "/raid/teams/{teamId}/kick/{participantId}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Leave a team
 */
export const usePostRaidTeamsTeamIdKickParticipantId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RaidTeam,
      PostRaidTeamsTeamIdKickParticipantIdError,
      PostRaidTeamsTeamIdKickParticipantIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RaidTeam,
    PostRaidTeamsTeamIdKickParticipantIdError,
    PostRaidTeamsTeamIdKickParticipantIdVariables
  >({
    mutationFn: (variables: PostRaidTeamsTeamIdKickParticipantIdVariables) =>
      fetchPostRaidTeamsTeamIdKickParticipantId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostRaidTeamsMergeQueryParams = {
  team1_id: string;
  team2_id: string;
};

export type PostRaidTeamsMergeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostRaidTeamsMergeVariables = {
  queryParams: PostRaidTeamsMergeQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Merge two teams
 */
export const fetchPostRaidTeamsMerge = (
  variables: PostRaidTeamsMergeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidTeam,
    PostRaidTeamsMergeError,
    undefined,
    {},
    PostRaidTeamsMergeQueryParams,
    {}
  >({ url: "/raid/teams/merge", method: "post", ...variables, signal });

/**
 * Merge two teams
 */
export const usePostRaidTeamsMerge = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.RaidTeam,
      PostRaidTeamsMergeError,
      PostRaidTeamsMergeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.RaidTeam,
    PostRaidTeamsMergeError,
    PostRaidTeamsMergeVariables
  >({
    mutationFn: (variables: PostRaidTeamsMergeVariables) =>
      fetchPostRaidTeamsMerge(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidInformationError = Fetcher.ErrorWrapper<undefined>;

export type GetRaidInformationVariables = HyperionContext["fetcherOptions"];

/**
 * Get raid information
 */
export const fetchGetRaidInformation = (
  variables: GetRaidInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidInformation,
    GetRaidInformationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/raid/information", method: "get", ...variables, signal });

/**
 * Get raid information
 */
export function getRaidInformationQuery(
  variables: GetRaidInformationVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RaidInformation>;
};

export function getRaidInformationQuery(
  variables: GetRaidInformationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaidInformation>)
    | reactQuery.SkipToken;
};

export function getRaidInformationQuery(
  variables: GetRaidInformationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/information",
      operationId: "getRaidInformation",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetRaidInformation(variables, signal),
  };
}

/**
 * Get raid information
 */
export const useSuspenseGetRaidInformation = <TData = Schemas.RaidInformation,>(
  variables: GetRaidInformationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidInformation,
      GetRaidInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaidInformation,
    GetRaidInformationError,
    TData
  >({
    ...getRaidInformationQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get raid information
 */
export const useGetRaidInformation = <TData = Schemas.RaidInformation,>(
  variables: GetRaidInformationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidInformation,
      GetRaidInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RaidInformation,
    GetRaidInformationError,
    TData
  >({
    ...getRaidInformationQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchRaidInformationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchRaidInformationVariables = {
  body?: Schemas.RaidInformation;
} & HyperionContext["fetcherOptions"];

/**
 * Update raid information
 */
export const fetchPatchRaidInformation = (
  variables: PatchRaidInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchRaidInformationError,
    Schemas.RaidInformation,
    {},
    {},
    {}
  >({ url: "/raid/information", method: "patch", ...variables, signal });

/**
 * Update raid information
 */
export const usePatchRaidInformation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRaidInformationError,
      PatchRaidInformationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRaidInformationError,
    PatchRaidInformationVariables
  >({
    mutationFn: (variables: PatchRaidInformationVariables) =>
      fetchPatchRaidInformation(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidDriveError = Fetcher.ErrorWrapper<undefined>;

export type GetRaidDriveVariables = HyperionContext["fetcherOptions"];

/**
 * Get drive folders
 */
export const fetchGetRaidDrive = (
  variables: GetRaidDriveVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.RaidDriveFoldersCreation,
    GetRaidDriveError,
    undefined,
    {},
    {},
    {}
  >({ url: "/raid/drive", method: "get", ...variables, signal });

/**
 * Get drive folders
 */
export function getRaidDriveQuery(variables: GetRaidDriveVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.RaidDriveFoldersCreation>;
};

export function getRaidDriveQuery(
  variables: GetRaidDriveVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaidDriveFoldersCreation>)
    | reactQuery.SkipToken;
};

export function getRaidDriveQuery(
  variables: GetRaidDriveVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/drive",
      operationId: "getRaidDrive",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRaidDrive(variables, signal),
  };
}

/**
 * Get drive folders
 */
export const useSuspenseGetRaidDrive = <
  TData = Schemas.RaidDriveFoldersCreation,
>(
  variables: GetRaidDriveVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidDriveFoldersCreation,
      GetRaidDriveError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaidDriveFoldersCreation,
    GetRaidDriveError,
    TData
  >({
    ...getRaidDriveQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get drive folders
 */
export const useGetRaidDrive = <TData = Schemas.RaidDriveFoldersCreation,>(
  variables: GetRaidDriveVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.RaidDriveFoldersCreation,
      GetRaidDriveError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.RaidDriveFoldersCreation,
    GetRaidDriveError,
    TData
  >({
    ...getRaidDriveQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchRaidDriveError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchRaidDriveVariables = {
  body: Schemas.RaidDriveFoldersCreation;
} & HyperionContext["fetcherOptions"];

/**
 * Update drive folders
 */
export const fetchPatchRaidDrive = (
  variables: PatchRaidDriveVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchRaidDriveError,
    Schemas.RaidDriveFoldersCreation,
    {},
    {},
    {}
  >({ url: "/raid/drive", method: "patch", ...variables, signal });

/**
 * Update drive folders
 */
export const usePatchRaidDrive = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRaidDriveError,
      PatchRaidDriveVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRaidDriveError,
    PatchRaidDriveVariables
  >({
    mutationFn: (variables: PatchRaidDriveVariables) =>
      fetchPatchRaidDrive(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidPriceError = Fetcher.ErrorWrapper<undefined>;

export type GetRaidPriceVariables = HyperionContext["fetcherOptions"];

/**
 * Get raid price
 */
export const fetchGetRaidPrice = (
  variables: GetRaidPriceVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.RaidPrice, GetRaidPriceError, undefined, {}, {}, {}>({
    url: "/raid/price",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get raid price
 */
export function getRaidPriceQuery(variables: GetRaidPriceVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.RaidPrice>;
};

export function getRaidPriceQuery(
  variables: GetRaidPriceVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.RaidPrice>)
    | reactQuery.SkipToken;
};

export function getRaidPriceQuery(
  variables: GetRaidPriceVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/price",
      operationId: "getRaidPrice",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRaidPrice(variables, signal),
  };
}

/**
 * Get raid price
 */
export const useSuspenseGetRaidPrice = <TData = Schemas.RaidPrice,>(
  variables: GetRaidPriceVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.RaidPrice, GetRaidPriceError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.RaidPrice,
    GetRaidPriceError,
    TData
  >({
    ...getRaidPriceQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get raid price
 */
export const useGetRaidPrice = <TData = Schemas.RaidPrice,>(
  variables: GetRaidPriceVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.RaidPrice, GetRaidPriceError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.RaidPrice, GetRaidPriceError, TData>({
    ...getRaidPriceQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchRaidPriceError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchRaidPriceVariables = {
  body?: Schemas.RaidPrice;
} & HyperionContext["fetcherOptions"];

/**
 * Update raid price
 */
export const fetchPatchRaidPrice = (
  variables: PatchRaidPriceVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PatchRaidPriceError, Schemas.RaidPrice, {}, {}, {}>({
    url: "/raid/price",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update raid price
 */
export const usePatchRaidPrice = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchRaidPriceError,
      PatchRaidPriceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchRaidPriceError,
    PatchRaidPriceVariables
  >({
    mutationFn: (variables: PatchRaidPriceVariables) =>
      fetchPatchRaidPrice(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetRaidPayError = Fetcher.ErrorWrapper<undefined>;

export type GetRaidPayVariables = HyperionContext["fetcherOptions"];

/**
 * Get payment url
 */
export const fetchGetRaidPay = (
  variables: GetRaidPayVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.PaymentUrl, GetRaidPayError, undefined, {}, {}, {}>({
    url: "/raid/pay",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get payment url
 */
export function getRaidPayQuery(variables: GetRaidPayVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.PaymentUrl>;
};

export function getRaidPayQuery(
  variables: GetRaidPayVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.PaymentUrl>)
    | reactQuery.SkipToken;
};

export function getRaidPayQuery(
  variables: GetRaidPayVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/raid/pay",
      operationId: "getRaidPay",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRaidPay(variables, signal),
  };
}

/**
 * Get payment url
 */
export const useSuspenseGetRaidPay = <TData = Schemas.PaymentUrl,>(
  variables: GetRaidPayVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PaymentUrl, GetRaidPayError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.PaymentUrl,
    GetRaidPayError,
    TData
  >({
    ...getRaidPayQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get payment url
 */
export const useGetRaidPay = <TData = Schemas.PaymentUrl,>(
  variables: GetRaidPayVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PaymentUrl, GetRaidPayError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.PaymentUrl, GetRaidPayError, TData>({
    ...getRaidPayQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCalendarEventsError = Fetcher.ErrorWrapper<undefined>;

export type GetCalendarEventsResponse = Schemas.EventReturn[];

export type GetCalendarEventsVariables = HyperionContext["fetcherOptions"];

/**
 * Get all events from the database.
 */
export const fetchGetCalendarEvents = (
  variables: GetCalendarEventsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCalendarEventsResponse,
    GetCalendarEventsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/calendar/events/", method: "get", ...variables, signal });

/**
 * Get all events from the database.
 */
export function getCalendarEventsQuery(variables: GetCalendarEventsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetCalendarEventsResponse>;
};

export function getCalendarEventsQuery(
  variables: GetCalendarEventsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCalendarEventsResponse>)
    | reactQuery.SkipToken;
};

export function getCalendarEventsQuery(
  variables: GetCalendarEventsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/calendar/events/",
      operationId: "getCalendarEvents",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCalendarEvents(variables, signal),
  };
}

/**
 * Get all events from the database.
 */
export const useSuspenseGetCalendarEvents = <
  TData = GetCalendarEventsResponse,
>(
  variables: GetCalendarEventsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsResponse,
      GetCalendarEventsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCalendarEventsResponse,
    GetCalendarEventsError,
    TData
  >({
    ...getCalendarEventsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all events from the database.
 */
export const useGetCalendarEvents = <TData = GetCalendarEventsResponse,>(
  variables: GetCalendarEventsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsResponse,
      GetCalendarEventsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCalendarEventsResponse,
    GetCalendarEventsError,
    TData
  >({
    ...getCalendarEventsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostCalendarEventsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostCalendarEventsVariables = {
  body: Schemas.EventBase;
} & HyperionContext["fetcherOptions"];

/**
 * Add an event to the calendar.
 */
export const fetchPostCalendarEvents = (
  variables: PostCalendarEventsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.EventReturn,
    PostCalendarEventsError,
    Schemas.EventBase,
    {},
    {},
    {}
  >({ url: "/calendar/events/", method: "post", ...variables, signal });

/**
 * Add an event to the calendar.
 */
export const usePostCalendarEvents = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.EventReturn,
      PostCalendarEventsError,
      PostCalendarEventsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.EventReturn,
    PostCalendarEventsError,
    PostCalendarEventsVariables
  >({
    mutationFn: (variables: PostCalendarEventsVariables) =>
      fetchPostCalendarEvents(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCalendarEventsConfirmedError = Fetcher.ErrorWrapper<undefined>;

export type GetCalendarEventsConfirmedResponse = Schemas.EventComplete[];

export type GetCalendarEventsConfirmedVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export const fetchGetCalendarEventsConfirmed = (
  variables: GetCalendarEventsConfirmedVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCalendarEventsConfirmedResponse,
    GetCalendarEventsConfirmedError,
    undefined,
    {},
    {},
    {}
  >({ url: "/calendar/events/confirmed", method: "get", ...variables, signal });

/**
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export function getCalendarEventsConfirmedQuery(
  variables: GetCalendarEventsConfirmedVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCalendarEventsConfirmedResponse>;
};

export function getCalendarEventsConfirmedQuery(
  variables: GetCalendarEventsConfirmedVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetCalendarEventsConfirmedResponse>)
    | reactQuery.SkipToken;
};

export function getCalendarEventsConfirmedQuery(
  variables: GetCalendarEventsConfirmedVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/calendar/events/confirmed",
      operationId: "getCalendarEventsConfirmed",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCalendarEventsConfirmed(variables, signal),
  };
}

/**
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export const useSuspenseGetCalendarEventsConfirmed = <
  TData = GetCalendarEventsConfirmedResponse,
>(
  variables: GetCalendarEventsConfirmedVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsConfirmedResponse,
      GetCalendarEventsConfirmedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCalendarEventsConfirmedResponse,
    GetCalendarEventsConfirmedError,
    TData
  >({
    ...getCalendarEventsConfirmedQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all confirmed events.
 *
 * **Usable by every member**
 */
export const useGetCalendarEventsConfirmed = <
  TData = GetCalendarEventsConfirmedResponse,
>(
  variables: GetCalendarEventsConfirmedVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsConfirmedResponse,
      GetCalendarEventsConfirmedError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCalendarEventsConfirmedResponse,
    GetCalendarEventsConfirmedError,
    TData
  >({
    ...getCalendarEventsConfirmedQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCalendarEventsUserApplicantIdPathParams = {
  applicantId: string;
};

export type GetCalendarEventsUserApplicantIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCalendarEventsUserApplicantIdResponse = Schemas.EventReturn[];

export type GetCalendarEventsUserApplicantIdVariables = {
  pathParams: GetCalendarEventsUserApplicantIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export const fetchGetCalendarEventsUserApplicantId = (
  variables: GetCalendarEventsUserApplicantIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetCalendarEventsUserApplicantIdResponse,
    GetCalendarEventsUserApplicantIdError,
    undefined,
    {},
    {},
    GetCalendarEventsUserApplicantIdPathParams
  >({
    url: "/calendar/events/user/{applicantId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export function getCalendarEventsUserApplicantIdQuery(
  variables: GetCalendarEventsUserApplicantIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetCalendarEventsUserApplicantIdResponse>;
};

export function getCalendarEventsUserApplicantIdQuery(
  variables: GetCalendarEventsUserApplicantIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetCalendarEventsUserApplicantIdResponse>)
    | reactQuery.SkipToken;
};

export function getCalendarEventsUserApplicantIdQuery(
  variables: GetCalendarEventsUserApplicantIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/calendar/events/user/{applicantId}",
      operationId: "getCalendarEventsUserApplicantId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCalendarEventsUserApplicantId(variables, signal),
  };
}

/**
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export const useSuspenseGetCalendarEventsUserApplicantId = <
  TData = GetCalendarEventsUserApplicantIdResponse,
>(
  variables: GetCalendarEventsUserApplicantIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsUserApplicantIdResponse,
      GetCalendarEventsUserApplicantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetCalendarEventsUserApplicantIdResponse,
    GetCalendarEventsUserApplicantIdError,
    TData
  >({
    ...getCalendarEventsUserApplicantIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get one user bookings.
 *
 * **Usable by the user or admins**
 */
export const useGetCalendarEventsUserApplicantId = <
  TData = GetCalendarEventsUserApplicantIdResponse,
>(
  variables: GetCalendarEventsUserApplicantIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetCalendarEventsUserApplicantIdResponse,
      GetCalendarEventsUserApplicantIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetCalendarEventsUserApplicantIdResponse,
    GetCalendarEventsUserApplicantIdError,
    TData
  >({
    ...getCalendarEventsUserApplicantIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetCalendarEventsEventIdPathParams = {
  eventId: string;
};

export type GetCalendarEventsEventIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCalendarEventsEventIdVariables = {
  pathParams: GetCalendarEventsEventIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get an event's information by its id.
 */
export const fetchGetCalendarEventsEventId = (
  variables: GetCalendarEventsEventIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.EventComplete,
    GetCalendarEventsEventIdError,
    undefined,
    {},
    {},
    GetCalendarEventsEventIdPathParams
  >({ url: "/calendar/events/{eventId}", method: "get", ...variables, signal });

/**
 * Get an event's information by its id.
 */
export function getCalendarEventsEventIdQuery(
  variables: GetCalendarEventsEventIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.EventComplete>;
};

export function getCalendarEventsEventIdQuery(
  variables: GetCalendarEventsEventIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.EventComplete>)
    | reactQuery.SkipToken;
};

export function getCalendarEventsEventIdQuery(
  variables: GetCalendarEventsEventIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/calendar/events/{eventId}",
      operationId: "getCalendarEventsEventId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCalendarEventsEventId(variables, signal),
  };
}

/**
 * Get an event's information by its id.
 */
export const useSuspenseGetCalendarEventsEventId = <
  TData = Schemas.EventComplete,
>(
  variables: GetCalendarEventsEventIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventComplete,
      GetCalendarEventsEventIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.EventComplete,
    GetCalendarEventsEventIdError,
    TData
  >({
    ...getCalendarEventsEventIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get an event's information by its id.
 */
export const useGetCalendarEventsEventId = <TData = Schemas.EventComplete,>(
  variables: GetCalendarEventsEventIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventComplete,
      GetCalendarEventsEventIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.EventComplete,
    GetCalendarEventsEventIdError,
    TData
  >({
    ...getCalendarEventsEventIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCalendarEventsEventIdPathParams = {
  eventId: string;
};

export type PatchCalendarEventsEventIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchCalendarEventsEventIdVariables = {
  body?: Schemas.EventEdit;
  pathParams: PatchCalendarEventsEventIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Edit an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const fetchPatchCalendarEventsEventId = (
  variables: PatchCalendarEventsEventIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCalendarEventsEventIdError,
    Schemas.EventEdit,
    {},
    {},
    PatchCalendarEventsEventIdPathParams
  >({
    url: "/calendar/events/{eventId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Edit an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const usePatchCalendarEventsEventId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCalendarEventsEventIdError,
      PatchCalendarEventsEventIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCalendarEventsEventIdError,
    PatchCalendarEventsEventIdVariables
  >({
    mutationFn: (variables: PatchCalendarEventsEventIdVariables) =>
      fetchPatchCalendarEventsEventId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteCalendarEventsEventIdPathParams = {
  eventId: void;
};

export type DeleteCalendarEventsEventIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteCalendarEventsEventIdVariables = {
  pathParams: DeleteCalendarEventsEventIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Remove an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const fetchDeleteCalendarEventsEventId = (
  variables: DeleteCalendarEventsEventIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteCalendarEventsEventIdError,
    undefined,
    {},
    {},
    DeleteCalendarEventsEventIdPathParams
  >({
    url: "/calendar/events/{eventId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Remove an event.
 *
 * **Only usable by admins or applicant before decision**
 */
export const useDeleteCalendarEventsEventId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteCalendarEventsEventIdError,
      DeleteCalendarEventsEventIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteCalendarEventsEventIdError,
    DeleteCalendarEventsEventIdVariables
  >({
    mutationFn: (variables: DeleteCalendarEventsEventIdVariables) =>
      fetchDeleteCalendarEventsEventId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCalendarEventsEventIdApplicantPathParams = {
  eventId: string;
};

export type GetCalendarEventsEventIdApplicantError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetCalendarEventsEventIdApplicantVariables = {
  pathParams: GetCalendarEventsEventIdApplicantPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchGetCalendarEventsEventIdApplicant = (
  variables: GetCalendarEventsEventIdApplicantVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.EventApplicant,
    GetCalendarEventsEventIdApplicantError,
    undefined,
    {},
    {},
    GetCalendarEventsEventIdApplicantPathParams
  >({
    url: "/calendar/events/{eventId}/applicant",
    method: "get",
    ...variables,
    signal,
  });

export function getCalendarEventsEventIdApplicantQuery(
  variables: GetCalendarEventsEventIdApplicantVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.EventApplicant>;
};

export function getCalendarEventsEventIdApplicantQuery(
  variables: GetCalendarEventsEventIdApplicantVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.EventApplicant>)
    | reactQuery.SkipToken;
};

export function getCalendarEventsEventIdApplicantQuery(
  variables: GetCalendarEventsEventIdApplicantVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/calendar/events/{eventId}/applicant",
      operationId: "getCalendarEventsEventIdApplicant",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCalendarEventsEventIdApplicant(variables, signal),
  };
}

export const useSuspenseGetCalendarEventsEventIdApplicant = <
  TData = Schemas.EventApplicant,
>(
  variables: GetCalendarEventsEventIdApplicantVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventApplicant,
      GetCalendarEventsEventIdApplicantError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.EventApplicant,
    GetCalendarEventsEventIdApplicantError,
    TData
  >({
    ...getCalendarEventsEventIdApplicantQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetCalendarEventsEventIdApplicant = <
  TData = Schemas.EventApplicant,
>(
  variables: GetCalendarEventsEventIdApplicantVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.EventApplicant,
      GetCalendarEventsEventIdApplicantError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.EventApplicant,
    GetCalendarEventsEventIdApplicantError,
    TData
  >({
    ...getCalendarEventsEventIdApplicantQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchCalendarEventsEventIdReplyDecisionPathParams = {
  eventId: string;
  decision: Schemas.Decision;
};

export type PatchCalendarEventsEventIdReplyDecisionError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchCalendarEventsEventIdReplyDecisionVariables = {
  pathParams: PatchCalendarEventsEventIdReplyDecisionPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Give a decision to an event.
 *
 * **Only usable by admins**
 */
export const fetchPatchCalendarEventsEventIdReplyDecision = (
  variables: PatchCalendarEventsEventIdReplyDecisionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchCalendarEventsEventIdReplyDecisionError,
    undefined,
    {},
    {},
    PatchCalendarEventsEventIdReplyDecisionPathParams
  >({
    url: "/calendar/events/{eventId}/reply/{decision}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Give a decision to an event.
 *
 * **Only usable by admins**
 */
export const usePatchCalendarEventsEventIdReplyDecision = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchCalendarEventsEventIdReplyDecisionError,
      PatchCalendarEventsEventIdReplyDecisionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchCalendarEventsEventIdReplyDecisionError,
    PatchCalendarEventsEventIdReplyDecisionVariables
  >({
    mutationFn: (variables: PatchCalendarEventsEventIdReplyDecisionVariables) =>
      fetchPatchCalendarEventsEventIdReplyDecision(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostCalendarIcalCreateError = Fetcher.ErrorWrapper<undefined>;

export type PostCalendarIcalCreateVariables = HyperionContext["fetcherOptions"];

/**
 * Create manually the icalendar file
 *
 * **Only usable by global admins**
 */
export const fetchPostCalendarIcalCreate = (
  variables: PostCalendarIcalCreateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostCalendarIcalCreateError, undefined, {}, {}, {}>({
    url: "/calendar/ical/create",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create manually the icalendar file
 *
 * **Only usable by global admins**
 */
export const usePostCalendarIcalCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostCalendarIcalCreateError,
      PostCalendarIcalCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostCalendarIcalCreateError,
    PostCalendarIcalCreateVariables
  >({
    mutationFn: (variables: PostCalendarIcalCreateVariables) =>
      fetchPostCalendarIcalCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCalendarIcalError = Fetcher.ErrorWrapper<undefined>;

export type GetCalendarIcalVariables = HyperionContext["fetcherOptions"];

/**
 * Get the icalendar file corresponding to the event in the database.
 */
export const fetchGetCalendarIcal = (
  variables: GetCalendarIcalVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetCalendarIcalError, undefined, {}, {}, {}>({
    url: "/calendar/ical",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the icalendar file corresponding to the event in the database.
 */
export function getCalendarIcalQuery(variables: GetCalendarIcalVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getCalendarIcalQuery(
  variables: GetCalendarIcalVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getCalendarIcalQuery(
  variables: GetCalendarIcalVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/calendar/ical",
      operationId: "getCalendarIcal",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCalendarIcal(variables, signal),
  };
}

/**
 * Get the icalendar file corresponding to the event in the database.
 */
export const useSuspenseGetCalendarIcal = <TData = undefined,>(
  variables: GetCalendarIcalVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetCalendarIcalError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetCalendarIcalError, TData>({
    ...getCalendarIcalQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the icalendar file corresponding to the event in the database.
 */
export const useGetCalendarIcal = <TData = undefined,>(
  variables: GetCalendarIcalVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetCalendarIcalError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetCalendarIcalError, TData>({
    ...getCalendarIcalQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostPaymentHelloassoWebhookError = Fetcher.ErrorWrapper<undefined>;

export type PostPaymentHelloassoWebhookVariables =
  HyperionContext["fetcherOptions"];

export const fetchPostPaymentHelloassoWebhook = (
  variables: PostPaymentHelloassoWebhookVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostPaymentHelloassoWebhookError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/payment/helloasso/webhook",
    method: "post",
    ...variables,
    signal,
  });

export const usePostPaymentHelloassoWebhook = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostPaymentHelloassoWebhookError,
      PostPaymentHelloassoWebhookVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostPaymentHelloassoWebhookError,
    PostPaymentHelloassoWebhookVariables
  >({
    mutationFn: (variables: PostPaymentHelloassoWebhookVariables) =>
      fetchPostPaymentHelloassoWebhook(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetSchoolsError = Fetcher.ErrorWrapper<undefined>;

export type GetSchoolsResponse = Schemas.CoreSchool[];

export type GetSchoolsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all schools from database as a list of dictionaries
 */
export const fetchGetSchools = (
  variables: GetSchoolsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetSchoolsResponse, GetSchoolsError, undefined, {}, {}, {}>({
    url: "/schools/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all schools from database as a list of dictionaries
 */
export function getSchoolsQuery(variables: GetSchoolsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetSchoolsResponse>;
};

export function getSchoolsQuery(
  variables: GetSchoolsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetSchoolsResponse>)
    | reactQuery.SkipToken;
};

export function getSchoolsQuery(
  variables: GetSchoolsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/schools/",
      operationId: "getSchools",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetSchools(variables, signal),
  };
}

/**
 * Return all schools from database as a list of dictionaries
 */
export const useSuspenseGetSchools = <TData = GetSchoolsResponse,>(
  variables: GetSchoolsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetSchoolsResponse, GetSchoolsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetSchoolsResponse,
    GetSchoolsError,
    TData
  >({
    ...getSchoolsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all schools from database as a list of dictionaries
 */
export const useGetSchools = <TData = GetSchoolsResponse,>(
  variables: GetSchoolsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetSchoolsResponse, GetSchoolsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetSchoolsResponse, GetSchoolsError, TData>({
    ...getSchoolsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostSchoolsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostSchoolsVariables = {
  body: Schemas.CoreSchoolBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new school and add users to it based on the email regex.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostSchools = (
  variables: PostSchoolsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreSchool,
    PostSchoolsError,
    Schemas.CoreSchoolBase,
    {},
    {},
    {}
  >({ url: "/schools/", method: "post", ...variables, signal });

/**
 * Create a new school and add users to it based on the email regex.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostSchools = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CoreSchool,
      PostSchoolsError,
      PostSchoolsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CoreSchool,
    PostSchoolsError,
    PostSchoolsVariables
  >({
    mutationFn: (variables: PostSchoolsVariables) =>
      fetchPostSchools(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type GetSchoolsSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetSchoolsSchoolIdVariables = {
  pathParams: GetSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return school with id from database as a dictionary.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetSchoolsSchoolId = (
  variables: GetSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreSchool,
    GetSchoolsSchoolIdError,
    undefined,
    {},
    {},
    GetSchoolsSchoolIdPathParams
  >({ url: "/schools/{schoolId}", method: "get", ...variables, signal });

/**
 * Return school with id from database as a dictionary.
 *
 * **This endpoint is only usable by administrators**
 */
export function getSchoolsSchoolIdQuery(
  variables: GetSchoolsSchoolIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CoreSchool>;
};

export function getSchoolsSchoolIdQuery(
  variables: GetSchoolsSchoolIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CoreSchool>)
    | reactQuery.SkipToken;
};

export function getSchoolsSchoolIdQuery(
  variables: GetSchoolsSchoolIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/schools/{schoolId}",
      operationId: "getSchoolsSchoolId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSchoolsSchoolId(variables, signal),
  };
}

/**
 * Return school with id from database as a dictionary.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetSchoolsSchoolId = <TData = Schemas.CoreSchool,>(
  variables: GetSchoolsSchoolIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CoreSchool,
      GetSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CoreSchool,
    GetSchoolsSchoolIdError,
    TData
  >({
    ...getSchoolsSchoolIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return school with id from database as a dictionary.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetSchoolsSchoolId = <TData = Schemas.CoreSchool,>(
  variables: GetSchoolsSchoolIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CoreSchool,
      GetSchoolsSchoolIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CoreSchool,
    GetSchoolsSchoolIdError,
    TData
  >({
    ...getSchoolsSchoolIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type PatchSchoolsSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchSchoolsSchoolIdVariables = {
  body?: Schemas.CoreSchoolUpdate;
  pathParams: PatchSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update the name or the description of a school.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchSchoolsSchoolId = (
  variables: PatchSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchSchoolsSchoolIdError,
    Schemas.CoreSchoolUpdate,
    {},
    {},
    PatchSchoolsSchoolIdPathParams
  >({ url: "/schools/{schoolId}", method: "patch", ...variables, signal });

/**
 * Update the name or the description of a school.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchSchoolsSchoolId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchSchoolsSchoolIdError,
      PatchSchoolsSchoolIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchSchoolsSchoolIdError,
    PatchSchoolsSchoolIdVariables
  >({
    mutationFn: (variables: PatchSchoolsSchoolIdVariables) =>
      fetchPatchSchoolsSchoolId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteSchoolsSchoolIdPathParams = {
  /**
   * @format uuid
   */
  schoolId: string;
};

export type DeleteSchoolsSchoolIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteSchoolsSchoolIdVariables = {
  pathParams: DeleteSchoolsSchoolIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete school from database.
 * This will remove the school from all users but won't delete any user.
 *
 * `SchoolTypes` schools can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteSchoolsSchoolId = (
  variables: DeleteSchoolsSchoolIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteSchoolsSchoolIdError,
    undefined,
    {},
    {},
    DeleteSchoolsSchoolIdPathParams
  >({ url: "/schools/{schoolId}", method: "delete", ...variables, signal });

/**
 * Delete school from database.
 * This will remove the school from all users but won't delete any user.
 *
 * `SchoolTypes` schools can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteSchoolsSchoolId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteSchoolsSchoolIdError,
      DeleteSchoolsSchoolIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteSchoolsSchoolIdError,
    DeleteSchoolsSchoolIdVariables
  >({
    mutationFn: (variables: DeleteSchoolsSchoolIdVariables) =>
      fetchDeleteSchoolsSchoolId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUsersQueryParams = {
  accountTypes?: Schemas.AccountType[];
};

export type GetUsersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersResponse = Schemas.CoreUserSimple[];

export type GetUsersVariables = {
  queryParams?: GetUsersQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetUsers = (
  variables: GetUsersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetUsersResponse,
    GetUsersError,
    undefined,
    {},
    GetUsersQueryParams,
    {}
  >({ url: "/users", method: "get", ...variables, signal });

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export function getUsersQuery(variables: GetUsersVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetUsersResponse>;
};

export function getUsersQuery(
  variables: GetUsersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetUsersResponse>)
    | reactQuery.SkipToken;
};

export function getUsersQuery(
  variables: GetUsersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users",
      operationId: "getUsers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetUsers(variables, signal),
  };
}

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetUsers = <TData = GetUsersResponse,>(
  variables: GetUsersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUsersResponse, GetUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<GetUsersResponse, GetUsersError, TData>({
    ...getUsersQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all users from database as a list of `CoreUserSimple`
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetUsers = <TData = GetUsersResponse,>(
  variables: GetUsersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetUsersResponse, GetUsersError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetUsersResponse, GetUsersError, TData>({
    ...getUsersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersCountError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersCountVariables = HyperionContext["fetcherOptions"];

/**
 * Return the number of users in the database
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetUsersCount = (
  variables: GetUsersCountVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<number, GetUsersCountError, undefined, {}, {}, {}>({
    url: "/users/count",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return the number of users in the database
 *
 * **This endpoint is only usable by administrators**
 */
export function getUsersCountQuery(variables: GetUsersCountVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<number>;
};

export function getUsersCountQuery(
  variables: GetUsersCountVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<number>)
    | reactQuery.SkipToken;
};

export function getUsersCountQuery(
  variables: GetUsersCountVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/count",
      operationId: "getUsersCount",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetUsersCount(variables, signal),
  };
}

/**
 * Return the number of users in the database
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetUsersCount = <TData = number,>(
  variables: GetUsersCountVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetUsersCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<number, GetUsersCountError, TData>({
    ...getUsersCountQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return the number of users in the database
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetUsersCount = <TData = number,>(
  variables: GetUsersCountVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<number, GetUsersCountError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<number, GetUsersCountError, TData>({
    ...getUsersCountQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersSearchQueryParams = {
  query: string;
  includedAccountTypes?: Schemas.AccountType[];
  excludedAccountTypes?: Schemas.AccountType[];
  includedGroups?: string[];
  excludedGroups?: string[];
};

export type GetUsersSearchError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersSearchResponse = Schemas.CoreUserSimple[];

export type GetUsersSearchVariables = {
  queryParams: GetUsersSearchQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Search for a user using Jaro_Winkler distance algorithm.
 * The `query` will be compared against users name, firstname and nickname.
 * Assume that `query` is the beginning of a name, so we can capitalize words to improve results.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetUsersSearch = (
  variables: GetUsersSearchVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetUsersSearchResponse,
    GetUsersSearchError,
    undefined,
    {},
    GetUsersSearchQueryParams,
    {}
  >({ url: "/users/search", method: "get", ...variables, signal });

/**
 * Search for a user using Jaro_Winkler distance algorithm.
 * The `query` will be compared against users name, firstname and nickname.
 * Assume that `query` is the beginning of a name, so we can capitalize words to improve results.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getUsersSearchQuery(variables: GetUsersSearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetUsersSearchResponse>;
};

export function getUsersSearchQuery(
  variables: GetUsersSearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetUsersSearchResponse>)
    | reactQuery.SkipToken;
};

export function getUsersSearchQuery(
  variables: GetUsersSearchVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/search",
      operationId: "getUsersSearch",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUsersSearch(variables, signal),
  };
}

/**
 * Search for a user using Jaro_Winkler distance algorithm.
 * The `query` will be compared against users name, firstname and nickname.
 * Assume that `query` is the beginning of a name, so we can capitalize words to improve results.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetUsersSearch = <TData = GetUsersSearchResponse,>(
  variables: GetUsersSearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUsersSearchResponse,
      GetUsersSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetUsersSearchResponse,
    GetUsersSearchError,
    TData
  >({
    ...getUsersSearchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Search for a user using Jaro_Winkler distance algorithm.
 * The `query` will be compared against users name, firstname and nickname.
 * Assume that `query` is the beginning of a name, so we can capitalize words to improve results.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetUsersSearch = <TData = GetUsersSearchResponse,>(
  variables: GetUsersSearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUsersSearchResponse,
      GetUsersSearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetUsersSearchResponse,
    GetUsersSearchError,
    TData
  >({
    ...getUsersSearchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersAccountTypesError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersAccountTypesResponse = Schemas.AccountType[];

export type GetUsersAccountTypesVariables = HyperionContext["fetcherOptions"];

/**
 * Return all account types hardcoded in the system
 */
export const fetchGetUsersAccountTypes = (
  variables: GetUsersAccountTypesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetUsersAccountTypesResponse,
    GetUsersAccountTypesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/users/account-types", method: "get", ...variables, signal });

/**
 * Return all account types hardcoded in the system
 */
export function getUsersAccountTypesQuery(
  variables: GetUsersAccountTypesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetUsersAccountTypesResponse>;
};

export function getUsersAccountTypesQuery(
  variables: GetUsersAccountTypesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetUsersAccountTypesResponse>)
    | reactQuery.SkipToken;
};

export function getUsersAccountTypesQuery(
  variables: GetUsersAccountTypesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/account-types",
      operationId: "getUsersAccountTypes",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUsersAccountTypes(variables, signal),
  };
}

/**
 * Return all account types hardcoded in the system
 */
export const useSuspenseGetUsersAccountTypes = <
  TData = GetUsersAccountTypesResponse,
>(
  variables: GetUsersAccountTypesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUsersAccountTypesResponse,
      GetUsersAccountTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetUsersAccountTypesResponse,
    GetUsersAccountTypesError,
    TData
  >({
    ...getUsersAccountTypesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all account types hardcoded in the system
 */
export const useGetUsersAccountTypes = <TData = GetUsersAccountTypesResponse,>(
  variables: GetUsersAccountTypesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetUsersAccountTypesResponse,
      GetUsersAccountTypesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetUsersAccountTypesResponse,
    GetUsersAccountTypesError,
    TData
  >({
    ...getUsersAccountTypesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetUsersMeError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersMeVariables = HyperionContext["fetcherOptions"];

/**
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetUsersMe = (
  variables: GetUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<Schemas.CoreUser, GetUsersMeError, undefined, {}, {}, {}>({
    url: "/users/me",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getUsersMeQuery(variables: GetUsersMeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CoreUser>;
};

export function getUsersMeQuery(
  variables: GetUsersMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CoreUser>)
    | reactQuery.SkipToken;
};

export function getUsersMeQuery(
  variables: GetUsersMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/me",
      operationId: "getUsersMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetUsersMe(variables, signal),
  };
}

/**
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetUsersMe = <TData = Schemas.CoreUser,>(
  variables: GetUsersMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreUser, GetUsersMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<Schemas.CoreUser, GetUsersMeError, TData>({
    ...getUsersMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return `CoreUser` representation of current user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetUsersMe = <TData = Schemas.CoreUser,>(
  variables: GetUsersMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreUser, GetUsersMeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CoreUser, GetUsersMeError, TData>({
    ...getUsersMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchUsersMeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchUsersMeVariables = {
  body?: Schemas.CoreUserUpdate;
} & HyperionContext["fetcherOptions"];

/**
 * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPatchUsersMe = (
  variables: PatchUsersMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchUsersMeError,
    Schemas.CoreUserUpdate,
    {},
    {},
    {}
  >({ url: "/users/me", method: "patch", ...variables, signal });

/**
 * Update the current user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePatchUsersMe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchUsersMeError,
      PatchUsersMeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchUsersMeError,
    PatchUsersMeVariables
  >({
    mutationFn: (variables: PatchUsersMeVariables) =>
      fetchPatchUsersMe(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersCreateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersCreateVariables = {
  body: Schemas.CoreUserCreateRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Start the user account creation process. The user will be sent an email with a link to activate his account.
 * > The received token needs to be sent to the `/users/activate` endpoint to activate the account.
 *
 * If the **password** is not provided, it will be required during the activation process. Don't submit a password if you are creating an account for someone else.
 *
 * When creating **student** or **staff** account a valid ECL email is required.
 * Only admin users can create other **account types**, contact ÉCLAIR for more information.
 */
export const fetchPostUsersCreate = (
  variables: PostUsersCreateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersCreateError,
    Schemas.CoreUserCreateRequest,
    {},
    {},
    {}
  >({ url: "/users/create", method: "post", ...variables, signal });

/**
 * Start the user account creation process. The user will be sent an email with a link to activate his account.
 * > The received token needs to be sent to the `/users/activate` endpoint to activate the account.
 *
 * If the **password** is not provided, it will be required during the activation process. Don't submit a password if you are creating an account for someone else.
 *
 * When creating **student** or **staff** account a valid ECL email is required.
 * Only admin users can create other **account types**, contact ÉCLAIR for more information.
 */
export const usePostUsersCreate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersCreateError,
      PostUsersCreateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersCreateError,
    PostUsersCreateVariables
  >({
    mutationFn: (variables: PostUsersCreateVariables) =>
      fetchPostUsersCreate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersBatchCreationError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersBatchCreationRequestBody =
  Schemas.CoreBatchUserCreateRequest[];

export type PostUsersBatchCreationVariables = {
  body?: PostUsersBatchCreationRequestBody;
} & HyperionContext["fetcherOptions"];

/**
 * Batch user account creation process. All users will be sent an email with a link to activate their account.
 * > The received token needs to be send to `/users/activate` endpoint to activate the account.
 *
 * Even for creating **student** or **staff** account a valid ECL email is not required but should preferably be used.
 *
 * The endpoint return a dictionary of unsuccessful user creation: `{email: error message}`.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostUsersBatchCreation = (
  variables: PostUsersBatchCreationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.BatchResult,
    PostUsersBatchCreationError,
    PostUsersBatchCreationRequestBody,
    {},
    {},
    {}
  >({ url: "/users/batch-creation", method: "post", ...variables, signal });

/**
 * Batch user account creation process. All users will be sent an email with a link to activate their account.
 * > The received token needs to be send to `/users/activate` endpoint to activate the account.
 *
 * Even for creating **student** or **staff** account a valid ECL email is not required but should preferably be used.
 *
 * The endpoint return a dictionary of unsuccessful user creation: `{email: error message}`.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostUsersBatchCreation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.BatchResult,
      PostUsersBatchCreationError,
      PostUsersBatchCreationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.BatchResult,
    PostUsersBatchCreationError,
    PostUsersBatchCreationVariables
  >({
    mutationFn: (variables: PostUsersBatchCreationVariables) =>
      fetchPostUsersBatchCreation(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersActivateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersActivateVariables = {
  body: Schemas.CoreUserActivateRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Activate the previously created account.
 *
 * **token**: the activation token sent by email to the user
 *
 * **password**: user password, required if it was not provided previously
 */
export const fetchPostUsersActivate = (
  variables: PostUsersActivateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersActivateError,
    Schemas.CoreUserActivateRequest,
    {},
    {},
    {}
  >({ url: "/users/activate", method: "post", ...variables, signal });

/**
 * Activate the previously created account.
 *
 * **token**: the activation token sent by email to the user
 *
 * **password**: user password, required if it was not provided previously
 */
export const usePostUsersActivate = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersActivateError,
      PostUsersActivateVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersActivateError,
    PostUsersActivateVariables
  >({
    mutationFn: (variables: PostUsersActivateVariables) =>
      fetchPostUsersActivate(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersS3InitError = Fetcher.ErrorWrapper<undefined>;

export type PostUsersS3InitVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint is used to initialize the S3 bucket for users.
 * It will create a file for each existing user in the S3 bucket.
 * It should be used only once, when the S3 bucket is created.
 */
export const fetchPostUsersS3Init = (
  variables: PostUsersS3InitVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, PostUsersS3InitError, undefined, {}, {}, {}>({
    url: "/users/s3-init",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint is used to initialize the S3 bucket for users.
 * It will create a file for each existing user in the S3 bucket.
 * It should be used only once, when the S3 bucket is created.
 */
export const usePostUsersS3Init = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostUsersS3InitError,
      PostUsersS3InitVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostUsersS3InitError,
    PostUsersS3InitVariables
  >({
    mutationFn: (variables: PostUsersS3InitVariables) =>
      fetchPostUsersS3Init(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersMakeAdminError = Fetcher.ErrorWrapper<undefined>;

export type PostUsersMakeAdminVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint is only usable if the database contains exactly one user.
 * It will add this user to the `admin` group.
 */
export const fetchPostUsersMakeAdmin = (
  variables: PostUsersMakeAdminVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersMakeAdminError,
    undefined,
    {},
    {},
    {}
  >({ url: "/users/make-admin", method: "post", ...variables, signal });

/**
 * This endpoint is only usable if the database contains exactly one user.
 * It will add this user to the `admin` group.
 */
export const usePostUsersMakeAdmin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersMakeAdminError,
      PostUsersMakeAdminVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersMakeAdminError,
    PostUsersMakeAdminVariables
  >({
    mutationFn: (variables: PostUsersMakeAdminVariables) =>
      fetchPostUsersMakeAdmin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersRecoverError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersRecoverVariables = {
  body: Schemas.BodyRecoverUserUsersRecoverPost;
} & HyperionContext["fetcherOptions"];

/**
 * Allow a user to start a password reset process.
 *
 * If the provided **email** corresponds to an existing account, a password reset token will be sent.
 * Using this token, the password can be changed with `/users/reset-password` endpoint
 */
export const fetchPostUsersRecover = (
  variables: PostUsersRecoverVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersRecoverError,
    Schemas.BodyRecoverUserUsersRecoverPost,
    {},
    {},
    {}
  >({ url: "/users/recover", method: "post", ...variables, signal });

/**
 * Allow a user to start a password reset process.
 *
 * If the provided **email** corresponds to an existing account, a password reset token will be sent.
 * Using this token, the password can be changed with `/users/reset-password` endpoint
 */
export const usePostUsersRecover = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersRecoverError,
      PostUsersRecoverVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersRecoverError,
    PostUsersRecoverVariables
  >({
    mutationFn: (variables: PostUsersRecoverVariables) =>
      fetchPostUsersRecover(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersResetPasswordError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersResetPasswordVariables = {
  body: Schemas.ResetPasswordRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
 */
export const fetchPostUsersResetPassword = (
  variables: PostUsersResetPasswordVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersResetPasswordError,
    Schemas.ResetPasswordRequest,
    {},
    {},
    {}
  >({ url: "/users/reset-password", method: "post", ...variables, signal });

/**
 * Reset the user password, using a **reset_token** provided by `/users/recover` endpoint.
 */
export const usePostUsersResetPassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersResetPasswordError,
      PostUsersResetPasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersResetPasswordError,
    PostUsersResetPasswordVariables
  >({
    mutationFn: (variables: PostUsersResetPasswordVariables) =>
      fetchPostUsersResetPassword(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersMigrateMailError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersMigrateMailVariables = {
  body: Schemas.MailMigrationRequest;
} & HyperionContext["fetcherOptions"];

/**
 * This endpoint will send a confirmation code to the user's new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
 */
export const fetchPostUsersMigrateMail = (
  variables: PostUsersMigrateMailVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostUsersMigrateMailError,
    Schemas.MailMigrationRequest,
    {},
    {},
    {}
  >({ url: "/users/migrate-mail", method: "post", ...variables, signal });

/**
 * This endpoint will send a confirmation code to the user's new email address. He will need to use this code to confirm the change with `/users/confirm-mail-migration` endpoint.
 */
export const usePostUsersMigrateMail = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostUsersMigrateMailError,
      PostUsersMigrateMailVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostUsersMigrateMailError,
    PostUsersMigrateMailVariables
  >({
    mutationFn: (variables: PostUsersMigrateMailVariables) =>
      fetchPostUsersMigrateMail(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUsersMigrateMailConfirmQueryParams = {
  token: string;
};

export type GetUsersMigrateMailConfirmError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersMigrateMailConfirmVariables = {
  queryParams: GetUsersMigrateMailConfirmQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * This endpoint will updates the user new email address.
 * The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
 */
export const fetchGetUsersMigrateMailConfirm = (
  variables: GetUsersMigrateMailConfirmVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetUsersMigrateMailConfirmError,
    undefined,
    {},
    GetUsersMigrateMailConfirmQueryParams,
    {}
  >({
    url: "/users/migrate-mail-confirm",
    method: "get",
    ...variables,
    signal,
  });

/**
 * This endpoint will updates the user new email address.
 * The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
 */
export function getUsersMigrateMailConfirmQuery(
  variables: GetUsersMigrateMailConfirmVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getUsersMigrateMailConfirmQuery(
  variables: GetUsersMigrateMailConfirmVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getUsersMigrateMailConfirmQuery(
  variables: GetUsersMigrateMailConfirmVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/migrate-mail-confirm",
      operationId: "getUsersMigrateMailConfirm",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUsersMigrateMailConfirm(variables, signal),
  };
}

/**
 * This endpoint will updates the user new email address.
 * The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
 */
export const useSuspenseGetUsersMigrateMailConfirm = <TData = void,>(
  variables: GetUsersMigrateMailConfirmVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetUsersMigrateMailConfirmError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetUsersMigrateMailConfirmError,
    TData
  >({
    ...getUsersMigrateMailConfirmQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint will updates the user new email address.
 * The user will need to use the confirmation code sent by the `/users/migrate-mail` endpoint.
 */
export const useGetUsersMigrateMailConfirm = <TData = void,>(
  variables: GetUsersMigrateMailConfirmVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetUsersMigrateMailConfirmError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetUsersMigrateMailConfirmError, TData>({
    ...getUsersMigrateMailConfirmQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostUsersChangePasswordError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersChangePasswordVariables = {
  body: Schemas.ChangePasswordRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Change a user password.
 *
 * This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
 */
export const fetchPostUsersChangePassword = (
  variables: PostUsersChangePasswordVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersChangePasswordError,
    Schemas.ChangePasswordRequest,
    {},
    {},
    {}
  >({ url: "/users/change-password", method: "post", ...variables, signal });

/**
 * Change a user password.
 *
 * This endpoint will check the **old_password**, see also the `/users/reset-password` endpoint if the user forgot their password.
 */
export const usePostUsersChangePassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersChangePasswordError,
      PostUsersChangePasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersChangePasswordError,
    PostUsersChangePasswordVariables
  >({
    mutationFn: (variables: PostUsersChangePasswordVariables) =>
      fetchPostUsersChangePassword(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUsersUserIdPathParams = {
  userId: string;
};

export type GetUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersUserIdVariables = {
  pathParams: GetUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return `CoreUser` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetUsersUserId = (
  variables: GetUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreUser,
    GetUsersUserIdError,
    undefined,
    {},
    {},
    GetUsersUserIdPathParams
  >({ url: "/users/{userId}", method: "get", ...variables, signal });

/**
 * Return `CoreUser` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getUsersUserIdQuery(variables: GetUsersUserIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CoreUser>;
};

export function getUsersUserIdQuery(
  variables: GetUsersUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CoreUser>)
    | reactQuery.SkipToken;
};

export function getUsersUserIdQuery(
  variables: GetUsersUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/{userId}",
      operationId: "getUsersUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUsersUserId(variables, signal),
  };
}

/**
 * Return `CoreUser` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetUsersUserId = <TData = Schemas.CoreUser,>(
  variables: GetUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreUser, GetUsersUserIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CoreUser,
    GetUsersUserIdError,
    TData
  >({
    ...getUsersUserIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return `CoreUser` representation of user with id `user_id`
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetUsersUserId = <TData = Schemas.CoreUser,>(
  variables: GetUsersUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreUser, GetUsersUserIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CoreUser, GetUsersUserIdError, TData>({
    ...getUsersUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchUsersUserIdPathParams = {
  userId: string;
};

export type PatchUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchUsersUserIdVariables = {
  body?: Schemas.CoreUserUpdateAdmin;
  pathParams: PatchUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchUsersUserId = (
  variables: PatchUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchUsersUserIdError,
    Schemas.CoreUserUpdateAdmin,
    {},
    {},
    PatchUsersUserIdPathParams
  >({ url: "/users/{userId}", method: "patch", ...variables, signal });

/**
 * Update an user, the request should contain a JSON with the fields to change (not necessarily all fields) and their new value
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchUsersUserIdError,
      PatchUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchUsersUserIdError,
    PatchUsersUserIdVariables
  >({
    mutationFn: (variables: PatchUsersUserIdVariables) =>
      fetchPatchUsersUserId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersMeAskDeletionError = Fetcher.ErrorWrapper<undefined>;

export type PostUsersMeAskDeletionVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint will ask administrators to process to the user deletion.
 * This manual verification is needed to prevent data from being deleting for other users
 */
export const fetchPostUsersMeAskDeletion = (
  variables: PostUsersMeAskDeletionVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostUsersMeAskDeletionError, undefined, {}, {}, {}>({
    url: "/users/me/ask-deletion",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint will ask administrators to process to the user deletion.
 * This manual verification is needed to prevent data from being deleting for other users
 */
export const usePostUsersMeAskDeletion = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostUsersMeAskDeletionError,
      PostUsersMeAskDeletionVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostUsersMeAskDeletionError,
    PostUsersMeAskDeletionVariables
  >({
    mutationFn: (variables: PostUsersMeAskDeletionVariables) =>
      fetchPostUsersMeAskDeletion(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostUsersMergeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersMergeVariables = {
  body: Schemas.CoreUserFusionRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Fusion two users into one. The first user will be deleted and its data will be transferred to the second user.
 */
export const fetchPostUsersMerge = (
  variables: PostUsersMergeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostUsersMergeError,
    Schemas.CoreUserFusionRequest,
    {},
    {},
    {}
  >({ url: "/users/merge", method: "post", ...variables, signal });

/**
 * Fusion two users into one. The first user will be deleted and its data will be transferred to the second user.
 */
export const usePostUsersMerge = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostUsersMergeError,
      PostUsersMergeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostUsersMergeError,
    PostUsersMergeVariables
  >({
    mutationFn: (variables: PostUsersMergeVariables) =>
      fetchPostUsersMerge(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUsersMeProfilePictureError = Fetcher.ErrorWrapper<undefined>;

export type GetUsersMeProfilePictureVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get the profile picture of the authenticated user.
 */
export const fetchGetUsersMeProfilePicture = (
  variables: GetUsersMeProfilePictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetUsersMeProfilePictureError,
    undefined,
    {},
    {},
    {}
  >({ url: "/users/me/profile-picture", method: "get", ...variables, signal });

/**
 * Get the profile picture of the authenticated user.
 */
export function getUsersMeProfilePictureQuery(
  variables: GetUsersMeProfilePictureVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getUsersMeProfilePictureQuery(
  variables: GetUsersMeProfilePictureVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getUsersMeProfilePictureQuery(
  variables: GetUsersMeProfilePictureVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/me/profile-picture",
      operationId: "getUsersMeProfilePicture",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUsersMeProfilePicture(variables, signal),
  };
}

/**
 * Get the profile picture of the authenticated user.
 */
export const useSuspenseGetUsersMeProfilePicture = <TData = undefined,>(
  variables: GetUsersMeProfilePictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetUsersMeProfilePictureError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetUsersMeProfilePictureError,
    TData
  >({
    ...getUsersMeProfilePictureQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the profile picture of the authenticated user.
 */
export const useGetUsersMeProfilePicture = <TData = undefined,>(
  variables: GetUsersMeProfilePictureVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetUsersMeProfilePictureError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetUsersMeProfilePictureError, TData>({
    ...getUsersMeProfilePictureQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostUsersMeProfilePictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostUsersMeProfilePictureVariables = {
  body: Schemas.BodyCreateCurrentUserProfilePictureUsersMeProfilePicturePost;
} & HyperionContext["fetcherOptions"];

/**
 * Upload a profile picture for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostUsersMeProfilePicture = (
  variables: PostUsersMeProfilePictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersMeProfilePictureError,
    Schemas.BodyCreateCurrentUserProfilePictureUsersMeProfilePicturePost,
    {},
    {},
    {}
  >({ url: "/users/me/profile-picture", method: "post", ...variables, signal });

/**
 * Upload a profile picture for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostUsersMeProfilePicture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostUsersMeProfilePictureError,
      PostUsersMeProfilePictureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostUsersMeProfilePictureError,
    PostUsersMeProfilePictureVariables
  >({
    mutationFn: (variables: PostUsersMeProfilePictureVariables) =>
      fetchPostUsersMeProfilePicture(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetUsersUserIdProfilePicturePathParams = {
  userId: string;
};

export type GetUsersUserIdProfilePictureError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetUsersUserIdProfilePictureVariables = {
  pathParams: GetUsersUserIdProfilePicturePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export const fetchGetUsersUserIdProfilePicture = (
  variables: GetUsersUserIdProfilePictureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetUsersUserIdProfilePictureError,
    undefined,
    {},
    {},
    GetUsersUserIdProfilePicturePathParams
  >({
    url: "/users/{userId}/profile-picture",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export function getUsersUserIdProfilePictureQuery(
  variables: GetUsersUserIdProfilePictureVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getUsersUserIdProfilePictureQuery(
  variables: GetUsersUserIdProfilePictureVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getUsersUserIdProfilePictureQuery(
  variables: GetUsersUserIdProfilePictureVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/users/{userId}/profile-picture",
      operationId: "getUsersUserIdProfilePicture",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetUsersUserIdProfilePicture(variables, signal),
  };
}

/**
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export const useSuspenseGetUsersUserIdProfilePicture = <TData = undefined,>(
  variables: GetUsersUserIdProfilePictureVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetUsersUserIdProfilePictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetUsersUserIdProfilePictureError,
    TData
  >({
    ...getUsersUserIdProfilePictureQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the profile picture of an user.
 *
 * Unauthenticated users can use this endpoint (needed for some OIDC services)
 */
export const useGetUsersUserIdProfilePicture = <TData = undefined,>(
  variables: GetUsersUserIdProfilePictureVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetUsersUserIdProfilePictureError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    undefined,
    GetUsersUserIdProfilePictureError,
    TData
  >({
    ...getUsersUserIdProfilePictureQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetMyeclpayStructuresError = Fetcher.ErrorWrapper<undefined>;

export type GetMyeclpayStructuresResponse = Schemas.Structure[];

export type GetMyeclpayStructuresVariables = HyperionContext["fetcherOptions"];

/**
 * Get all structures.
 */
export const fetchGetMyeclpayStructures = (
  variables: GetMyeclpayStructuresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMyeclpayStructuresResponse,
    GetMyeclpayStructuresError,
    undefined,
    {},
    {},
    {}
  >({ url: "/myeclpay/structures", method: "get", ...variables, signal });

/**
 * Get all structures.
 */
export function getMyeclpayStructuresQuery(
  variables: GetMyeclpayStructuresVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetMyeclpayStructuresResponse>;
};

export function getMyeclpayStructuresQuery(
  variables: GetMyeclpayStructuresVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetMyeclpayStructuresResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayStructuresQuery(
  variables: GetMyeclpayStructuresVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/structures",
      operationId: "getMyeclpayStructures",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayStructures(variables, signal),
  };
}

/**
 * Get all structures.
 */
export const useSuspenseGetMyeclpayStructures = <
  TData = GetMyeclpayStructuresResponse,
>(
  variables: GetMyeclpayStructuresVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayStructuresResponse,
      GetMyeclpayStructuresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMyeclpayStructuresResponse,
    GetMyeclpayStructuresError,
    TData
  >({
    ...getMyeclpayStructuresQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all structures.
 */
export const useGetMyeclpayStructures = <
  TData = GetMyeclpayStructuresResponse,
>(
  variables: GetMyeclpayStructuresVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayStructuresResponse,
      GetMyeclpayStructuresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMyeclpayStructuresResponse,
    GetMyeclpayStructuresError,
    TData
  >({
    ...getMyeclpayStructuresQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayStructuresError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayStructuresVariables = {
  body: Schemas.StructureBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new structure.
 *
 * A structure contains:
 *  - a name
 *  - an association membership id
 *  - a manager user id
 *  - a list of stores
 *
 * **The user must be an admin to use this endpoint**
 */
export const fetchPostMyeclpayStructures = (
  variables: PostMyeclpayStructuresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Structure,
    PostMyeclpayStructuresError,
    Schemas.StructureBase,
    {},
    {},
    {}
  >({ url: "/myeclpay/structures", method: "post", ...variables, signal });

/**
 * Create a new structure.
 *
 * A structure contains:
 *  - a name
 *  - an association membership id
 *  - a manager user id
 *  - a list of stores
 *
 * **The user must be an admin to use this endpoint**
 */
export const usePostMyeclpayStructures = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Structure,
      PostMyeclpayStructuresError,
      PostMyeclpayStructuresVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Structure,
    PostMyeclpayStructuresError,
    PostMyeclpayStructuresVariables
  >({
    mutationFn: (variables: PostMyeclpayStructuresVariables) =>
      fetchPostMyeclpayStructures(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PatchMyeclpayStructuresStructureIdPathParams = {
  /**
   * @format uuid
   */
  structureId: string;
};

export type PatchMyeclpayStructuresStructureIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchMyeclpayStructuresStructureIdVariables = {
  body?: Schemas.StructureUpdate;
  pathParams: PatchMyeclpayStructuresStructureIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a structure.
 *
 * **The user must be an admin to use this endpoint**
 */
export const fetchPatchMyeclpayStructuresStructureId = (
  variables: PatchMyeclpayStructuresStructureIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchMyeclpayStructuresStructureIdError,
    Schemas.StructureUpdate,
    {},
    {},
    PatchMyeclpayStructuresStructureIdPathParams
  >({
    url: "/myeclpay/structures/{structureId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a structure.
 *
 * **The user must be an admin to use this endpoint**
 */
export const usePatchMyeclpayStructuresStructureId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchMyeclpayStructuresStructureIdError,
      PatchMyeclpayStructuresStructureIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchMyeclpayStructuresStructureIdError,
    PatchMyeclpayStructuresStructureIdVariables
  >({
    mutationFn: (variables: PatchMyeclpayStructuresStructureIdVariables) =>
      fetchPatchMyeclpayStructuresStructureId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteMyeclpayStructuresStructureIdPathParams = {
  /**
   * @format uuid
   */
  structureId: string;
};

export type DeleteMyeclpayStructuresStructureIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteMyeclpayStructuresStructureIdVariables = {
  pathParams: DeleteMyeclpayStructuresStructureIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a structure. Only structures without stores can be deleted.
 *
 * **The user must be an admin to use this endpoint**
 */
export const fetchDeleteMyeclpayStructuresStructureId = (
  variables: DeleteMyeclpayStructuresStructureIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteMyeclpayStructuresStructureIdError,
    undefined,
    {},
    {},
    DeleteMyeclpayStructuresStructureIdPathParams
  >({
    url: "/myeclpay/structures/{structureId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a structure. Only structures without stores can be deleted.
 *
 * **The user must be an admin to use this endpoint**
 */
export const useDeleteMyeclpayStructuresStructureId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteMyeclpayStructuresStructureIdError,
      DeleteMyeclpayStructuresStructureIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteMyeclpayStructuresStructureIdError,
    DeleteMyeclpayStructuresStructureIdVariables
  >({
    mutationFn: (variables: DeleteMyeclpayStructuresStructureIdVariables) =>
      fetchDeleteMyeclpayStructuresStructureId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostMyeclpayStructuresStructureIdInitManagerTransferPathParams = {
  /**
   * @format uuid
   */
  structureId: string;
};

export type PostMyeclpayStructuresStructureIdInitManagerTransferError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostMyeclpayStructuresStructureIdInitManagerTransferVariables = {
  body: Schemas.StructureTranfert;
  pathParams: PostMyeclpayStructuresStructureIdInitManagerTransferPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Initiate the transfer of a structure to a new manager. The current manager will receive an email with a link to confirm the transfer.
 * The link will only be valid for a limited time.
 *
 * **The user must be the manager for this structure**
 */
export const fetchPostMyeclpayStructuresStructureIdInitManagerTransfer = (
  variables: PostMyeclpayStructuresStructureIdInitManagerTransferVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostMyeclpayStructuresStructureIdInitManagerTransferError,
    Schemas.StructureTranfert,
    {},
    {},
    PostMyeclpayStructuresStructureIdInitManagerTransferPathParams
  >({
    url: "/myeclpay/structures/{structureId}/init-manager-transfer",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Initiate the transfer of a structure to a new manager. The current manager will receive an email with a link to confirm the transfer.
 * The link will only be valid for a limited time.
 *
 * **The user must be the manager for this structure**
 */
export const usePostMyeclpayStructuresStructureIdInitManagerTransfer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostMyeclpayStructuresStructureIdInitManagerTransferError,
      PostMyeclpayStructuresStructureIdInitManagerTransferVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostMyeclpayStructuresStructureIdInitManagerTransferError,
    PostMyeclpayStructuresStructureIdInitManagerTransferVariables
  >({
    mutationFn: (
      variables: PostMyeclpayStructuresStructureIdInitManagerTransferVariables,
    ) =>
      fetchPostMyeclpayStructuresStructureIdInitManagerTransfer(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMyeclpayStructuresConfirmManagerTransferQueryParams = {
  token: string;
};

export type GetMyeclpayStructuresConfirmManagerTransferError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetMyeclpayStructuresConfirmManagerTransferVariables = {
  queryParams: GetMyeclpayStructuresConfirmManagerTransferQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a manager for an association
 *
 * The user must have initiated the update of the manager with `init_update_structure_manager`
 */
export const fetchGetMyeclpayStructuresConfirmManagerTransfer = (
  variables: GetMyeclpayStructuresConfirmManagerTransferVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetMyeclpayStructuresConfirmManagerTransferError,
    undefined,
    {},
    GetMyeclpayStructuresConfirmManagerTransferQueryParams,
    {}
  >({
    url: "/myeclpay/structures/confirm-manager-transfer",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Update a manager for an association
 *
 * The user must have initiated the update of the manager with `init_update_structure_manager`
 */
export function getMyeclpayStructuresConfirmManagerTransferQuery(
  variables: GetMyeclpayStructuresConfirmManagerTransferVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getMyeclpayStructuresConfirmManagerTransferQuery(
  variables:
    | GetMyeclpayStructuresConfirmManagerTransferVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getMyeclpayStructuresConfirmManagerTransferQuery(
  variables:
    | GetMyeclpayStructuresConfirmManagerTransferVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/structures/confirm-manager-transfer",
      operationId: "getMyeclpayStructuresConfirmManagerTransfer",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayStructuresConfirmManagerTransfer(variables, signal),
  };
}

/**
 * Update a manager for an association
 *
 * The user must have initiated the update of the manager with `init_update_structure_manager`
 */
export const useSuspenseGetMyeclpayStructuresConfirmManagerTransfer = <
  TData = void,
>(
  variables: GetMyeclpayStructuresConfirmManagerTransferVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetMyeclpayStructuresConfirmManagerTransferError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetMyeclpayStructuresConfirmManagerTransferError,
    TData
  >({
    ...getMyeclpayStructuresConfirmManagerTransferQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Update a manager for an association
 *
 * The user must have initiated the update of the manager with `init_update_structure_manager`
 */
export const useGetMyeclpayStructuresConfirmManagerTransfer = <TData = void,>(
  variables:
    | GetMyeclpayStructuresConfirmManagerTransferVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetMyeclpayStructuresConfirmManagerTransferError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    void,
    GetMyeclpayStructuresConfirmManagerTransferError,
    TData
  >({
    ...getMyeclpayStructuresConfirmManagerTransferQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayStructuresStructureIdStoresPathParams = {
  /**
   * @format uuid
   */
  structureId: string;
};

export type PostMyeclpayStructuresStructureIdStoresError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostMyeclpayStructuresStructureIdStoresVariables = {
  body: Schemas.StoreBase;
  pathParams: PostMyeclpayStructuresStructureIdStoresPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a store. The structure manager will be added as a seller for the store.
 *
 * Stores name should be unique, as an user need to be able to identify a store by its name.
 *
 * **The user must be the manager for this structure**
 */
export const fetchPostMyeclpayStructuresStructureIdStores = (
  variables: PostMyeclpayStructuresStructureIdStoresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Store,
    PostMyeclpayStructuresStructureIdStoresError,
    Schemas.StoreBase,
    {},
    {},
    PostMyeclpayStructuresStructureIdStoresPathParams
  >({
    url: "/myeclpay/structures/{structureId}/stores",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a store. The structure manager will be added as a seller for the store.
 *
 * Stores name should be unique, as an user need to be able to identify a store by its name.
 *
 * **The user must be the manager for this structure**
 */
export const usePostMyeclpayStructuresStructureIdStores = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Store,
      PostMyeclpayStructuresStructureIdStoresError,
      PostMyeclpayStructuresStructureIdStoresVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Store,
    PostMyeclpayStructuresStructureIdStoresError,
    PostMyeclpayStructuresStructureIdStoresVariables
  >({
    mutationFn: (variables: PostMyeclpayStructuresStructureIdStoresVariables) =>
      fetchPostMyeclpayStructuresStructureIdStores(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMyeclpayStoresStoreIdHistoryPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type GetMyeclpayStoresStoreIdHistoryQueryParams = {
  start_date?: string | null;
  end_date?: string | null;
};

export type GetMyeclpayStoresStoreIdHistoryError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMyeclpayStoresStoreIdHistoryResponse = Schemas.History[];

export type GetMyeclpayStoresStoreIdHistoryVariables = {
  pathParams: GetMyeclpayStoresStoreIdHistoryPathParams;
  queryParams?: GetMyeclpayStoresStoreIdHistoryQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get all transactions for the store.
 *
 * **The user must be authorized to see the store history**
 */
export const fetchGetMyeclpayStoresStoreIdHistory = (
  variables: GetMyeclpayStoresStoreIdHistoryVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMyeclpayStoresStoreIdHistoryResponse,
    GetMyeclpayStoresStoreIdHistoryError,
    undefined,
    {},
    GetMyeclpayStoresStoreIdHistoryQueryParams,
    GetMyeclpayStoresStoreIdHistoryPathParams
  >({
    url: "/myeclpay/stores/{storeId}/history",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all transactions for the store.
 *
 * **The user must be authorized to see the store history**
 */
export function getMyeclpayStoresStoreIdHistoryQuery(
  variables: GetMyeclpayStoresStoreIdHistoryVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMyeclpayStoresStoreIdHistoryResponse>;
};

export function getMyeclpayStoresStoreIdHistoryQuery(
  variables: GetMyeclpayStoresStoreIdHistoryVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetMyeclpayStoresStoreIdHistoryResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayStoresStoreIdHistoryQuery(
  variables: GetMyeclpayStoresStoreIdHistoryVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/stores/{storeId}/history",
      operationId: "getMyeclpayStoresStoreIdHistory",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayStoresStoreIdHistory(variables, signal),
  };
}

/**
 * Get all transactions for the store.
 *
 * **The user must be authorized to see the store history**
 */
export const useSuspenseGetMyeclpayStoresStoreIdHistory = <
  TData = GetMyeclpayStoresStoreIdHistoryResponse,
>(
  variables: GetMyeclpayStoresStoreIdHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayStoresStoreIdHistoryResponse,
      GetMyeclpayStoresStoreIdHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMyeclpayStoresStoreIdHistoryResponse,
    GetMyeclpayStoresStoreIdHistoryError,
    TData
  >({
    ...getMyeclpayStoresStoreIdHistoryQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all transactions for the store.
 *
 * **The user must be authorized to see the store history**
 */
export const useGetMyeclpayStoresStoreIdHistory = <
  TData = GetMyeclpayStoresStoreIdHistoryResponse,
>(
  variables: GetMyeclpayStoresStoreIdHistoryVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayStoresStoreIdHistoryResponse,
      GetMyeclpayStoresStoreIdHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMyeclpayStoresStoreIdHistoryResponse,
    GetMyeclpayStoresStoreIdHistoryError,
    TData
  >({
    ...getMyeclpayStoresStoreIdHistoryQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetMyeclpayUsersMeStoresError = Fetcher.ErrorWrapper<undefined>;

export type GetMyeclpayUsersMeStoresResponse = Schemas.UserStore[];

export type GetMyeclpayUsersMeStoresVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get all stores for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetMyeclpayUsersMeStores = (
  variables: GetMyeclpayUsersMeStoresVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMyeclpayUsersMeStoresResponse,
    GetMyeclpayUsersMeStoresError,
    undefined,
    {},
    {},
    {}
  >({ url: "/myeclpay/users/me/stores", method: "get", ...variables, signal });

/**
 * Get all stores for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getMyeclpayUsersMeStoresQuery(
  variables: GetMyeclpayUsersMeStoresVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMyeclpayUsersMeStoresResponse>;
};

export function getMyeclpayUsersMeStoresQuery(
  variables: GetMyeclpayUsersMeStoresVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetMyeclpayUsersMeStoresResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayUsersMeStoresQuery(
  variables: GetMyeclpayUsersMeStoresVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/users/me/stores",
      operationId: "getMyeclpayUsersMeStores",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayUsersMeStores(variables, signal),
  };
}

/**
 * Get all stores for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetMyeclpayUsersMeStores = <
  TData = GetMyeclpayUsersMeStoresResponse,
>(
  variables: GetMyeclpayUsersMeStoresVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayUsersMeStoresResponse,
      GetMyeclpayUsersMeStoresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMyeclpayUsersMeStoresResponse,
    GetMyeclpayUsersMeStoresError,
    TData
  >({
    ...getMyeclpayUsersMeStoresQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all stores for the current user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetMyeclpayUsersMeStores = <
  TData = GetMyeclpayUsersMeStoresResponse,
>(
  variables: GetMyeclpayUsersMeStoresVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayUsersMeStoresResponse,
      GetMyeclpayUsersMeStoresError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMyeclpayUsersMeStoresResponse,
    GetMyeclpayUsersMeStoresError,
    TData
  >({
    ...getMyeclpayUsersMeStoresQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchMyeclpayStoresStoreIdPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type PatchMyeclpayStoresStoreIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchMyeclpayStoresStoreIdVariables = {
  body?: Schemas.StoreUpdate;
  pathParams: PatchMyeclpayStoresStoreIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a store
 *
 * **The user must be the manager for this store's structure**
 */
export const fetchPatchMyeclpayStoresStoreId = (
  variables: PatchMyeclpayStoresStoreIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchMyeclpayStoresStoreIdError,
    Schemas.StoreUpdate,
    {},
    {},
    PatchMyeclpayStoresStoreIdPathParams
  >({
    url: "/myeclpay/stores/{storeId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a store
 *
 * **The user must be the manager for this store's structure**
 */
export const usePatchMyeclpayStoresStoreId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchMyeclpayStoresStoreIdError,
      PatchMyeclpayStoresStoreIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchMyeclpayStoresStoreIdError,
    PatchMyeclpayStoresStoreIdVariables
  >({
    mutationFn: (variables: PatchMyeclpayStoresStoreIdVariables) =>
      fetchPatchMyeclpayStoresStoreId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteMyeclpayStoresStoreIdPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type DeleteMyeclpayStoresStoreIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteMyeclpayStoresStoreIdVariables = {
  pathParams: DeleteMyeclpayStoresStoreIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a store. Only stores without transactions can be deleted.
 *
 * **The user must be the manager for this store's structure**
 */
export const fetchDeleteMyeclpayStoresStoreId = (
  variables: DeleteMyeclpayStoresStoreIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteMyeclpayStoresStoreIdError,
    undefined,
    {},
    {},
    DeleteMyeclpayStoresStoreIdPathParams
  >({
    url: "/myeclpay/stores/{storeId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a store. Only stores without transactions can be deleted.
 *
 * **The user must be the manager for this store's structure**
 */
export const useDeleteMyeclpayStoresStoreId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteMyeclpayStoresStoreIdError,
      DeleteMyeclpayStoresStoreIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteMyeclpayStoresStoreIdError,
    DeleteMyeclpayStoresStoreIdVariables
  >({
    mutationFn: (variables: DeleteMyeclpayStoresStoreIdVariables) =>
      fetchDeleteMyeclpayStoresStoreId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostMyeclpayStoresStoreIdSellersPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type PostMyeclpayStoresStoreIdSellersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayStoresStoreIdSellersVariables = {
  body: Schemas.SellerCreation;
  pathParams: PostMyeclpayStoresStoreIdSellersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a store seller.
 *
 * This seller will have authorized permissions among:
 * - can_bank
 * - can_see_history
 * - can_cancel
 * - can_manage_sellers
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const fetchPostMyeclpayStoresStoreIdSellers = (
  variables: PostMyeclpayStoresStoreIdSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Seller,
    PostMyeclpayStoresStoreIdSellersError,
    Schemas.SellerCreation,
    {},
    {},
    PostMyeclpayStoresStoreIdSellersPathParams
  >({
    url: "/myeclpay/stores/{storeId}/sellers",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a store seller.
 *
 * This seller will have authorized permissions among:
 * - can_bank
 * - can_see_history
 * - can_cancel
 * - can_manage_sellers
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const usePostMyeclpayStoresStoreIdSellers = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.Seller,
      PostMyeclpayStoresStoreIdSellersError,
      PostMyeclpayStoresStoreIdSellersVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.Seller,
    PostMyeclpayStoresStoreIdSellersError,
    PostMyeclpayStoresStoreIdSellersVariables
  >({
    mutationFn: (variables: PostMyeclpayStoresStoreIdSellersVariables) =>
      fetchPostMyeclpayStoresStoreIdSellers(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMyeclpayStoresStoreIdSellersPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type GetMyeclpayStoresStoreIdSellersError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMyeclpayStoresStoreIdSellersResponse = Schemas.Seller[];

export type GetMyeclpayStoresStoreIdSellersVariables = {
  pathParams: GetMyeclpayStoresStoreIdSellersPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get all sellers for the given store.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const fetchGetMyeclpayStoresStoreIdSellers = (
  variables: GetMyeclpayStoresStoreIdSellersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMyeclpayStoresStoreIdSellersResponse,
    GetMyeclpayStoresStoreIdSellersError,
    undefined,
    {},
    {},
    GetMyeclpayStoresStoreIdSellersPathParams
  >({
    url: "/myeclpay/stores/{storeId}/sellers",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all sellers for the given store.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export function getMyeclpayStoresStoreIdSellersQuery(
  variables: GetMyeclpayStoresStoreIdSellersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMyeclpayStoresStoreIdSellersResponse>;
};

export function getMyeclpayStoresStoreIdSellersQuery(
  variables: GetMyeclpayStoresStoreIdSellersVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetMyeclpayStoresStoreIdSellersResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayStoresStoreIdSellersQuery(
  variables: GetMyeclpayStoresStoreIdSellersVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/stores/{storeId}/sellers",
      operationId: "getMyeclpayStoresStoreIdSellers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayStoresStoreIdSellers(variables, signal),
  };
}

/**
 * Get all sellers for the given store.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const useSuspenseGetMyeclpayStoresStoreIdSellers = <
  TData = GetMyeclpayStoresStoreIdSellersResponse,
>(
  variables: GetMyeclpayStoresStoreIdSellersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayStoresStoreIdSellersResponse,
      GetMyeclpayStoresStoreIdSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMyeclpayStoresStoreIdSellersResponse,
    GetMyeclpayStoresStoreIdSellersError,
    TData
  >({
    ...getMyeclpayStoresStoreIdSellersQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all sellers for the given store.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const useGetMyeclpayStoresStoreIdSellers = <
  TData = GetMyeclpayStoresStoreIdSellersResponse,
>(
  variables: GetMyeclpayStoresStoreIdSellersVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayStoresStoreIdSellersResponse,
      GetMyeclpayStoresStoreIdSellersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMyeclpayStoresStoreIdSellersResponse,
    GetMyeclpayStoresStoreIdSellersError,
    TData
  >({
    ...getMyeclpayStoresStoreIdSellersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchMyeclpayStoresStoreIdSellersSellerUserIdPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
  sellerUserId: string;
};

export type PatchMyeclpayStoresStoreIdSellersSellerUserIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchMyeclpayStoresStoreIdSellersSellerUserIdVariables = {
  body?: Schemas.SellerUpdate;
  pathParams: PatchMyeclpayStoresStoreIdSellersSellerUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a store seller permissions.
 * The structure manager cannot be updated as a seller.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const fetchPatchMyeclpayStoresStoreIdSellersSellerUserId = (
  variables: PatchMyeclpayStoresStoreIdSellersSellerUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchMyeclpayStoresStoreIdSellersSellerUserIdError,
    Schemas.SellerUpdate,
    {},
    {},
    PatchMyeclpayStoresStoreIdSellersSellerUserIdPathParams
  >({
    url: "/myeclpay/stores/{storeId}/sellers/{sellerUserId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a store seller permissions.
 * The structure manager cannot be updated as a seller.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const usePatchMyeclpayStoresStoreIdSellersSellerUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchMyeclpayStoresStoreIdSellersSellerUserIdError,
      PatchMyeclpayStoresStoreIdSellersSellerUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchMyeclpayStoresStoreIdSellersSellerUserIdError,
    PatchMyeclpayStoresStoreIdSellersSellerUserIdVariables
  >({
    mutationFn: (
      variables: PatchMyeclpayStoresStoreIdSellersSellerUserIdVariables,
    ) =>
      fetchPatchMyeclpayStoresStoreIdSellersSellerUserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteMyeclpayStoresStoreIdSellersSellerUserIdPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
  sellerUserId: string;
};

export type DeleteMyeclpayStoresStoreIdSellersSellerUserIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteMyeclpayStoresStoreIdSellersSellerUserIdVariables = {
  pathParams: DeleteMyeclpayStoresStoreIdSellersSellerUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a store seller.
 * The structure manager cannot be deleted as a seller.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const fetchDeleteMyeclpayStoresStoreIdSellersSellerUserId = (
  variables: DeleteMyeclpayStoresStoreIdSellersSellerUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteMyeclpayStoresStoreIdSellersSellerUserIdError,
    undefined,
    {},
    {},
    DeleteMyeclpayStoresStoreIdSellersSellerUserIdPathParams
  >({
    url: "/myeclpay/stores/{storeId}/sellers/{sellerUserId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a store seller.
 * The structure manager cannot be deleted as a seller.
 *
 * **The user must have the `can_manage_sellers` permission for this store**
 */
export const useDeleteMyeclpayStoresStoreIdSellersSellerUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteMyeclpayStoresStoreIdSellersSellerUserIdError,
      DeleteMyeclpayStoresStoreIdSellersSellerUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteMyeclpayStoresStoreIdSellersSellerUserIdError,
    DeleteMyeclpayStoresStoreIdSellersSellerUserIdVariables
  >({
    mutationFn: (
      variables: DeleteMyeclpayStoresStoreIdSellersSellerUserIdVariables,
    ) =>
      fetchDeleteMyeclpayStoresStoreIdSellersSellerUserId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostMyeclpayUsersMeRegisterError = Fetcher.ErrorWrapper<undefined>;

export type PostMyeclpayUsersMeRegisterVariables =
  HyperionContext["fetcherOptions"];

/**
 * Sign MyECL Pay TOS for the given user.
 *
 * The user will need to accept the latest TOS version to be able to use MyECL Pay.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostMyeclpayUsersMeRegister = (
  variables: PostMyeclpayUsersMeRegisterVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostMyeclpayUsersMeRegisterError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/myeclpay/users/me/register",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Sign MyECL Pay TOS for the given user.
 *
 * The user will need to accept the latest TOS version to be able to use MyECL Pay.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostMyeclpayUsersMeRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostMyeclpayUsersMeRegisterError,
      PostMyeclpayUsersMeRegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostMyeclpayUsersMeRegisterError,
    PostMyeclpayUsersMeRegisterVariables
  >({
    mutationFn: (variables: PostMyeclpayUsersMeRegisterVariables) =>
      fetchPostMyeclpayUsersMeRegister(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetMyeclpayUsersMeTosError = Fetcher.ErrorWrapper<undefined>;

export type GetMyeclpayUsersMeTosVariables = HyperionContext["fetcherOptions"];

/**
 * Get the latest TOS version and the user signed TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetMyeclpayUsersMeTos = (
  variables: GetMyeclpayUsersMeTosVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.TOSSignatureResponse,
    GetMyeclpayUsersMeTosError,
    undefined,
    {},
    {},
    {}
  >({ url: "/myeclpay/users/me/tos", method: "get", ...variables, signal });

/**
 * Get the latest TOS version and the user signed TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getMyeclpayUsersMeTosQuery(
  variables: GetMyeclpayUsersMeTosVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.TOSSignatureResponse>;
};

export function getMyeclpayUsersMeTosQuery(
  variables: GetMyeclpayUsersMeTosVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.TOSSignatureResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayUsersMeTosQuery(
  variables: GetMyeclpayUsersMeTosVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/users/me/tos",
      operationId: "getMyeclpayUsersMeTos",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayUsersMeTos(variables, signal),
  };
}

/**
 * Get the latest TOS version and the user signed TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetMyeclpayUsersMeTos = <
  TData = Schemas.TOSSignatureResponse,
>(
  variables: GetMyeclpayUsersMeTosVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TOSSignatureResponse,
      GetMyeclpayUsersMeTosError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.TOSSignatureResponse,
    GetMyeclpayUsersMeTosError,
    TData
  >({
    ...getMyeclpayUsersMeTosQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get the latest TOS version and the user signed TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetMyeclpayUsersMeTos = <TData = Schemas.TOSSignatureResponse,>(
  variables: GetMyeclpayUsersMeTosVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.TOSSignatureResponse,
      GetMyeclpayUsersMeTosError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.TOSSignatureResponse,
    GetMyeclpayUsersMeTosError,
    TData
  >({
    ...getMyeclpayUsersMeTosQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayUsersMeTosError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayUsersMeTosVariables = {
  body: Schemas.TOSSignature;
} & HyperionContext["fetcherOptions"];

/**
 * Sign MyECL Pay TOS for the given user.
 *
 * If the user is already registered in the MyECLPay system, this will update the TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostMyeclpayUsersMeTos = (
  variables: PostMyeclpayUsersMeTosVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostMyeclpayUsersMeTosError,
    Schemas.TOSSignature,
    {},
    {},
    {}
  >({ url: "/myeclpay/users/me/tos", method: "post", ...variables, signal });

/**
 * Sign MyECL Pay TOS for the given user.
 *
 * If the user is already registered in the MyECLPay system, this will update the TOS version.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostMyeclpayUsersMeTos = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostMyeclpayUsersMeTosError,
      PostMyeclpayUsersMeTosVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostMyeclpayUsersMeTosError,
    PostMyeclpayUsersMeTosVariables
  >({
    mutationFn: (variables: PostMyeclpayUsersMeTosVariables) =>
      fetchPostMyeclpayUsersMeTos(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetMyeclpayUsersMeWalletDevicesError =
  Fetcher.ErrorWrapper<undefined>;

export type GetMyeclpayUsersMeWalletDevicesResponse = Schemas.WalletDevice[];

export type GetMyeclpayUsersMeWalletDevicesVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetMyeclpayUsersMeWalletDevices = (
  variables: GetMyeclpayUsersMeWalletDevicesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMyeclpayUsersMeWalletDevicesResponse,
    GetMyeclpayUsersMeWalletDevicesError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/myeclpay/users/me/wallet/devices",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getMyeclpayUsersMeWalletDevicesQuery(
  variables: GetMyeclpayUsersMeWalletDevicesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMyeclpayUsersMeWalletDevicesResponse>;
};

export function getMyeclpayUsersMeWalletDevicesQuery(
  variables: GetMyeclpayUsersMeWalletDevicesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetMyeclpayUsersMeWalletDevicesResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayUsersMeWalletDevicesQuery(
  variables: GetMyeclpayUsersMeWalletDevicesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/users/me/wallet/devices",
      operationId: "getMyeclpayUsersMeWalletDevices",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayUsersMeWalletDevices(variables, signal),
  };
}

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetMyeclpayUsersMeWalletDevices = <
  TData = GetMyeclpayUsersMeWalletDevicesResponse,
>(
  variables: GetMyeclpayUsersMeWalletDevicesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayUsersMeWalletDevicesResponse,
      GetMyeclpayUsersMeWalletDevicesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMyeclpayUsersMeWalletDevicesResponse,
    GetMyeclpayUsersMeWalletDevicesError,
    TData
  >({
    ...getMyeclpayUsersMeWalletDevicesQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetMyeclpayUsersMeWalletDevices = <
  TData = GetMyeclpayUsersMeWalletDevicesResponse,
>(
  variables: GetMyeclpayUsersMeWalletDevicesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayUsersMeWalletDevicesResponse,
      GetMyeclpayUsersMeWalletDevicesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMyeclpayUsersMeWalletDevicesResponse,
    GetMyeclpayUsersMeWalletDevicesError,
    TData
  >({
    ...getMyeclpayUsersMeWalletDevicesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayUsersMeWalletDevicesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayUsersMeWalletDevicesVariables = {
  body: Schemas.WalletDeviceCreation;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new device for the user.
 * The user will need to activate it using a token sent by email.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostMyeclpayUsersMeWalletDevices = (
  variables: PostMyeclpayUsersMeWalletDevicesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.WalletDevice,
    PostMyeclpayUsersMeWalletDevicesError,
    Schemas.WalletDeviceCreation,
    {},
    {},
    {}
  >({
    url: "/myeclpay/users/me/wallet/devices",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new device for the user.
 * The user will need to activate it using a token sent by email.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostMyeclpayUsersMeWalletDevices = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.WalletDevice,
      PostMyeclpayUsersMeWalletDevicesError,
      PostMyeclpayUsersMeWalletDevicesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.WalletDevice,
    PostMyeclpayUsersMeWalletDevicesError,
    PostMyeclpayUsersMeWalletDevicesVariables
  >({
    mutationFn: (variables: PostMyeclpayUsersMeWalletDevicesVariables) =>
      fetchPostMyeclpayUsersMeWalletDevices(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMyeclpayUsersMeWalletDevicesWalletDeviceIdPathParams = {
  /**
   * @format uuid
   */
  walletDeviceId: string;
};

export type GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables = {
  pathParams: GetMyeclpayUsersMeWalletDevicesWalletDeviceIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetMyeclpayUsersMeWalletDevicesWalletDeviceId = (
  variables: GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.WalletDevice,
    GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError,
    undefined,
    {},
    {},
    GetMyeclpayUsersMeWalletDevicesWalletDeviceIdPathParams
  >({
    url: "/myeclpay/users/me/wallet/devices/{walletDeviceId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getMyeclpayUsersMeWalletDevicesWalletDeviceIdQuery(
  variables: GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.WalletDevice>;
};

export function getMyeclpayUsersMeWalletDevicesWalletDeviceIdQuery(
  variables:
    | GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.WalletDevice>)
    | reactQuery.SkipToken;
};

export function getMyeclpayUsersMeWalletDevicesWalletDeviceIdQuery(
  variables:
    | GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/users/me/wallet/devices/{walletDeviceId}",
      operationId: "getMyeclpayUsersMeWalletDevicesWalletDeviceId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayUsersMeWalletDevicesWalletDeviceId(
              variables,
              signal,
            ),
  };
}

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetMyeclpayUsersMeWalletDevicesWalletDeviceId = <
  TData = Schemas.WalletDevice,
>(
  variables: GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.WalletDevice,
      GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.WalletDevice,
    GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError,
    TData
  >({
    ...getMyeclpayUsersMeWalletDevicesWalletDeviceIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get user devices.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetMyeclpayUsersMeWalletDevicesWalletDeviceId = <
  TData = Schemas.WalletDevice,
>(
  variables:
    | GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.WalletDevice,
      GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.WalletDevice,
    GetMyeclpayUsersMeWalletDevicesWalletDeviceIdError,
    TData
  >({
    ...getMyeclpayUsersMeWalletDevicesWalletDeviceIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetMyeclpayUsersMeWalletError = Fetcher.ErrorWrapper<undefined>;

export type GetMyeclpayUsersMeWalletVariables =
  HyperionContext["fetcherOptions"];

/**
 * Get user wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetMyeclpayUsersMeWallet = (
  variables: GetMyeclpayUsersMeWalletVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.Wallet,
    GetMyeclpayUsersMeWalletError,
    undefined,
    {},
    {},
    {}
  >({ url: "/myeclpay/users/me/wallet", method: "get", ...variables, signal });

/**
 * Get user wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getMyeclpayUsersMeWalletQuery(
  variables: GetMyeclpayUsersMeWalletVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.Wallet>;
};

export function getMyeclpayUsersMeWalletQuery(
  variables: GetMyeclpayUsersMeWalletVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.Wallet>)
    | reactQuery.SkipToken;
};

export function getMyeclpayUsersMeWalletQuery(
  variables: GetMyeclpayUsersMeWalletVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/users/me/wallet",
      operationId: "getMyeclpayUsersMeWallet",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayUsersMeWallet(variables, signal),
  };
}

/**
 * Get user wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetMyeclpayUsersMeWallet = <TData = Schemas.Wallet,>(
  variables: GetMyeclpayUsersMeWalletVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Wallet,
      GetMyeclpayUsersMeWalletError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.Wallet,
    GetMyeclpayUsersMeWalletError,
    TData
  >({
    ...getMyeclpayUsersMeWalletQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get user wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetMyeclpayUsersMeWallet = <TData = Schemas.Wallet,>(
  variables: GetMyeclpayUsersMeWalletVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.Wallet,
      GetMyeclpayUsersMeWalletError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.Wallet,
    GetMyeclpayUsersMeWalletError,
    TData
  >({
    ...getMyeclpayUsersMeWalletQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetMyeclpayDevicesActivateQueryParams = {
  token: string;
};

export type GetMyeclpayDevicesActivateError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMyeclpayDevicesActivateVariables = {
  queryParams: GetMyeclpayDevicesActivateQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Activate a wallet device
 */
export const fetchGetMyeclpayDevicesActivate = (
  variables: GetMyeclpayDevicesActivateVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetMyeclpayDevicesActivateError,
    undefined,
    {},
    GetMyeclpayDevicesActivateQueryParams,
    {}
  >({ url: "/myeclpay/devices/activate", method: "get", ...variables, signal });

/**
 * Activate a wallet device
 */
export function getMyeclpayDevicesActivateQuery(
  variables: GetMyeclpayDevicesActivateVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getMyeclpayDevicesActivateQuery(
  variables: GetMyeclpayDevicesActivateVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getMyeclpayDevicesActivateQuery(
  variables: GetMyeclpayDevicesActivateVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/devices/activate",
      operationId: "getMyeclpayDevicesActivate",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayDevicesActivate(variables, signal),
  };
}

/**
 * Activate a wallet device
 */
export const useSuspenseGetMyeclpayDevicesActivate = <TData = void,>(
  variables: GetMyeclpayDevicesActivateVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetMyeclpayDevicesActivateError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetMyeclpayDevicesActivateError,
    TData
  >({
    ...getMyeclpayDevicesActivateQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Activate a wallet device
 */
export const useGetMyeclpayDevicesActivate = <TData = void,>(
  variables: GetMyeclpayDevicesActivateVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetMyeclpayDevicesActivateError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetMyeclpayDevicesActivateError, TData>({
    ...getMyeclpayDevicesActivateQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokePathParams = {
  /**
   * @format uuid
   */
  walletDeviceId: string;
};

export type PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeVariables = {
  pathParams: PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Revoke a device for the user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevoke = (
  variables: PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError,
    undefined,
    {},
    {},
    PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokePathParams
  >({
    url: "/myeclpay/users/me/wallet/devices/{walletDeviceId}/revoke",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Revoke a device for the user.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevoke = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError,
      PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeError,
    PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeVariables
  >({
    mutationFn: (
      variables: PostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevokeVariables,
    ) =>
      fetchPostMyeclpayUsersMeWalletDevicesWalletDeviceIdRevoke(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMyeclpayUsersMeWalletHistoryQueryParams = {
  start_date?: string | null;
  end_date?: string | null;
};

export type GetMyeclpayUsersMeWalletHistoryError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMyeclpayUsersMeWalletHistoryResponse = Schemas.History[];

export type GetMyeclpayUsersMeWalletHistoryVariables = {
  queryParams?: GetMyeclpayUsersMeWalletHistoryQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Get all transactions for the current user's wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetMyeclpayUsersMeWalletHistory = (
  variables: GetMyeclpayUsersMeWalletHistoryVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMyeclpayUsersMeWalletHistoryResponse,
    GetMyeclpayUsersMeWalletHistoryError,
    undefined,
    {},
    GetMyeclpayUsersMeWalletHistoryQueryParams,
    {}
  >({
    url: "/myeclpay/users/me/wallet/history",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Get all transactions for the current user's wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getMyeclpayUsersMeWalletHistoryQuery(
  variables: GetMyeclpayUsersMeWalletHistoryVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMyeclpayUsersMeWalletHistoryResponse>;
};

export function getMyeclpayUsersMeWalletHistoryQuery(
  variables: GetMyeclpayUsersMeWalletHistoryVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetMyeclpayUsersMeWalletHistoryResponse>)
    | reactQuery.SkipToken;
};

export function getMyeclpayUsersMeWalletHistoryQuery(
  variables: GetMyeclpayUsersMeWalletHistoryVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/users/me/wallet/history",
      operationId: "getMyeclpayUsersMeWalletHistory",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayUsersMeWalletHistory(variables, signal),
  };
}

/**
 * Get all transactions for the current user's wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetMyeclpayUsersMeWalletHistory = <
  TData = GetMyeclpayUsersMeWalletHistoryResponse,
>(
  variables: GetMyeclpayUsersMeWalletHistoryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayUsersMeWalletHistoryResponse,
      GetMyeclpayUsersMeWalletHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMyeclpayUsersMeWalletHistoryResponse,
    GetMyeclpayUsersMeWalletHistoryError,
    TData
  >({
    ...getMyeclpayUsersMeWalletHistoryQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all transactions for the current user's wallet.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetMyeclpayUsersMeWalletHistory = <
  TData = GetMyeclpayUsersMeWalletHistoryResponse,
>(
  variables: GetMyeclpayUsersMeWalletHistoryVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMyeclpayUsersMeWalletHistoryResponse,
      GetMyeclpayUsersMeWalletHistoryError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMyeclpayUsersMeWalletHistoryResponse,
    GetMyeclpayUsersMeWalletHistoryError,
    TData
  >({
    ...getMyeclpayUsersMeWalletHistoryQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayTransferInitError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayTransferInitVariables = {
  body: Schemas.TransferInfo;
} & HyperionContext["fetcherOptions"];

/**
 * Initiate HelloAsso transfer, return a payment url to complete the transaction on HelloAsso website.
 */
export const fetchPostMyeclpayTransferInit = (
  variables: PostMyeclpayTransferInitVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PaymentUrl,
    PostMyeclpayTransferInitError,
    Schemas.TransferInfo,
    {},
    {},
    {}
  >({ url: "/myeclpay/transfer/init", method: "post", ...variables, signal });

/**
 * Initiate HelloAsso transfer, return a payment url to complete the transaction on HelloAsso website.
 */
export const usePostMyeclpayTransferInit = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.PaymentUrl,
      PostMyeclpayTransferInitError,
      PostMyeclpayTransferInitVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.PaymentUrl,
    PostMyeclpayTransferInitError,
    PostMyeclpayTransferInitVariables
  >({
    mutationFn: (variables: PostMyeclpayTransferInitVariables) =>
      fetchPostMyeclpayTransferInit(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetMyeclpayTransferRedirectQueryParams = {
  url: string;
  checkoutIntentId?: string | null;
  code?: string | null;
  orderId?: string | null;
  error?: string | null;
};

export type GetMyeclpayTransferRedirectError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMyeclpayTransferRedirectVariables = {
  queryParams: GetMyeclpayTransferRedirectQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * HelloAsso checkout should be configured to redirect the user to:
 *  - f"{settings.CLIENT_URL}myeclpay/transfer/redirect?url={redirect_url}"
 * Redirect the user to the provided redirect `url`. The parameters `checkoutIntentId`, `code`, `orderId` and `error` passed by HelloAsso will be added to the redirect URL.
 * The redirect `url` must be trusted by Hyperion in the dotenv.
 */
export const fetchGetMyeclpayTransferRedirect = (
  variables: GetMyeclpayTransferRedirectVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.PaymentUrl,
    GetMyeclpayTransferRedirectError,
    undefined,
    {},
    GetMyeclpayTransferRedirectQueryParams,
    {}
  >({
    url: "/myeclpay/transfer/redirect",
    method: "get",
    ...variables,
    signal,
  });

/**
 * HelloAsso checkout should be configured to redirect the user to:
 *  - f"{settings.CLIENT_URL}myeclpay/transfer/redirect?url={redirect_url}"
 * Redirect the user to the provided redirect `url`. The parameters `checkoutIntentId`, `code`, `orderId` and `error` passed by HelloAsso will be added to the redirect URL.
 * The redirect `url` must be trusted by Hyperion in the dotenv.
 */
export function getMyeclpayTransferRedirectQuery(
  variables: GetMyeclpayTransferRedirectVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.PaymentUrl>;
};

export function getMyeclpayTransferRedirectQuery(
  variables: GetMyeclpayTransferRedirectVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.PaymentUrl>)
    | reactQuery.SkipToken;
};

export function getMyeclpayTransferRedirectQuery(
  variables: GetMyeclpayTransferRedirectVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/transfer/redirect",
      operationId: "getMyeclpayTransferRedirect",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayTransferRedirect(variables, signal),
  };
}

/**
 * HelloAsso checkout should be configured to redirect the user to:
 *  - f"{settings.CLIENT_URL}myeclpay/transfer/redirect?url={redirect_url}"
 * Redirect the user to the provided redirect `url`. The parameters `checkoutIntentId`, `code`, `orderId` and `error` passed by HelloAsso will be added to the redirect URL.
 * The redirect `url` must be trusted by Hyperion in the dotenv.
 */
export const useSuspenseGetMyeclpayTransferRedirect = <
  TData = Schemas.PaymentUrl,
>(
  variables: GetMyeclpayTransferRedirectVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaymentUrl,
      GetMyeclpayTransferRedirectError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.PaymentUrl,
    GetMyeclpayTransferRedirectError,
    TData
  >({
    ...getMyeclpayTransferRedirectQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * HelloAsso checkout should be configured to redirect the user to:
 *  - f"{settings.CLIENT_URL}myeclpay/transfer/redirect?url={redirect_url}"
 * Redirect the user to the provided redirect `url`. The parameters `checkoutIntentId`, `code`, `orderId` and `error` passed by HelloAsso will be added to the redirect URL.
 * The redirect `url` must be trusted by Hyperion in the dotenv.
 */
export const useGetMyeclpayTransferRedirect = <TData = Schemas.PaymentUrl,>(
  variables: GetMyeclpayTransferRedirectVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.PaymentUrl,
      GetMyeclpayTransferRedirectError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.PaymentUrl,
    GetMyeclpayTransferRedirectError,
    TData
  >({
    ...getMyeclpayTransferRedirectQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMyeclpayStoresStoreIdScanCheckPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type PostMyeclpayStoresStoreIdScanCheckError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayStoresStoreIdScanCheckVariables = {
  body: Schemas.ScanInfo;
  pathParams: PostMyeclpayStoresStoreIdScanCheckPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Validate if a given QR Code can be scanned by the seller.
 *
 * The QR Code should be valid, the seller should have the `can_bank` permission for this store,
 * and the debited wallet device should be active.
 *
 * If the store structure has an association membership, the user should be a member of the association.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostMyeclpayStoresStoreIdScanCheck = (
  variables: PostMyeclpayStoresStoreIdScanCheckVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AppTypesStandardResponsesResult,
    PostMyeclpayStoresStoreIdScanCheckError,
    Schemas.ScanInfo,
    {},
    {},
    PostMyeclpayStoresStoreIdScanCheckPathParams
  >({
    url: "/myeclpay/stores/{storeId}/scan/check",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Validate if a given QR Code can be scanned by the seller.
 *
 * The QR Code should be valid, the seller should have the `can_bank` permission for this store,
 * and the debited wallet device should be active.
 *
 * If the store structure has an association membership, the user should be a member of the association.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostMyeclpayStoresStoreIdScanCheck = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AppTypesStandardResponsesResult,
      PostMyeclpayStoresStoreIdScanCheckError,
      PostMyeclpayStoresStoreIdScanCheckVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AppTypesStandardResponsesResult,
    PostMyeclpayStoresStoreIdScanCheckError,
    PostMyeclpayStoresStoreIdScanCheckVariables
  >({
    mutationFn: (variables: PostMyeclpayStoresStoreIdScanCheckVariables) =>
      fetchPostMyeclpayStoresStoreIdScanCheck(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostMyeclpayStoresStoreIdScanPathParams = {
  /**
   * @format uuid
   */
  storeId: string;
};

export type PostMyeclpayStoresStoreIdScanError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMyeclpayStoresStoreIdScanVariables = {
  body: Schemas.ScanInfo;
  pathParams: PostMyeclpayStoresStoreIdScanPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Scan and bank a QR code for this store.
 *
 * `signature` should be a base64 encoded string
 *  - signed using *ed25519*,
 *  - where data are a `QRCodeContentData` object:
 *     ```
 *     {
 *         id: UUID
 *         tot: int
 *         iat: datetime
 *         key: UUID
 *     }
 *     ```
 *
 * The provided content is checked to ensure:
 *     - the QR Code is not already used
 *     - the QR Code is not expired
 *     - the QR Code is intended to be scanned for a store `scan_info.store`
 *     - the signature is valid and correspond to `wallet_device_id` public key
 *     - the debited's wallet device is active
 *     - the debited's Wallet balance greater than the QR Code total
 *
 * **The user must be authenticated to use this endpoint**
 * **The user must have the `can_bank` permission for this store**
 */
export const fetchPostMyeclpayStoresStoreIdScan = (
  variables: PostMyeclpayStoresStoreIdScanVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostMyeclpayStoresStoreIdScanError,
    Schemas.ScanInfo,
    {},
    {},
    PostMyeclpayStoresStoreIdScanPathParams
  >({
    url: "/myeclpay/stores/{storeId}/scan",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Scan and bank a QR code for this store.
 *
 * `signature` should be a base64 encoded string
 *  - signed using *ed25519*,
 *  - where data are a `QRCodeContentData` object:
 *     ```
 *     {
 *         id: UUID
 *         tot: int
 *         iat: datetime
 *         key: UUID
 *     }
 *     ```
 *
 * The provided content is checked to ensure:
 *     - the QR Code is not already used
 *     - the QR Code is not expired
 *     - the QR Code is intended to be scanned for a store `scan_info.store`
 *     - the signature is valid and correspond to `wallet_device_id` public key
 *     - the debited's wallet device is active
 *     - the debited's Wallet balance greater than the QR Code total
 *
 * **The user must be authenticated to use this endpoint**
 * **The user must have the `can_bank` permission for this store**
 */
export const usePostMyeclpayStoresStoreIdScan = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostMyeclpayStoresStoreIdScanError,
      PostMyeclpayStoresStoreIdScanVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostMyeclpayStoresStoreIdScanError,
    PostMyeclpayStoresStoreIdScanVariables
  >({
    mutationFn: (variables: PostMyeclpayStoresStoreIdScanVariables) =>
      fetchPostMyeclpayStoresStoreIdScan(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostMyeclpayTransactionsTransactionIdRefundPathParams = {
  /**
   * @format uuid
   */
  transactionId: string;
};

export type PostMyeclpayTransactionsTransactionIdRefundError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostMyeclpayTransactionsTransactionIdRefundVariables = {
  body: Schemas.RefundInfo;
  pathParams: PostMyeclpayTransactionsTransactionIdRefundPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Refund a transaction. Only transactions made in the last 30 days can be refunded.
 *
 * Currently transactions between users are forbidden and can thus not be refunded.
 *
 * To cancel a transaction made in the last 30 seconds, the endpoint `/myeclpay/transactions/{transaction_id}/cancel` should be used.
 *
 * **The user must either be the credited user or a seller with cancel permissions of the credited store of the transaction**
 */
export const fetchPostMyeclpayTransactionsTransactionIdRefund = (
  variables: PostMyeclpayTransactionsTransactionIdRefundVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostMyeclpayTransactionsTransactionIdRefundError,
    Schemas.RefundInfo,
    {},
    {},
    PostMyeclpayTransactionsTransactionIdRefundPathParams
  >({
    url: "/myeclpay/transactions/{transactionId}/refund",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Refund a transaction. Only transactions made in the last 30 days can be refunded.
 *
 * Currently transactions between users are forbidden and can thus not be refunded.
 *
 * To cancel a transaction made in the last 30 seconds, the endpoint `/myeclpay/transactions/{transaction_id}/cancel` should be used.
 *
 * **The user must either be the credited user or a seller with cancel permissions of the credited store of the transaction**
 */
export const usePostMyeclpayTransactionsTransactionIdRefund = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostMyeclpayTransactionsTransactionIdRefundError,
      PostMyeclpayTransactionsTransactionIdRefundVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostMyeclpayTransactionsTransactionIdRefundError,
    PostMyeclpayTransactionsTransactionIdRefundVariables
  >({
    mutationFn: (
      variables: PostMyeclpayTransactionsTransactionIdRefundVariables,
    ) =>
      fetchPostMyeclpayTransactionsTransactionIdRefund(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostMyeclpayTransactionsTransactionIdCancelPathParams = {
  /**
   * @format uuid
   */
  transactionId: string;
};

export type PostMyeclpayTransactionsTransactionIdCancelError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostMyeclpayTransactionsTransactionIdCancelVariables = {
  pathParams: PostMyeclpayTransactionsTransactionIdCancelPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Cancel a transaction.
 * A transaction can be canceled in the first 30 seconds after it has been created.
 *
 * To refund an older transaction, use the `/myeclpay/transactions/{transaction_id}/refund` endpoint.
 *
 * **The user must either be the credited user or the seller of the transaction**
 */
export const fetchPostMyeclpayTransactionsTransactionIdCancel = (
  variables: PostMyeclpayTransactionsTransactionIdCancelVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostMyeclpayTransactionsTransactionIdCancelError,
    undefined,
    {},
    {},
    PostMyeclpayTransactionsTransactionIdCancelPathParams
  >({
    url: "/myeclpay/transactions/{transactionId}/cancel",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Cancel a transaction.
 * A transaction can be canceled in the first 30 seconds after it has been created.
 *
 * To refund an older transaction, use the `/myeclpay/transactions/{transaction_id}/refund` endpoint.
 *
 * **The user must either be the credited user or the seller of the transaction**
 */
export const usePostMyeclpayTransactionsTransactionIdCancel = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostMyeclpayTransactionsTransactionIdCancelError,
      PostMyeclpayTransactionsTransactionIdCancelVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostMyeclpayTransactionsTransactionIdCancelError,
    PostMyeclpayTransactionsTransactionIdCancelVariables
  >({
    mutationFn: (
      variables: PostMyeclpayTransactionsTransactionIdCancelVariables,
    ) =>
      fetchPostMyeclpayTransactionsTransactionIdCancel(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMyeclpayIntegrityCheckQueryParams = {
  lastChecked?: string | null;
  /**
   * @default false
   */
  isInitialisation?: boolean;
};

export type GetMyeclpayIntegrityCheckHeaders = {
  x_data_verifier_token: string;
};

export type GetMyeclpayIntegrityCheckError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMyeclpayIntegrityCheckVariables = {
  headers: GetMyeclpayIntegrityCheckHeaders;
  queryParams?: GetMyeclpayIntegrityCheckQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Send all the MyECL Pay data for integrity check.
 * Data includes:
 * - Wallets deducted of the last 30 seconds transactions
 * - Transactions with at least 30 seconds delay
 * - Transfers
 * - Refunds
 *
 * **The header must contain the MYECLPAY_DATA_VERIFIER_ACCESS_TOKEN defined in the settings in the `x-data-verifier-token` field**
 */
export const fetchGetMyeclpayIntegrityCheck = (
  variables: GetMyeclpayIntegrityCheckVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.IntegrityCheckData,
    GetMyeclpayIntegrityCheckError,
    undefined,
    GetMyeclpayIntegrityCheckHeaders,
    GetMyeclpayIntegrityCheckQueryParams,
    {}
  >({ url: "/myeclpay/integrity-check", method: "get", ...variables, signal });

/**
 * Send all the MyECL Pay data for integrity check.
 * Data includes:
 * - Wallets deducted of the last 30 seconds transactions
 * - Transactions with at least 30 seconds delay
 * - Transfers
 * - Refunds
 *
 * **The header must contain the MYECLPAY_DATA_VERIFIER_ACCESS_TOKEN defined in the settings in the `x-data-verifier-token` field**
 */
export function getMyeclpayIntegrityCheckQuery(
  variables: GetMyeclpayIntegrityCheckVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.IntegrityCheckData>;
};

export function getMyeclpayIntegrityCheckQuery(
  variables: GetMyeclpayIntegrityCheckVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.IntegrityCheckData>)
    | reactQuery.SkipToken;
};

export function getMyeclpayIntegrityCheckQuery(
  variables: GetMyeclpayIntegrityCheckVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay/integrity-check",
      operationId: "getMyeclpayIntegrityCheck",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayIntegrityCheck(variables, signal),
  };
}

/**
 * Send all the MyECL Pay data for integrity check.
 * Data includes:
 * - Wallets deducted of the last 30 seconds transactions
 * - Transactions with at least 30 seconds delay
 * - Transfers
 * - Refunds
 *
 * **The header must contain the MYECLPAY_DATA_VERIFIER_ACCESS_TOKEN defined in the settings in the `x-data-verifier-token` field**
 */
export const useSuspenseGetMyeclpayIntegrityCheck = <
  TData = Schemas.IntegrityCheckData,
>(
  variables: GetMyeclpayIntegrityCheckVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.IntegrityCheckData,
      GetMyeclpayIntegrityCheckError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.IntegrityCheckData,
    GetMyeclpayIntegrityCheckError,
    TData
  >({
    ...getMyeclpayIntegrityCheckQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Send all the MyECL Pay data for integrity check.
 * Data includes:
 * - Wallets deducted of the last 30 seconds transactions
 * - Transactions with at least 30 seconds delay
 * - Transfers
 * - Refunds
 *
 * **The header must contain the MYECLPAY_DATA_VERIFIER_ACCESS_TOKEN defined in the settings in the `x-data-verifier-token` field**
 */
export const useGetMyeclpayIntegrityCheck = <
  TData = Schemas.IntegrityCheckData,
>(
  variables: GetMyeclpayIntegrityCheckVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.IntegrityCheckData,
      GetMyeclpayIntegrityCheckError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.IntegrityCheckData,
    GetMyeclpayIntegrityCheckError,
    TData
  >({
    ...getMyeclpayIntegrityCheckQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetMembershipsError = Fetcher.ErrorWrapper<undefined>;

export type GetMembershipsResponse = Schemas.MembershipSimple[];

export type GetMembershipsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all memberships from database as a list of dictionaries
 */
export const fetchGetMemberships = (
  variables: GetMembershipsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMembershipsResponse,
    GetMembershipsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/memberships/", method: "get", ...variables, signal });

/**
 * Return all memberships from database as a list of dictionaries
 */
export function getMembershipsQuery(variables: GetMembershipsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetMembershipsResponse>;
};

export function getMembershipsQuery(
  variables: GetMembershipsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetMembershipsResponse>)
    | reactQuery.SkipToken;
};

export function getMembershipsQuery(
  variables: GetMembershipsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/memberships/",
      operationId: "getMemberships",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMemberships(variables, signal),
  };
}

/**
 * Return all memberships from database as a list of dictionaries
 */
export const useSuspenseGetMemberships = <TData = GetMembershipsResponse,>(
  variables: GetMembershipsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsResponse,
      GetMembershipsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMembershipsResponse,
    GetMembershipsError,
    TData
  >({
    ...getMembershipsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all memberships from database as a list of dictionaries
 */
export const useGetMemberships = <TData = GetMembershipsResponse,>(
  variables: GetMembershipsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsResponse,
      GetMembershipsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMembershipsResponse,
    GetMembershipsError,
    TData
  >({
    ...getMembershipsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMembershipsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMembershipsVariables = {
  body: Schemas.AppCoreMembershipsSchemasMembershipsMembershipBase;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostMemberships = (
  variables: PostMembershipsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.MembershipSimple,
    PostMembershipsError,
    Schemas.AppCoreMembershipsSchemasMembershipsMembershipBase,
    {},
    {},
    {}
  >({ url: "/memberships/", method: "post", ...variables, signal });

/**
 * Create a new membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostMemberships = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MembershipSimple,
      PostMembershipsError,
      PostMembershipsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.MembershipSimple,
    PostMembershipsError,
    PostMembershipsVariables
  >({
    mutationFn: (variables: PostMembershipsVariables) =>
      fetchPostMemberships(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetMembershipsAssociationMembershipIdMembersPathParams = {
  /**
   * @format uuid
   */
  associationMembershipId: string;
};

export type GetMembershipsAssociationMembershipIdMembersQueryParams = {
  /**
   * @format date
   */
  minimalStartDate?: string;
  /**
   * @format date
   */
  maximalStartDate?: string;
  /**
   * @format date
   */
  minimalEndDate?: string;
  /**
   * @format date
   */
  maximalEndDate?: string;
};

export type GetMembershipsAssociationMembershipIdMembersError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetMembershipsAssociationMembershipIdMembersResponse =
  Schemas.UserMembershipComplete[];

export type GetMembershipsAssociationMembershipIdMembersVariables = {
  pathParams: GetMembershipsAssociationMembershipIdMembersPathParams;
  queryParams?: GetMembershipsAssociationMembershipIdMembersQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return membership with the given ID.
 *
 * **This endpoint is only usable by ECL members**
 */
export const fetchGetMembershipsAssociationMembershipIdMembers = (
  variables: GetMembershipsAssociationMembershipIdMembersVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMembershipsAssociationMembershipIdMembersResponse,
    GetMembershipsAssociationMembershipIdMembersError,
    undefined,
    {},
    GetMembershipsAssociationMembershipIdMembersQueryParams,
    GetMembershipsAssociationMembershipIdMembersPathParams
  >({
    url: "/memberships/{associationMembershipId}/members",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return membership with the given ID.
 *
 * **This endpoint is only usable by ECL members**
 */
export function getMembershipsAssociationMembershipIdMembersQuery(
  variables: GetMembershipsAssociationMembershipIdMembersVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMembershipsAssociationMembershipIdMembersResponse>;
};

export function getMembershipsAssociationMembershipIdMembersQuery(
  variables:
    | GetMembershipsAssociationMembershipIdMembersVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetMembershipsAssociationMembershipIdMembersResponse>)
    | reactQuery.SkipToken;
};

export function getMembershipsAssociationMembershipIdMembersQuery(
  variables:
    | GetMembershipsAssociationMembershipIdMembersVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/memberships/{associationMembershipId}/members",
      operationId: "getMembershipsAssociationMembershipIdMembers",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMembershipsAssociationMembershipIdMembers(
              variables,
              signal,
            ),
  };
}

/**
 * Return membership with the given ID.
 *
 * **This endpoint is only usable by ECL members**
 */
export const useSuspenseGetMembershipsAssociationMembershipIdMembers = <
  TData = GetMembershipsAssociationMembershipIdMembersResponse,
>(
  variables: GetMembershipsAssociationMembershipIdMembersVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsAssociationMembershipIdMembersResponse,
      GetMembershipsAssociationMembershipIdMembersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMembershipsAssociationMembershipIdMembersResponse,
    GetMembershipsAssociationMembershipIdMembersError,
    TData
  >({
    ...getMembershipsAssociationMembershipIdMembersQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return membership with the given ID.
 *
 * **This endpoint is only usable by ECL members**
 */
export const useGetMembershipsAssociationMembershipIdMembers = <
  TData = GetMembershipsAssociationMembershipIdMembersResponse,
>(
  variables:
    | GetMembershipsAssociationMembershipIdMembersVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsAssociationMembershipIdMembersResponse,
      GetMembershipsAssociationMembershipIdMembersError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMembershipsAssociationMembershipIdMembersResponse,
    GetMembershipsAssociationMembershipIdMembersError,
    TData
  >({
    ...getMembershipsAssociationMembershipIdMembersQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchMembershipsAssociationMembershipIdPathParams = {
  /**
   * @format uuid
   */
  associationMembershipId: string;
};

export type PatchMembershipsAssociationMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PatchMembershipsAssociationMembershipIdVariables = {
  body: Schemas.AppCoreMembershipsSchemasMembershipsMembershipBase;
  pathParams: PatchMembershipsAssociationMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchMembershipsAssociationMembershipId = (
  variables: PatchMembershipsAssociationMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchMembershipsAssociationMembershipIdError,
    Schemas.AppCoreMembershipsSchemasMembershipsMembershipBase,
    {},
    {},
    PatchMembershipsAssociationMembershipIdPathParams
  >({
    url: "/memberships/{associationMembershipId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchMembershipsAssociationMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchMembershipsAssociationMembershipIdError,
      PatchMembershipsAssociationMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchMembershipsAssociationMembershipIdError,
    PatchMembershipsAssociationMembershipIdVariables
  >({
    mutationFn: (variables: PatchMembershipsAssociationMembershipIdVariables) =>
      fetchPatchMembershipsAssociationMembershipId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteMembershipsAssociationMembershipIdPathParams = {
  /**
   * @format uuid
   */
  associationMembershipId: string;
};

export type DeleteMembershipsAssociationMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteMembershipsAssociationMembershipIdVariables = {
  pathParams: DeleteMembershipsAssociationMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteMembershipsAssociationMembershipId = (
  variables: DeleteMembershipsAssociationMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteMembershipsAssociationMembershipIdError,
    undefined,
    {},
    {},
    DeleteMembershipsAssociationMembershipIdPathParams
  >({
    url: "/memberships/{associationMembershipId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteMembershipsAssociationMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteMembershipsAssociationMembershipIdError,
      DeleteMembershipsAssociationMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteMembershipsAssociationMembershipIdError,
    DeleteMembershipsAssociationMembershipIdVariables
  >({
    mutationFn: (
      variables: DeleteMembershipsAssociationMembershipIdVariables,
    ) =>
      fetchDeleteMembershipsAssociationMembershipId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetMembershipsUsersUserIdPathParams = {
  userId: string;
};

export type GetMembershipsUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetMembershipsUsersUserIdResponse =
  Schemas.UserMembershipComplete[];

export type GetMembershipsUsersUserIdVariables = {
  pathParams: GetMembershipsUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all memberships for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetMembershipsUsersUserId = (
  variables: GetMembershipsUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMembershipsUsersUserIdResponse,
    GetMembershipsUsersUserIdError,
    undefined,
    {},
    {},
    GetMembershipsUsersUserIdPathParams
  >({
    url: "/memberships/users/{userId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all memberships for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export function getMembershipsUsersUserIdQuery(
  variables: GetMembershipsUsersUserIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMembershipsUsersUserIdResponse>;
};

export function getMembershipsUsersUserIdQuery(
  variables: GetMembershipsUsersUserIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetMembershipsUsersUserIdResponse>)
    | reactQuery.SkipToken;
};

export function getMembershipsUsersUserIdQuery(
  variables: GetMembershipsUsersUserIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/memberships/users/{userId}",
      operationId: "getMembershipsUsersUserId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMembershipsUsersUserId(variables, signal),
  };
}

/**
 * Return all memberships for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetMembershipsUsersUserId = <
  TData = GetMembershipsUsersUserIdResponse,
>(
  variables: GetMembershipsUsersUserIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsUsersUserIdResponse,
      GetMembershipsUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMembershipsUsersUserIdResponse,
    GetMembershipsUsersUserIdError,
    TData
  >({
    ...getMembershipsUsersUserIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all memberships for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetMembershipsUsersUserId = <
  TData = GetMembershipsUsersUserIdResponse,
>(
  variables: GetMembershipsUsersUserIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsUsersUserIdResponse,
      GetMembershipsUsersUserIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMembershipsUsersUserIdResponse,
    GetMembershipsUsersUserIdError,
    TData
  >({
    ...getMembershipsUsersUserIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMembershipsUsersUserIdPathParams = {
  userId: string;
};

export type PostMembershipsUsersUserIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostMembershipsUsersUserIdVariables = {
  body: Schemas.UserMembershipBase;
  pathParams: PostMembershipsUsersUserIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new user membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostMembershipsUsersUserId = (
  variables: PostMembershipsUsersUserIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.UserMembershipComplete,
    PostMembershipsUsersUserIdError,
    Schemas.UserMembershipBase,
    {},
    {},
    PostMembershipsUsersUserIdPathParams
  >({
    url: "/memberships/users/{userId}",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Create a new user membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostMembershipsUsersUserId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.UserMembershipComplete,
      PostMembershipsUsersUserIdError,
      PostMembershipsUsersUserIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.UserMembershipComplete,
    PostMembershipsUsersUserIdError,
    PostMembershipsUsersUserIdVariables
  >({
    mutationFn: (variables: PostMembershipsUsersUserIdVariables) =>
      fetchPostMembershipsUsersUserId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetMembershipsUsersUserIdAssociationMembershipIdPathParams = {
  userId: string;
  /**
   * @format uuid
   */
  associationMembershipId: string;
};

export type GetMembershipsUsersUserIdAssociationMembershipIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type GetMembershipsUsersUserIdAssociationMembershipIdResponse =
  Schemas.UserMembershipComplete[];

export type GetMembershipsUsersUserIdAssociationMembershipIdVariables = {
  pathParams: GetMembershipsUsersUserIdAssociationMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return all user memberships for a specific association membership for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetMembershipsUsersUserIdAssociationMembershipId = (
  variables: GetMembershipsUsersUserIdAssociationMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetMembershipsUsersUserIdAssociationMembershipIdResponse,
    GetMembershipsUsersUserIdAssociationMembershipIdError,
    undefined,
    {},
    {},
    GetMembershipsUsersUserIdAssociationMembershipIdPathParams
  >({
    url: "/memberships/users/{userId}/{associationMembershipId}",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all user memberships for a specific association membership for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export function getMembershipsUsersUserIdAssociationMembershipIdQuery(
  variables: GetMembershipsUsersUserIdAssociationMembershipIdVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<GetMembershipsUsersUserIdAssociationMembershipIdResponse>;
};

export function getMembershipsUsersUserIdAssociationMembershipIdQuery(
  variables:
    | GetMembershipsUsersUserIdAssociationMembershipIdVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<GetMembershipsUsersUserIdAssociationMembershipIdResponse>)
    | reactQuery.SkipToken;
};

export function getMembershipsUsersUserIdAssociationMembershipIdQuery(
  variables:
    | GetMembershipsUsersUserIdAssociationMembershipIdVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/memberships/users/{userId}/{associationMembershipId}",
      operationId: "getMembershipsUsersUserIdAssociationMembershipId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMembershipsUsersUserIdAssociationMembershipId(
              variables,
              signal,
            ),
  };
}

/**
 * Return all user memberships for a specific association membership for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetMembershipsUsersUserIdAssociationMembershipId = <
  TData = GetMembershipsUsersUserIdAssociationMembershipIdResponse,
>(
  variables: GetMembershipsUsersUserIdAssociationMembershipIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsUsersUserIdAssociationMembershipIdResponse,
      GetMembershipsUsersUserIdAssociationMembershipIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetMembershipsUsersUserIdAssociationMembershipIdResponse,
    GetMembershipsUsersUserIdAssociationMembershipIdError,
    TData
  >({
    ...getMembershipsUsersUserIdAssociationMembershipIdQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all user memberships for a specific association membership for a user.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetMembershipsUsersUserIdAssociationMembershipId = <
  TData = GetMembershipsUsersUserIdAssociationMembershipIdResponse,
>(
  variables:
    | GetMembershipsUsersUserIdAssociationMembershipIdVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetMembershipsUsersUserIdAssociationMembershipIdResponse,
      GetMembershipsUsersUserIdAssociationMembershipIdError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetMembershipsUsersUserIdAssociationMembershipIdResponse,
    GetMembershipsUsersUserIdAssociationMembershipIdError,
    TData
  >({
    ...getMembershipsUsersUserIdAssociationMembershipIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostMembershipsAssociationMembershipIdAddBatchPathParams = {
  /**
   * @format uuid
   */
  associationMembershipId: string;
};

export type PostMembershipsAssociationMembershipIdAddBatchError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostMembershipsAssociationMembershipIdAddBatchResponse =
  Schemas.MembershipUserMappingEmail[];

export type PostMembershipsAssociationMembershipIdAddBatchRequestBody =
  Schemas.MembershipUserMappingEmail[];

export type PostMembershipsAssociationMembershipIdAddBatchVariables = {
  body?: PostMembershipsAssociationMembershipIdAddBatchRequestBody;
  pathParams: PostMembershipsAssociationMembershipIdAddBatchPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Add a batch of user to a membership.
 *
 * Return the list of unknown users whose email is not in the database.
 *
 * **User must be an administrator to use this endpoint.**
 */
export const fetchPostMembershipsAssociationMembershipIdAddBatch = (
  variables: PostMembershipsAssociationMembershipIdAddBatchVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    PostMembershipsAssociationMembershipIdAddBatchResponse,
    PostMembershipsAssociationMembershipIdAddBatchError,
    PostMembershipsAssociationMembershipIdAddBatchRequestBody,
    {},
    {},
    PostMembershipsAssociationMembershipIdAddBatchPathParams
  >({
    url: "/memberships/{associationMembershipId}/add-batch/",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Add a batch of user to a membership.
 *
 * Return the list of unknown users whose email is not in the database.
 *
 * **User must be an administrator to use this endpoint.**
 */
export const usePostMembershipsAssociationMembershipIdAddBatch = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      PostMembershipsAssociationMembershipIdAddBatchResponse,
      PostMembershipsAssociationMembershipIdAddBatchError,
      PostMembershipsAssociationMembershipIdAddBatchVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    PostMembershipsAssociationMembershipIdAddBatchResponse,
    PostMembershipsAssociationMembershipIdAddBatchError,
    PostMembershipsAssociationMembershipIdAddBatchVariables
  >({
    mutationFn: (
      variables: PostMembershipsAssociationMembershipIdAddBatchVariables,
    ) =>
      fetchPostMembershipsAssociationMembershipIdAddBatch(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PatchMembershipsUsersMembershipIdPathParams = {
  /**
   * @format uuid
   */
  membershipId: string;
};

export type PatchMembershipsUsersMembershipIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchMembershipsUsersMembershipIdVariables = {
  body?: Schemas.UserMembershipEdit;
  pathParams: PatchMembershipsUsersMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update a user membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchMembershipsUsersMembershipId = (
  variables: PatchMembershipsUsersMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchMembershipsUsersMembershipIdError,
    Schemas.UserMembershipEdit,
    {},
    {},
    PatchMembershipsUsersMembershipIdPathParams
  >({
    url: "/memberships/users/{membershipId}",
    method: "patch",
    ...variables,
    signal,
  });

/**
 * Update a user membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchMembershipsUsersMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchMembershipsUsersMembershipIdError,
      PatchMembershipsUsersMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchMembershipsUsersMembershipIdError,
    PatchMembershipsUsersMembershipIdVariables
  >({
    mutationFn: (variables: PatchMembershipsUsersMembershipIdVariables) =>
      fetchPatchMembershipsUsersMembershipId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteMembershipsUsersMembershipIdPathParams = {
  /**
   * @format uuid
   */
  membershipId: string;
};

export type DeleteMembershipsUsersMembershipIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteMembershipsUsersMembershipIdVariables = {
  pathParams: DeleteMembershipsUsersMembershipIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a user membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteMembershipsUsersMembershipId = (
  variables: DeleteMembershipsUsersMembershipIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteMembershipsUsersMembershipIdError,
    undefined,
    {},
    {},
    DeleteMembershipsUsersMembershipIdPathParams
  >({
    url: "/memberships/users/{membershipId}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Delete a user membership.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteMembershipsUsersMembershipId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteMembershipsUsersMembershipIdError,
      DeleteMembershipsUsersMembershipIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteMembershipsUsersMembershipIdError,
    DeleteMembershipsUsersMembershipIdVariables
  >({
    mutationFn: (variables: DeleteMembershipsUsersMembershipIdVariables) =>
      fetchDeleteMembershipsUsersMembershipId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetGroupsError = Fetcher.ErrorWrapper<undefined>;

export type GetGroupsResponse = Schemas.CoreGroupSimple[];

export type GetGroupsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all groups from database as a list of dictionaries
 */
export const fetchGetGroups = (
  variables: GetGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<GetGroupsResponse, GetGroupsError, undefined, {}, {}, {}>({
    url: "/groups/",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return all groups from database as a list of dictionaries
 */
export function getGroupsQuery(variables: GetGroupsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetGroupsResponse>;
};

export function getGroupsQuery(
  variables: GetGroupsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetGroupsResponse>)
    | reactQuery.SkipToken;
};

export function getGroupsQuery(
  variables: GetGroupsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/groups/",
      operationId: "getGroups",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetGroups(variables, signal),
  };
}

/**
 * Return all groups from database as a list of dictionaries
 */
export const useSuspenseGetGroups = <TData = GetGroupsResponse,>(
  variables: GetGroupsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetGroupsResponse, GetGroupsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<GetGroupsResponse, GetGroupsError, TData>({
    ...getGroupsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all groups from database as a list of dictionaries
 */
export const useGetGroups = <TData = GetGroupsResponse,>(
  variables: GetGroupsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetGroupsResponse, GetGroupsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<GetGroupsResponse, GetGroupsError, TData>({
    ...getGroupsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostGroupsError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostGroupsVariables = {
  body: Schemas.CoreGroupCreate;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostGroups = (
  variables: PostGroupsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreGroupSimple,
    PostGroupsError,
    Schemas.CoreGroupCreate,
    {},
    {},
    {}
  >({ url: "/groups/", method: "post", ...variables, signal });

/**
 * Create a new group.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostGroups = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CoreGroupSimple,
      PostGroupsError,
      PostGroupsVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CoreGroupSimple,
    PostGroupsError,
    PostGroupsVariables
  >({
    mutationFn: (variables: PostGroupsVariables) =>
      fetchPostGroups(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetGroupsGroupIdPathParams = {
  groupId: string;
};

export type GetGroupsGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetGroupsGroupIdVariables = {
  pathParams: GetGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetGroupsGroupId = (
  variables: GetGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreGroup,
    GetGroupsGroupIdError,
    undefined,
    {},
    {},
    GetGroupsGroupIdPathParams
  >({ url: "/groups/{groupId}", method: "get", ...variables, signal });

/**
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export function getGroupsGroupIdQuery(variables: GetGroupsGroupIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CoreGroup>;
};

export function getGroupsGroupIdQuery(
  variables: GetGroupsGroupIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CoreGroup>)
    | reactQuery.SkipToken;
};

export function getGroupsGroupIdQuery(
  variables: GetGroupsGroupIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/groups/{groupId}",
      operationId: "getGroupsGroupId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetGroupsGroupId(variables, signal),
  };
}

/**
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetGroupsGroupId = <TData = Schemas.CoreGroup,>(
  variables: GetGroupsGroupIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreGroup, GetGroupsGroupIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CoreGroup,
    GetGroupsGroupIdError,
    TData
  >({
    ...getGroupsGroupIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return group with id from database as a dictionary. This includes a list of users being members of the group.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetGroupsGroupId = <TData = Schemas.CoreGroup,>(
  variables: GetGroupsGroupIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.CoreGroup, GetGroupsGroupIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<Schemas.CoreGroup, GetGroupsGroupIdError, TData>({
    ...getGroupsGroupIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PatchGroupsGroupIdPathParams = {
  groupId: string;
};

export type PatchGroupsGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PatchGroupsGroupIdVariables = {
  body?: Schemas.CoreGroupUpdate;
  pathParams: PatchGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Update the name or the description of a group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPatchGroupsGroupId = (
  variables: PatchGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PatchGroupsGroupIdError,
    Schemas.CoreGroupUpdate,
    {},
    {},
    PatchGroupsGroupIdPathParams
  >({ url: "/groups/{groupId}", method: "patch", ...variables, signal });

/**
 * Update the name or the description of a group.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePatchGroupsGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PatchGroupsGroupIdError,
      PatchGroupsGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PatchGroupsGroupIdError,
    PatchGroupsGroupIdVariables
  >({
    mutationFn: (variables: PatchGroupsGroupIdVariables) =>
      fetchPatchGroupsGroupId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteGroupsGroupIdPathParams = {
  groupId: string;
};

export type DeleteGroupsGroupIdError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteGroupsGroupIdVariables = {
  pathParams: DeleteGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Delete group from database.
 * This will remove the group from all users but won't delete any user.
 *
 * `GroupTypes` groups can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteGroupsGroupId = (
  variables: DeleteGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteGroupsGroupIdError,
    undefined,
    {},
    {},
    DeleteGroupsGroupIdPathParams
  >({ url: "/groups/{groupId}", method: "delete", ...variables, signal });

/**
 * Delete group from database.
 * This will remove the group from all users but won't delete any user.
 *
 * `GroupTypes` groups can not be deleted.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteGroupsGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteGroupsGroupIdError,
      DeleteGroupsGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteGroupsGroupIdError,
    DeleteGroupsGroupIdVariables
  >({
    mutationFn: (variables: DeleteGroupsGroupIdVariables) =>
      fetchDeleteGroupsGroupId(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostGroupsMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostGroupsMembershipVariables = {
  body: Schemas.CoreMembership;
} & HyperionContext["fetcherOptions"];

/**
 * Create a new membership in database and return the group. This allows to "add a user to a group".
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostGroupsMembership = (
  variables: PostGroupsMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreGroup,
    PostGroupsMembershipError,
    Schemas.CoreMembership,
    {},
    {},
    {}
  >({ url: "/groups/membership", method: "post", ...variables, signal });

/**
 * Create a new membership in database and return the group. This allows to "add a user to a group".
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostGroupsMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.CoreGroup,
      PostGroupsMembershipError,
      PostGroupsMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.CoreGroup,
    PostGroupsMembershipError,
    PostGroupsMembershipVariables
  >({
    mutationFn: (variables: PostGroupsMembershipVariables) =>
      fetchPostGroupsMembership(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteGroupsMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteGroupsMembershipVariables = {
  body: Schemas.CoreMembershipDelete;
} & HyperionContext["fetcherOptions"];

/**
 * Delete a membership using the user and group ids.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteGroupsMembership = (
  variables: DeleteGroupsMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteGroupsMembershipError,
    Schemas.CoreMembershipDelete,
    {},
    {},
    {}
  >({ url: "/groups/membership", method: "delete", ...variables, signal });

/**
 * Delete a membership using the user and group ids.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteGroupsMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteGroupsMembershipError,
      DeleteGroupsMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteGroupsMembershipError,
    DeleteGroupsMembershipVariables
  >({
    mutationFn: (variables: DeleteGroupsMembershipVariables) =>
      fetchDeleteGroupsMembership(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostGroupsBatchMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostGroupsBatchMembershipVariables = {
  body: Schemas.CoreBatchMembership;
} & HyperionContext["fetcherOptions"];

/**
 * Add a list of user to a group, using a list of email.
 * If an user does not exist it will be ignored.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostGroupsBatchMembership = (
  variables: PostGroupsBatchMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostGroupsBatchMembershipError,
    Schemas.CoreBatchMembership,
    {},
    {},
    {}
  >({ url: "/groups/batch-membership", method: "post", ...variables, signal });

/**
 * Add a list of user to a group, using a list of email.
 * If an user does not exist it will be ignored.
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostGroupsBatchMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostGroupsBatchMembershipError,
      PostGroupsBatchMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostGroupsBatchMembershipError,
    PostGroupsBatchMembershipVariables
  >({
    mutationFn: (variables: PostGroupsBatchMembershipVariables) =>
      fetchPostGroupsBatchMembership(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteGroupsBatchMembershipError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteGroupsBatchMembershipVariables = {
  body: Schemas.CoreBatchDeleteMembership;
} & HyperionContext["fetcherOptions"];

/**
 * This endpoint removes all users from a given group.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchDeleteGroupsBatchMembership = (
  variables: DeleteGroupsBatchMembershipVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteGroupsBatchMembershipError,
    Schemas.CoreBatchDeleteMembership,
    {},
    {},
    {}
  >({
    url: "/groups/batch-membership",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * This endpoint removes all users from a given group.
 *
 * **This endpoint is only usable by administrators**
 */
export const useDeleteGroupsBatchMembership = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteGroupsBatchMembershipError,
      DeleteGroupsBatchMembershipVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteGroupsBatchMembershipError,
    DeleteGroupsBatchMembershipVariables
  >({
    mutationFn: (variables: DeleteGroupsBatchMembershipVariables) =>
      fetchDeleteGroupsBatchMembership(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetInformationError = Fetcher.ErrorWrapper<undefined>;

export type GetInformationVariables = HyperionContext["fetcherOptions"];

/**
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export const fetchGetInformation = (
  variables: GetInformationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.CoreInformation,
    GetInformationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/information", method: "get", ...variables, signal });

/**
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export function getInformationQuery(variables: GetInformationVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.CoreInformation>;
};

export function getInformationQuery(
  variables: GetInformationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.CoreInformation>)
    | reactQuery.SkipToken;
};

export function getInformationQuery(
  variables: GetInformationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/information",
      operationId: "getInformation",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetInformation(variables, signal),
  };
}

/**
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export const useSuspenseGetInformation = <TData = Schemas.CoreInformation,>(
  variables: GetInformationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CoreInformation,
      GetInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.CoreInformation,
    GetInformationError,
    TData
  >({
    ...getInformationQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return information about Hyperion. This endpoint can be used to check if the API is up.
 */
export const useGetInformation = <TData = Schemas.CoreInformation,>(
  variables: GetInformationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.CoreInformation,
      GetInformationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    Schemas.CoreInformation,
    GetInformationError,
    TData
  >({
    ...getInformationQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetPrivacyError = Fetcher.ErrorWrapper<undefined>;

export type GetPrivacyVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion privacy
 */
export const fetchGetPrivacy = (
  variables: GetPrivacyVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetPrivacyError, undefined, {}, {}, {}>({
    url: "/privacy",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion privacy
 */
export function getPrivacyQuery(variables: GetPrivacyVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getPrivacyQuery(
  variables: GetPrivacyVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getPrivacyQuery(
  variables: GetPrivacyVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/privacy",
      operationId: "getPrivacy",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetPrivacy(variables, signal),
  };
}

/**
 * Return Hyperion privacy
 */
export const useSuspenseGetPrivacy = <TData = undefined,>(
  variables: GetPrivacyVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetPrivacyError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetPrivacyError, TData>({
    ...getPrivacyQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return Hyperion privacy
 */
export const useGetPrivacy = <TData = undefined,>(
  variables: GetPrivacyVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetPrivacyError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetPrivacyError, TData>({
    ...getPrivacyQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetTermsAndConditionsError = Fetcher.ErrorWrapper<undefined>;

export type GetTermsAndConditionsVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion terms and conditions pages
 */
export const fetchGetTermsAndConditions = (
  variables: GetTermsAndConditionsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetTermsAndConditionsError, undefined, {}, {}, {}>({
    url: "/terms-and-conditions",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion terms and conditions pages
 */
export function getTermsAndConditionsQuery(
  variables: GetTermsAndConditionsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getTermsAndConditionsQuery(
  variables: GetTermsAndConditionsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getTermsAndConditionsQuery(
  variables: GetTermsAndConditionsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/terms-and-conditions",
      operationId: "getTermsAndConditions",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetTermsAndConditions(variables, signal),
  };
}

/**
 * Return Hyperion terms and conditions pages
 */
export const useSuspenseGetTermsAndConditions = <TData = undefined,>(
  variables: GetTermsAndConditionsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetTermsAndConditionsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetTermsAndConditionsError,
    TData
  >({
    ...getTermsAndConditionsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return Hyperion terms and conditions pages
 */
export const useGetTermsAndConditions = <TData = undefined,>(
  variables: GetTermsAndConditionsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetTermsAndConditionsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetTermsAndConditionsError, TData>({
    ...getTermsAndConditionsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetMyeclpayTermsOfServiceError = Fetcher.ErrorWrapper<undefined>;

export type GetMyeclpayTermsOfServiceVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return MyECLPay latest ToS
 */
export const fetchGetMyeclpayTermsOfService = (
  variables: GetMyeclpayTermsOfServiceVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetMyeclpayTermsOfServiceError,
    undefined,
    {},
    {},
    {}
  >({ url: "/myeclpay-terms-of-service", method: "get", ...variables, signal });

/**
 * Return MyECLPay latest ToS
 */
export function getMyeclpayTermsOfServiceQuery(
  variables: GetMyeclpayTermsOfServiceVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getMyeclpayTermsOfServiceQuery(
  variables: GetMyeclpayTermsOfServiceVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getMyeclpayTermsOfServiceQuery(
  variables: GetMyeclpayTermsOfServiceVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/myeclpay-terms-of-service",
      operationId: "getMyeclpayTermsOfService",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetMyeclpayTermsOfService(variables, signal),
  };
}

/**
 * Return MyECLPay latest ToS
 */
export const useSuspenseGetMyeclpayTermsOfService = <TData = undefined,>(
  variables: GetMyeclpayTermsOfServiceVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetMyeclpayTermsOfServiceError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetMyeclpayTermsOfServiceError,
    TData
  >({
    ...getMyeclpayTermsOfServiceQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return MyECLPay latest ToS
 */
export const useGetMyeclpayTermsOfService = <TData = undefined,>(
  variables: GetMyeclpayTermsOfServiceVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      undefined,
      GetMyeclpayTermsOfServiceError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetMyeclpayTermsOfServiceError, TData>({
    ...getMyeclpayTermsOfServiceQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetSupportError = Fetcher.ErrorWrapper<undefined>;

export type GetSupportVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion support
 */
export const fetchGetSupport = (
  variables: GetSupportVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetSupportError, undefined, {}, {}, {}>({
    url: "/support",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion support
 */
export function getSupportQuery(variables: GetSupportVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getSupportQuery(
  variables: GetSupportVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getSupportQuery(
  variables: GetSupportVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/support",
      operationId: "getSupport",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetSupport(variables, signal),
  };
}

/**
 * Return Hyperion support
 */
export const useSuspenseGetSupport = <TData = undefined,>(
  variables: GetSupportVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetSupportError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetSupportError, TData>({
    ...getSupportQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return Hyperion support
 */
export const useGetSupport = <TData = undefined,>(
  variables: GetSupportVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetSupportError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetSupportError, TData>({
    ...getSupportQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetSecurityTxtError = Fetcher.ErrorWrapper<undefined>;

export type GetSecurityTxtVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion security.txt file
 */
export const fetchGetSecurityTxt = (
  variables: GetSecurityTxtVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetSecurityTxtError, undefined, {}, {}, {}>({
    url: "/security.txt",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion security.txt file
 */
export function getSecurityTxtQuery(variables: GetSecurityTxtVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getSecurityTxtQuery(
  variables: GetSecurityTxtVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getSecurityTxtQuery(
  variables: GetSecurityTxtVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/security.txt",
      operationId: "getSecurityTxt",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetSecurityTxt(variables, signal),
  };
}

/**
 * Return Hyperion security.txt file
 */
export const useSuspenseGetSecurityTxt = <TData = undefined,>(
  variables: GetSecurityTxtVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetSecurityTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetSecurityTxtError, TData>({
    ...getSecurityTxtQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return Hyperion security.txt file
 */
export const useGetSecurityTxt = <TData = undefined,>(
  variables: GetSecurityTxtVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetSecurityTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetSecurityTxtError, TData>({
    ...getSecurityTxtQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetWellKnownSecurityTxtError = Fetcher.ErrorWrapper<undefined>;

export type GetWellKnownSecurityTxtVariables =
  HyperionContext["fetcherOptions"];

/**
 * Return Hyperion security.txt file
 */
export const fetchGetWellKnownSecurityTxt = (
  variables: GetWellKnownSecurityTxtVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetWellKnownSecurityTxtError, undefined, {}, {}, {}>(
    { url: "/.well-known/security.txt", method: "get", ...variables, signal },
  );

/**
 * Return Hyperion security.txt file
 */
export function getWellKnownSecurityTxtQuery(
  variables: GetWellKnownSecurityTxtVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getWellKnownSecurityTxtQuery(
  variables: GetWellKnownSecurityTxtVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getWellKnownSecurityTxtQuery(
  variables: GetWellKnownSecurityTxtVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/.well-known/security.txt",
      operationId: "getWellKnownSecurityTxt",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetWellKnownSecurityTxt(variables, signal),
  };
}

/**
 * Return Hyperion security.txt file
 */
export const useSuspenseGetWellKnownSecurityTxt = <TData = undefined,>(
  variables: GetWellKnownSecurityTxtVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetWellKnownSecurityTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    undefined,
    GetWellKnownSecurityTxtError,
    TData
  >({
    ...getWellKnownSecurityTxtQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return Hyperion security.txt file
 */
export const useGetWellKnownSecurityTxt = <TData = undefined,>(
  variables: GetWellKnownSecurityTxtVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetWellKnownSecurityTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetWellKnownSecurityTxtError, TData>({
    ...getWellKnownSecurityTxtQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetRobotsTxtError = Fetcher.ErrorWrapper<undefined>;

export type GetRobotsTxtVariables = HyperionContext["fetcherOptions"];

/**
 * Return Hyperion robots.txt file
 */
export const fetchGetRobotsTxt = (
  variables: GetRobotsTxtVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetRobotsTxtError, undefined, {}, {}, {}>({
    url: "/robots.txt",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Return Hyperion robots.txt file
 */
export function getRobotsTxtQuery(variables: GetRobotsTxtVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getRobotsTxtQuery(
  variables: GetRobotsTxtVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getRobotsTxtQuery(
  variables: GetRobotsTxtVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/robots.txt",
      operationId: "getRobotsTxt",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetRobotsTxt(variables, signal),
  };
}

/**
 * Return Hyperion robots.txt file
 */
export const useSuspenseGetRobotsTxt = <TData = undefined,>(
  variables: GetRobotsTxtVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetRobotsTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetRobotsTxtError, TData>({
    ...getRobotsTxtQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return Hyperion robots.txt file
 */
export const useGetRobotsTxt = <TData = undefined,>(
  variables: GetRobotsTxtVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetRobotsTxtError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetRobotsTxtError, TData>({
    ...getRobotsTxtQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetStyleFileCssPathParams = {
  file: string;
};

export type GetStyleFileCssError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetStyleFileCssVariables = {
  pathParams: GetStyleFileCssPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Return a style file from the assets folder
 */
export const fetchGetStyleFileCss = (
  variables: GetStyleFileCssVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetStyleFileCssError,
    undefined,
    {},
    {},
    GetStyleFileCssPathParams
  >({ url: "/style/{file}.css", method: "get", ...variables, signal });

/**
 * Return a style file from the assets folder
 */
export function getStyleFileCssQuery(variables: GetStyleFileCssVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getStyleFileCssQuery(
  variables: GetStyleFileCssVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getStyleFileCssQuery(
  variables: GetStyleFileCssVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/style/{file}.css",
      operationId: "getStyleFileCss",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetStyleFileCss(variables, signal),
  };
}

/**
 * Return a style file from the assets folder
 */
export const useSuspenseGetStyleFileCss = <TData = undefined,>(
  variables: GetStyleFileCssVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetStyleFileCssError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetStyleFileCssError, TData>({
    ...getStyleFileCssQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return a style file from the assets folder
 */
export const useGetStyleFileCss = <TData = undefined,>(
  variables: GetStyleFileCssVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetStyleFileCssError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetStyleFileCssError, TData>({
    ...getStyleFileCssQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetFaviconIcoError = Fetcher.ErrorWrapper<undefined>;

export type GetFaviconIcoVariables = HyperionContext["fetcherOptions"];

export const fetchGetFaviconIco = (
  variables: GetFaviconIcoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, GetFaviconIcoError, undefined, {}, {}, {}>({
    url: "/favicon.ico",
    method: "get",
    ...variables,
    signal,
  });

export function getFaviconIcoQuery(variables: GetFaviconIcoVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getFaviconIcoQuery(
  variables: GetFaviconIcoVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getFaviconIcoQuery(
  variables: GetFaviconIcoVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/favicon.ico",
      operationId: "getFaviconIco",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetFaviconIco(variables, signal),
  };
}

export const useSuspenseGetFaviconIco = <TData = undefined,>(
  variables: GetFaviconIcoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetFaviconIcoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetFaviconIcoError, TData>({
    ...getFaviconIcoQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetFaviconIco = <TData = undefined,>(
  variables: GetFaviconIcoVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetFaviconIcoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetFaviconIcoError, TData>({
    ...getFaviconIcoQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetModuleVisibilityError = Fetcher.ErrorWrapper<undefined>;

export type GetModuleVisibilityResponse = Schemas.ModuleVisibility[];

export type GetModuleVisibilityVariables = HyperionContext["fetcherOptions"];

/**
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchGetModuleVisibility = (
  variables: GetModuleVisibilityVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetModuleVisibilityResponse,
    GetModuleVisibilityError,
    undefined,
    {},
    {},
    {}
  >({ url: "/module-visibility/", method: "get", ...variables, signal });

/**
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export function getModuleVisibilityQuery(
  variables: GetModuleVisibilityVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetModuleVisibilityResponse>;
};

export function getModuleVisibilityQuery(
  variables: GetModuleVisibilityVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetModuleVisibilityResponse>)
    | reactQuery.SkipToken;
};

export function getModuleVisibilityQuery(
  variables: GetModuleVisibilityVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/module-visibility/",
      operationId: "getModuleVisibility",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetModuleVisibility(variables, signal),
  };
}

/**
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export const useSuspenseGetModuleVisibility = <
  TData = GetModuleVisibilityResponse,
>(
  variables: GetModuleVisibilityVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetModuleVisibilityResponse,
      GetModuleVisibilityError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetModuleVisibilityResponse,
    GetModuleVisibilityError,
    TData
  >({
    ...getModuleVisibilityQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all existing module_visibility.
 *
 * **This endpoint is only usable by administrators**
 */
export const useGetModuleVisibility = <TData = GetModuleVisibilityResponse,>(
  variables: GetModuleVisibilityVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetModuleVisibilityResponse,
      GetModuleVisibilityError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetModuleVisibilityResponse,
    GetModuleVisibilityError,
    TData
  >({
    ...getModuleVisibilityQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostModuleVisibilityError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostModuleVisibilityVariables = {
  body: Schemas.ModuleVisibilityCreate;
} & HyperionContext["fetcherOptions"];

/**
 * Add a new group or account type to a module
 *
 * **This endpoint is only usable by administrators**
 */
export const fetchPostModuleVisibility = (
  variables: PostModuleVisibilityVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    PostModuleVisibilityError,
    Schemas.ModuleVisibilityCreate,
    {},
    {},
    {}
  >({ url: "/module-visibility/", method: "post", ...variables, signal });

/**
 * Add a new group or account type to a module
 *
 * **This endpoint is only usable by administrators**
 */
export const usePostModuleVisibility = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostModuleVisibilityError,
      PostModuleVisibilityVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostModuleVisibilityError,
    PostModuleVisibilityVariables
  >({
    mutationFn: (variables: PostModuleVisibilityVariables) =>
      fetchPostModuleVisibility(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetModuleVisibilityMeError = Fetcher.ErrorWrapper<undefined>;

export type GetModuleVisibilityMeResponse = string[];

export type GetModuleVisibilityMeVariables = HyperionContext["fetcherOptions"];

/**
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export const fetchGetModuleVisibilityMe = (
  variables: GetModuleVisibilityMeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetModuleVisibilityMeResponse,
    GetModuleVisibilityMeError,
    undefined,
    {},
    {},
    {}
  >({ url: "/module-visibility/me", method: "get", ...variables, signal });

/**
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export function getModuleVisibilityMeQuery(
  variables: GetModuleVisibilityMeVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetModuleVisibilityMeResponse>;
};

export function getModuleVisibilityMeQuery(
  variables: GetModuleVisibilityMeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetModuleVisibilityMeResponse>)
    | reactQuery.SkipToken;
};

export function getModuleVisibilityMeQuery(
  variables: GetModuleVisibilityMeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/module-visibility/me",
      operationId: "getModuleVisibilityMe",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetModuleVisibilityMe(variables, signal),
  };
}

/**
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export const useSuspenseGetModuleVisibilityMe = <
  TData = GetModuleVisibilityMeResponse,
>(
  variables: GetModuleVisibilityMeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetModuleVisibilityMeResponse,
      GetModuleVisibilityMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetModuleVisibilityMeResponse,
    GetModuleVisibilityMeError,
    TData
  >({
    ...getModuleVisibilityMeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get group user accessible root
 *
 * **This endpoint is only usable by everyone**
 */
export const useGetModuleVisibilityMe = <
  TData = GetModuleVisibilityMeResponse,
>(
  variables: GetModuleVisibilityMeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetModuleVisibilityMeResponse,
      GetModuleVisibilityMeError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetModuleVisibilityMeResponse,
    GetModuleVisibilityMeError,
    TData
  >({
    ...getModuleVisibilityMeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DeleteModuleVisibilityRootGroupsGroupIdPathParams = {
  root: string;
  groupId: string;
};

export type DeleteModuleVisibilityRootGroupsGroupIdError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteModuleVisibilityRootGroupsGroupIdVariables = {
  pathParams: DeleteModuleVisibilityRootGroupsGroupIdPathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteModuleVisibilityRootGroupsGroupId = (
  variables: DeleteModuleVisibilityRootGroupsGroupIdVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteModuleVisibilityRootGroupsGroupIdError,
    undefined,
    {},
    {},
    DeleteModuleVisibilityRootGroupsGroupIdPathParams
  >({
    url: "/module-visibility/{root}/groups/{groupId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteModuleVisibilityRootGroupsGroupId = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteModuleVisibilityRootGroupsGroupIdError,
      DeleteModuleVisibilityRootGroupsGroupIdVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteModuleVisibilityRootGroupsGroupIdError,
    DeleteModuleVisibilityRootGroupsGroupIdVariables
  >({
    mutationFn: (variables: DeleteModuleVisibilityRootGroupsGroupIdVariables) =>
      fetchDeleteModuleVisibilityRootGroupsGroupId(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type DeleteModuleVisibilityRootAccountTypesAccountTypePathParams = {
  root: string;
  accountType: Schemas.AccountType;
};

export type DeleteModuleVisibilityRootAccountTypesAccountTypeError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type DeleteModuleVisibilityRootAccountTypesAccountTypeVariables = {
  pathParams: DeleteModuleVisibilityRootAccountTypesAccountTypePathParams;
} & HyperionContext["fetcherOptions"];

export const fetchDeleteModuleVisibilityRootAccountTypesAccountType = (
  variables: DeleteModuleVisibilityRootAccountTypesAccountTypeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteModuleVisibilityRootAccountTypesAccountTypeError,
    undefined,
    {},
    {},
    DeleteModuleVisibilityRootAccountTypesAccountTypePathParams
  >({
    url: "/module-visibility/{root}/account-types/{accountType}",
    method: "delete",
    ...variables,
    signal,
  });

export const useDeleteModuleVisibilityRootAccountTypesAccountType = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteModuleVisibilityRootAccountTypesAccountTypeError,
      DeleteModuleVisibilityRootAccountTypesAccountTypeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteModuleVisibilityRootAccountTypesAccountTypeError,
    DeleteModuleVisibilityRootAccountTypesAccountTypeVariables
  >({
    mutationFn: (
      variables: DeleteModuleVisibilityRootAccountTypesAccountTypeVariables,
    ) =>
      fetchDeleteModuleVisibilityRootAccountTypesAccountType(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostAuthSimpleTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthSimpleTokenVariables = HyperionContext["fetcherOptions"];

/**
 * Ask for a JWT access token using oauth password flow.
 *
 * *username* and *password* must be provided
 *
 * Note: the request body needs to use **form-data** and not json.
 */
export const fetchPostAuthSimpleToken = (
  variables: PostAuthSimpleTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.AccessToken,
    PostAuthSimpleTokenError,
    undefined,
    {},
    {},
    {}
  >({ url: "/auth/simple_token", method: "post", ...variables, signal });

/**
 * Ask for a JWT access token using oauth password flow.
 *
 * *username* and *password* must be provided
 *
 * Note: the request body needs to use **form-data** and not json.
 */
export const usePostAuthSimpleToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.AccessToken,
      PostAuthSimpleTokenError,
      PostAuthSimpleTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.AccessToken,
    PostAuthSimpleTokenError,
    PostAuthSimpleTokenVariables
  >({
    mutationFn: (variables: PostAuthSimpleTokenVariables) =>
      fetchPostAuthSimpleToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAuthAuthorizeQueryParams = {
  client_id: string;
  redirect_uri?: string | null;
  response_type: string;
  scope?: string | null;
  state?: string | null;
  nonce?: string | null;
  code_challenge?: string | null;
  code_challenge_method?: string | null;
};

export type GetAuthAuthorizeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type GetAuthAuthorizeVariables = {
  queryParams: GetAuthAuthorizeQueryParams;
} & HyperionContext["fetcherOptions"];

/**
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const fetchGetAuthAuthorize = (
  variables: GetAuthAuthorizeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    GetAuthAuthorizeError,
    undefined,
    {},
    GetAuthAuthorizeQueryParams,
    {}
  >({ url: "/auth/authorize", method: "get", ...variables, signal });

/**
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export function getAuthAuthorizeQuery(variables: GetAuthAuthorizeVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getAuthAuthorizeQuery(
  variables: GetAuthAuthorizeVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getAuthAuthorizeQuery(
  variables: GetAuthAuthorizeVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/auth/authorize",
      operationId: "getAuthAuthorize",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAuthAuthorize(variables, signal),
  };
}

/**
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const useSuspenseGetAuthAuthorize = <TData = undefined,>(
  variables: GetAuthAuthorizeVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetAuthAuthorizeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetAuthAuthorizeError, TData>({
    ...getAuthAuthorizeQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * This endpoint is the one the user is redirected to when they begin the Oauth or Openid connect (*oidc*) *Authorization code* process.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const useGetAuthAuthorize = <TData = undefined,>(
  variables: GetAuthAuthorizeVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetAuthAuthorizeError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<undefined, GetAuthAuthorizeError, TData>({
    ...getAuthAuthorizeQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostAuthAuthorizeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthAuthorizeVariables = HyperionContext["fetcherOptions"];

/**
 * This endpoint is the one the user is redirected to when they begin the OAuth or Openid connect (*oidc*) *Authorization code* process with or without PKCE.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const fetchPostAuthAuthorize = (
  variables: PostAuthAuthorizeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<undefined, PostAuthAuthorizeError, undefined, {}, {}, {}>({
    url: "/auth/authorize",
    method: "post",
    ...variables,
    signal,
  });

/**
 * This endpoint is the one the user is redirected to when they begin the OAuth or Openid connect (*oidc*) *Authorization code* process with or without PKCE.
 * The page allows the user to login and may let the user choose what type of data they want to authorize the client for.
 *
 * This is the endpoint that should be set in the client OAuth or OIDC configuration page. It can be called by a GET or a POST request.
 *
 * See `/auth/authorization-flow/authorize-validation` endpoint for information about the parameters.
 *
 * > In order for the authorization code grant to be secure, the authorization page must appear in a web browser the user is familiar with,
 * > and must not be embedded in an iframe popup or an embedded browser in a mobile app.
 * > If it could be embedded in another website, the user would have no way of verifying it is the legitimate service and is not a phishing attempt.
 *
 * **This endpoint is a UI endpoint which send and html page response. It will redirect to `/auth/authorization-flow/authorize-validation`**
 */
export const usePostAuthAuthorize = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAuthAuthorizeError,
      PostAuthAuthorizeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAuthAuthorizeError,
    PostAuthAuthorizeVariables
  >({
    mutationFn: (variables: PostAuthAuthorizeVariables) =>
      fetchPostAuthAuthorize(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostAuthAuthorizationFlowAuthorizeValidationError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostAuthAuthorizationFlowAuthorizeValidationVariables =
  HyperionContext["fetcherOptions"];

/**
 * Part 1 of the authorization code grant.
 *
 * Parameters must be `application/x-www-form-urlencoded` and includes:
 *
 * * parameters for OAuth and Openid connect:
 *     * `response_type`: must be `code`
 *     * `client_id`: client identifier, needs to be registered in the server known_clients
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization.
 *     * `scope`: optional for OAuth, must contain "openid" for oidc. List of scope the client want to get access to.
 *     * `state`: recommended. Opaque value used to maintain state between the request and the callback.
 *
 * * additional parameters for Openid connect:
 *     * `nonce`: oidc only. A string value used to associate a client session with an ID Token, and to mitigate replay attacks.
 *
 * * additional parameters for PKCE (see specs on https://datatracker.ietf.org/doc/html/rfc7636/):
 *     * `code_challenge`: PKCE only
 *     * `code_challenge_method`: PKCE only
 *
 *
 * * parameters that allows to authenticate the user and know which scopes he grants access to.
 *     * `email`
 *     * `password`
 *
 * References:
 *  * https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2
 *  * https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
 */
export const fetchPostAuthAuthorizationFlowAuthorizeValidation = (
  variables: PostAuthAuthorizationFlowAuthorizeValidationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostAuthAuthorizationFlowAuthorizeValidationError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/auth/authorization-flow/authorize-validation",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Part 1 of the authorization code grant.
 *
 * Parameters must be `application/x-www-form-urlencoded` and includes:
 *
 * * parameters for OAuth and Openid connect:
 *     * `response_type`: must be `code`
 *     * `client_id`: client identifier, needs to be registered in the server known_clients
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization.
 *     * `scope`: optional for OAuth, must contain "openid" for oidc. List of scope the client want to get access to.
 *     * `state`: recommended. Opaque value used to maintain state between the request and the callback.
 *
 * * additional parameters for Openid connect:
 *     * `nonce`: oidc only. A string value used to associate a client session with an ID Token, and to mitigate replay attacks.
 *
 * * additional parameters for PKCE (see specs on https://datatracker.ietf.org/doc/html/rfc7636/):
 *     * `code_challenge`: PKCE only
 *     * `code_challenge_method`: PKCE only
 *
 *
 * * parameters that allows to authenticate the user and know which scopes he grants access to.
 *     * `email`
 *     * `password`
 *
 * References:
 *  * https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2
 *  * https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest
 */
export const usePostAuthAuthorizationFlowAuthorizeValidation = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostAuthAuthorizationFlowAuthorizeValidationError,
      PostAuthAuthorizationFlowAuthorizeValidationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostAuthAuthorizationFlowAuthorizeValidationError,
    PostAuthAuthorizationFlowAuthorizeValidationVariables
  >({
    mutationFn: (
      variables: PostAuthAuthorizationFlowAuthorizeValidationVariables,
    ) =>
      fetchPostAuthAuthorizationFlowAuthorizeValidation(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostAuthTokenHeaders = {
  authorization?: string | null;
};

export type PostAuthTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthTokenVariables = {
  headers?: PostAuthTokenHeaders;
} & HyperionContext["fetcherOptions"];

/**
 * Part 2 of the authorization code grant.
 * The client exchange its authorization code for an access token. The endpoint supports OAuth and Openid connect, with or without PKCE.
 *
 * Parameters must be `application/x-www-form-urlencoded` and include:
 *
 * * parameters for OAuth and Openid connect:
 *     * `grant_type`: must be `authorization_code` or `refresh_token`
 *     * `code`: the authorization code received from the authorization endpoint
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization. If provided, must be the same as previously registered in the `redirect_uri` field of the client.
 *
 * * Client credentials
 *     The client must send either:
 *         the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * * additional parameters for PKCE:
 *     * `code_verifier`: PKCE only, allows to verify the previous code_challenge
 *
 * https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
 * https://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation
 */
export const fetchPostAuthToken = (
  variables: PostAuthTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.TokenResponse,
    PostAuthTokenError,
    undefined,
    PostAuthTokenHeaders,
    {},
    {}
  >({ url: "/auth/token", method: "post", ...variables, signal });

/**
 * Part 2 of the authorization code grant.
 * The client exchange its authorization code for an access token. The endpoint supports OAuth and Openid connect, with or without PKCE.
 *
 * Parameters must be `application/x-www-form-urlencoded` and include:
 *
 * * parameters for OAuth and Openid connect:
 *     * `grant_type`: must be `authorization_code` or `refresh_token`
 *     * `code`: the authorization code received from the authorization endpoint
 *     * `redirect_uri`: optional for OAuth (when registered in known_clients) but required for oidc. The url we need to redirect the user to after the authorization. If provided, must be the same as previously registered in the `redirect_uri` field of the client.
 *
 * * Client credentials
 *     The client must send either:
 *         the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * * additional parameters for PKCE:
 *     * `code_verifier`: PKCE only, allows to verify the previous code_challenge
 *
 * https://datatracker.ietf.org/doc/html/rfc6749#section-4.1.3
 * https://openid.net/specs/openid-connect-core-1_0.html#TokenRequestValidation
 */
export const usePostAuthToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.TokenResponse,
      PostAuthTokenError,
      PostAuthTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.TokenResponse,
    PostAuthTokenError,
    PostAuthTokenVariables
  >({
    mutationFn: (variables: PostAuthTokenVariables) =>
      fetchPostAuthToken(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostAuthIntrospectHeaders = {
  authorization?: string | null;
};

export type PostAuthIntrospectError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostAuthIntrospectVariables = {
  headers?: PostAuthIntrospectHeaders;
} & HyperionContext["fetcherOptions"];

/**
 * Some clients requires an endpoint to check if an access token or a refresh token is valid.
 * This endpoint should not be publicly accessible, and is thus restricted to some AuthClient.
 *
 * * parameters:
 *     * `token`: the token to introspect
 *     * `token_type_hint`: may be `access_token` or `refresh_token`, we currently do not use this hint as we are able to differentiate access and refresh tokens
 *
 * * Client credentials
 *     The client must send either:
 *         the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * Reference:
 * https://www.oauth.com/oauth2-servers/token-introspection-endpoint/
 * https://datatracker.ietf.org/doc/html/rfc7662
 */
export const fetchPostAuthIntrospect = (
  variables: PostAuthIntrospectVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    Schemas.IntrospectTokenResponse,
    PostAuthIntrospectError,
    undefined,
    PostAuthIntrospectHeaders,
    {},
    {}
  >({ url: "/auth/introspect", method: "post", ...variables, signal });

/**
 * Some clients requires an endpoint to check if an access token or a refresh token is valid.
 * This endpoint should not be publicly accessible, and is thus restricted to some AuthClient.
 *
 * * parameters:
 *     * `token`: the token to introspect
 *     * `token_type_hint`: may be `access_token` or `refresh_token`, we currently do not use this hint as we are able to differentiate access and refresh tokens
 *
 * * Client credentials
 *     The client must send either:
 *         the client id and secret in the authorization header or with client_id and client_secret parameters
 *
 * Reference:
 * https://www.oauth.com/oauth2-servers/token-introspection-endpoint/
 * https://datatracker.ietf.org/doc/html/rfc7662
 */
export const usePostAuthIntrospect = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.IntrospectTokenResponse,
      PostAuthIntrospectError,
      PostAuthIntrospectVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    Schemas.IntrospectTokenResponse,
    PostAuthIntrospectError,
    PostAuthIntrospectVariables
  >({
    mutationFn: (variables: PostAuthIntrospectVariables) =>
      fetchPostAuthIntrospect(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetAuthUserinfoError = Fetcher.ErrorWrapper<undefined>;

export type GetAuthUserinfoVariables = HyperionContext["fetcherOptions"];

/**
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export const fetchGetAuthUserinfo = (
  variables: GetAuthUserinfoVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, GetAuthUserinfoError, undefined, {}, {}, {}>({
    url: "/auth/userinfo",
    method: "get",
    ...variables,
    signal,
  });

/**
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export function getAuthUserinfoQuery(variables: GetAuthUserinfoVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getAuthUserinfoQuery(
  variables: GetAuthUserinfoVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getAuthUserinfoQuery(
  variables: GetAuthUserinfoVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/auth/userinfo",
      operationId: "getAuthUserinfo",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetAuthUserinfo(variables, signal),
  };
}

/**
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export const useSuspenseGetAuthUserinfo = <TData = void,>(
  variables: GetAuthUserinfoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetAuthUserinfoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<void, GetAuthUserinfoError, TData>({
    ...getAuthUserinfoQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Openid connect specify an endpoint the client can use to get information about the user.
 * The oidc client will provide the access_token it got previously in the request.
 *
 * The information expected depends on the client and may include the user identifier, name, email, phone...
 * See the reference for possible claims. See the client documentation and implementation to know what it needs and can receive.
 * The sub (subject) Claim MUST always be returned in the UserInfo Response.
 *
 * The client can ask for specific information using scopes and claims. See the reference for more information.
 * This procedure is not implemented in Hyperion as we can customize the response using auth_client class
 *
 * Reference:
 * https://openid.net/specs/openid-connect-core-1_0.html#UserInfo
 */
export const useGetAuthUserinfo = <TData = void,>(
  variables: GetAuthUserinfoVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetAuthUserinfoError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetAuthUserinfoError, TData>({
    ...getAuthUserinfoQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetOidcAuthorizationFlowJwksUriError =
  Fetcher.ErrorWrapper<undefined>;

export type GetOidcAuthorizationFlowJwksUriVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetOidcAuthorizationFlowJwksUri = (
  variables: GetOidcAuthorizationFlowJwksUriVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetOidcAuthorizationFlowJwksUriError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/oidc/authorization-flow/jwks_uri",
    method: "get",
    ...variables,
    signal,
  });

export function getOidcAuthorizationFlowJwksUriQuery(
  variables: GetOidcAuthorizationFlowJwksUriVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getOidcAuthorizationFlowJwksUriQuery(
  variables: GetOidcAuthorizationFlowJwksUriVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getOidcAuthorizationFlowJwksUriQuery(
  variables: GetOidcAuthorizationFlowJwksUriVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/oidc/authorization-flow/jwks_uri",
      operationId: "getOidcAuthorizationFlowJwksUri",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetOidcAuthorizationFlowJwksUri(variables, signal),
  };
}

export const useSuspenseGetOidcAuthorizationFlowJwksUri = <TData = void,>(
  variables: GetOidcAuthorizationFlowJwksUriVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetOidcAuthorizationFlowJwksUriError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetOidcAuthorizationFlowJwksUriError,
    TData
  >({
    ...getOidcAuthorizationFlowJwksUriQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetOidcAuthorizationFlowJwksUri = <TData = void,>(
  variables: GetOidcAuthorizationFlowJwksUriVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetOidcAuthorizationFlowJwksUriError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetOidcAuthorizationFlowJwksUriError, TData>(
    {
      ...getOidcAuthorizationFlowJwksUriQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetWellKnownOauthAuthorizationServerError =
  Fetcher.ErrorWrapper<undefined>;

export type GetWellKnownOauthAuthorizationServerVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetWellKnownOauthAuthorizationServer = (
  variables: GetWellKnownOauthAuthorizationServerVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetWellKnownOauthAuthorizationServerError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/.well-known/oauth-authorization-server",
    method: "get",
    ...variables,
    signal,
  });

export function getWellKnownOauthAuthorizationServerQuery(
  variables: GetWellKnownOauthAuthorizationServerVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getWellKnownOauthAuthorizationServerQuery(
  variables:
    | GetWellKnownOauthAuthorizationServerVariables
    | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getWellKnownOauthAuthorizationServerQuery(
  variables:
    | GetWellKnownOauthAuthorizationServerVariables
    | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/.well-known/oauth-authorization-server",
      operationId: "getWellKnownOauthAuthorizationServer",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetWellKnownOauthAuthorizationServer(variables, signal),
  };
}

export const useSuspenseGetWellKnownOauthAuthorizationServer = <TData = void,>(
  variables: GetWellKnownOauthAuthorizationServerVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetWellKnownOauthAuthorizationServerError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetWellKnownOauthAuthorizationServerError,
    TData
  >({
    ...getWellKnownOauthAuthorizationServerQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetWellKnownOauthAuthorizationServer = <TData = void,>(
  variables:
    | GetWellKnownOauthAuthorizationServerVariables
    | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetWellKnownOauthAuthorizationServerError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    void,
    GetWellKnownOauthAuthorizationServerError,
    TData
  >({
    ...getWellKnownOauthAuthorizationServerQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetWellKnownOpenidConfigurationError =
  Fetcher.ErrorWrapper<undefined>;

export type GetWellKnownOpenidConfigurationVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetWellKnownOpenidConfiguration = (
  variables: GetWellKnownOpenidConfigurationVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    void,
    GetWellKnownOpenidConfigurationError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/.well-known/openid-configuration",
    method: "get",
    ...variables,
    signal,
  });

export function getWellKnownOpenidConfigurationQuery(
  variables: GetWellKnownOpenidConfigurationVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getWellKnownOpenidConfigurationQuery(
  variables: GetWellKnownOpenidConfigurationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getWellKnownOpenidConfigurationQuery(
  variables: GetWellKnownOpenidConfigurationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/.well-known/openid-configuration",
      operationId: "getWellKnownOpenidConfiguration",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetWellKnownOpenidConfiguration(variables, signal),
  };
}

export const useSuspenseGetWellKnownOpenidConfiguration = <TData = void,>(
  variables: GetWellKnownOpenidConfigurationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetWellKnownOpenidConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetWellKnownOpenidConfigurationError,
    TData
  >({
    ...getWellKnownOpenidConfigurationQuery(
      deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export const useGetWellKnownOpenidConfiguration = <TData = void,>(
  variables: GetWellKnownOpenidConfigurationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      void,
      GetWellKnownOpenidConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetWellKnownOpenidConfigurationError, TData>(
    {
      ...getWellKnownOpenidConfigurationQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type GetNotificationDevicesError = Fetcher.ErrorWrapper<undefined>;

export type GetNotificationDevicesResponse = Schemas.FirebaseDevice[];

export type GetNotificationDevicesVariables = HyperionContext["fetcherOptions"];

/**
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export const fetchGetNotificationDevices = (
  variables: GetNotificationDevicesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetNotificationDevicesResponse,
    GetNotificationDevicesError,
    undefined,
    {},
    {},
    {}
  >({ url: "/notification/devices", method: "get", ...variables, signal });

/**
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export function getNotificationDevicesQuery(
  variables: GetNotificationDevicesVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetNotificationDevicesResponse>;
};

export function getNotificationDevicesQuery(
  variables: GetNotificationDevicesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetNotificationDevicesResponse>)
    | reactQuery.SkipToken;
};

export function getNotificationDevicesQuery(
  variables: GetNotificationDevicesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/notification/devices",
      operationId: "getNotificationDevices",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetNotificationDevices(variables, signal),
  };
}

/**
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export const useSuspenseGetNotificationDevices = <
  TData = GetNotificationDevicesResponse,
>(
  variables: GetNotificationDevicesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationDevicesResponse,
      GetNotificationDevicesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetNotificationDevicesResponse,
    GetNotificationDevicesError,
    TData
  >({
    ...getNotificationDevicesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Get all devices a user have registered.
 * This endpoint is useful to get firebase tokens for debugging purposes.
 *
 * **Only admins can use this endpoint**
 */
export const useGetNotificationDevices = <
  TData = GetNotificationDevicesResponse,
>(
  variables: GetNotificationDevicesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationDevicesResponse,
      GetNotificationDevicesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetNotificationDevicesResponse,
    GetNotificationDevicesError,
    TData
  >({
    ...getNotificationDevicesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostNotificationDevicesError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostNotificationDevicesVariables = {
  body: Schemas.BodyRegisterFirebaseDeviceNotificationDevicesPost;
} & HyperionContext["fetcherOptions"];

/**
 * Register a firebase device for the user, if the device already exists, this will update the creation date.
 * This endpoint should be called once a month to ensure that the token is still valide.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostNotificationDevices = (
  variables: PostNotificationDevicesVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationDevicesError,
    Schemas.BodyRegisterFirebaseDeviceNotificationDevicesPost,
    {},
    {},
    {}
  >({ url: "/notification/devices", method: "post", ...variables, signal });

/**
 * Register a firebase device for the user, if the device already exists, this will update the creation date.
 * This endpoint should be called once a month to ensure that the token is still valide.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostNotificationDevices = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationDevicesError,
      PostNotificationDevicesVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationDevicesError,
    PostNotificationDevicesVariables
  >({
    mutationFn: (variables: PostNotificationDevicesVariables) =>
      fetchPostNotificationDevices(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type DeleteNotificationDevicesFirebaseTokenPathParams = {
  firebaseToken: string;
};

export type DeleteNotificationDevicesFirebaseTokenError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type DeleteNotificationDevicesFirebaseTokenVariables = {
  pathParams: DeleteNotificationDevicesFirebaseTokenPathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Unregister a firebase device for the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchDeleteNotificationDevicesFirebaseToken = (
  variables: DeleteNotificationDevicesFirebaseTokenVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    DeleteNotificationDevicesFirebaseTokenError,
    undefined,
    {},
    {},
    DeleteNotificationDevicesFirebaseTokenPathParams
  >({
    url: "/notification/devices/{firebaseToken}",
    method: "delete",
    ...variables,
    signal,
  });

/**
 * Unregister a firebase device for the user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useDeleteNotificationDevicesFirebaseToken = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteNotificationDevicesFirebaseTokenError,
      DeleteNotificationDevicesFirebaseTokenVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    DeleteNotificationDevicesFirebaseTokenError,
    DeleteNotificationDevicesFirebaseTokenVariables
  >({
    mutationFn: (variables: DeleteNotificationDevicesFirebaseTokenVariables) =>
      fetchDeleteNotificationDevicesFirebaseToken(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostNotificationTopicsTopicIdSubscribePathParams = {
  /**
   * @format uuid
   */
  topicId: string;
};

export type PostNotificationTopicsTopicIdSubscribeError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostNotificationTopicsTopicIdSubscribeVariables = {
  pathParams: PostNotificationTopicsTopicIdSubscribePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Subscribe to a topic.
 *
 * If the topic define restrictions, the user must be in the corresponding group or be a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostNotificationTopicsTopicIdSubscribe = (
  variables: PostNotificationTopicsTopicIdSubscribeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTopicsTopicIdSubscribeError,
    undefined,
    {},
    {},
    PostNotificationTopicsTopicIdSubscribePathParams
  >({
    url: "/notification/topics/{topicId}/subscribe",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Subscribe to a topic.
 *
 * If the topic define restrictions, the user must be in the corresponding group or be a member.
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostNotificationTopicsTopicIdSubscribe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTopicsTopicIdSubscribeError,
      PostNotificationTopicsTopicIdSubscribeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTopicsTopicIdSubscribeError,
    PostNotificationTopicsTopicIdSubscribeVariables
  >({
    mutationFn: (variables: PostNotificationTopicsTopicIdSubscribeVariables) =>
      fetchPostNotificationTopicsTopicIdSubscribe(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type PostNotificationTopicsTopicIdUnsubscribePathParams = {
  /**
   * @format uuid
   */
  topicId: string;
};

export type PostNotificationTopicsTopicIdUnsubscribeError =
  Fetcher.ErrorWrapper<{
    status: 422;
    payload: Schemas.HTTPValidationError;
  }>;

export type PostNotificationTopicsTopicIdUnsubscribeVariables = {
  pathParams: PostNotificationTopicsTopicIdUnsubscribePathParams;
} & HyperionContext["fetcherOptions"];

/**
 * Unsubscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchPostNotificationTopicsTopicIdUnsubscribe = (
  variables: PostNotificationTopicsTopicIdUnsubscribeVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTopicsTopicIdUnsubscribeError,
    undefined,
    {},
    {},
    PostNotificationTopicsTopicIdUnsubscribePathParams
  >({
    url: "/notification/topics/{topicId}/unsubscribe",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Unsubscribe to a topic
 *
 * **The user must be authenticated to use this endpoint**
 */
export const usePostNotificationTopicsTopicIdUnsubscribe = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTopicsTopicIdUnsubscribeError,
      PostNotificationTopicsTopicIdUnsubscribeVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTopicsTopicIdUnsubscribeError,
    PostNotificationTopicsTopicIdUnsubscribeVariables
  >({
    mutationFn: (
      variables: PostNotificationTopicsTopicIdUnsubscribeVariables,
    ) =>
      fetchPostNotificationTopicsTopicIdUnsubscribe(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetNotificationTopicsError = Fetcher.ErrorWrapper<undefined>;

export type GetNotificationTopicsResponse = Schemas.TopicUser[];

export type GetNotificationTopicsVariables = HyperionContext["fetcherOptions"];

/**
 * Return all available topics for a user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const fetchGetNotificationTopics = (
  variables: GetNotificationTopicsVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    GetNotificationTopicsResponse,
    GetNotificationTopicsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/notification/topics", method: "get", ...variables, signal });

/**
 * Return all available topics for a user
 *
 * **The user must be authenticated to use this endpoint**
 */
export function getNotificationTopicsQuery(
  variables: GetNotificationTopicsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetNotificationTopicsResponse>;
};

export function getNotificationTopicsQuery(
  variables: GetNotificationTopicsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetNotificationTopicsResponse>)
    | reactQuery.SkipToken;
};

export function getNotificationTopicsQuery(
  variables: GetNotificationTopicsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/notification/topics",
      operationId: "getNotificationTopics",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetNotificationTopics(variables, signal),
  };
}

/**
 * Return all available topics for a user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useSuspenseGetNotificationTopics = <
  TData = GetNotificationTopicsResponse,
>(
  variables: GetNotificationTopicsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationTopicsResponse,
      GetNotificationTopicsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    GetNotificationTopicsResponse,
    GetNotificationTopicsError,
    TData
  >({
    ...getNotificationTopicsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

/**
 * Return all available topics for a user
 *
 * **The user must be authenticated to use this endpoint**
 */
export const useGetNotificationTopics = <
  TData = GetNotificationTopicsResponse,
>(
  variables: GetNotificationTopicsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetNotificationTopicsResponse,
      GetNotificationTopicsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<
    GetNotificationTopicsResponse,
    GetNotificationTopicsError,
    TData
  >({
    ...getNotificationTopicsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PostNotificationSendError = Fetcher.ErrorWrapper<{
  status: 422;
  payload: Schemas.HTTPValidationError;
}>;

export type PostNotificationSendVariables = {
  body: Schemas.GroupNotificationRequest;
} & HyperionContext["fetcherOptions"];

/**
 * Send a notification to a group.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationSend = (
  variables: PostNotificationSendVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationSendError,
    Schemas.GroupNotificationRequest,
    {},
    {},
    {}
  >({ url: "/notification/send", method: "post", ...variables, signal });

/**
 * Send a notification to a group.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationSend = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationSendError,
      PostNotificationSendVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationSendError,
    PostNotificationSendVariables
  >({
    mutationFn: (variables: PostNotificationSendVariables) =>
      fetchPostNotificationSend(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostNotificationTestSendError = Fetcher.ErrorWrapper<undefined>;

export type PostNotificationTestSendVariables =
  HyperionContext["fetcherOptions"];

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationTestSend = (
  variables: PostNotificationTestSendVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, PostNotificationTestSendError, undefined, {}, {}, {}>({
    url: "/notification/test/send",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationTestSend = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      void,
      PostNotificationTestSendError,
      PostNotificationTestSendVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    void,
    PostNotificationTestSendError,
    PostNotificationTestSendVariables
  >({
    mutationFn: (variables: PostNotificationTestSendVariables) =>
      fetchPostNotificationTestSend(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostNotificationTestSendFutureError =
  Fetcher.ErrorWrapper<undefined>;

export type PostNotificationTestSendFutureVariables =
  HyperionContext["fetcherOptions"];

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationTestSendFuture = (
  variables: PostNotificationTestSendFutureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTestSendFutureError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/notification/test/send/future",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationTestSendFuture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTestSendFutureError,
      PostNotificationTestSendFutureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTestSendFutureError,
    PostNotificationTestSendFutureVariables
  >({
    mutationFn: (variables: PostNotificationTestSendFutureVariables) =>
      fetchPostNotificationTestSendFuture(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostNotificationTestSendTopicError =
  Fetcher.ErrorWrapper<undefined>;

export type PostNotificationTestSendTopicVariables =
  HyperionContext["fetcherOptions"];

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationTestSendTopic = (
  variables: PostNotificationTestSendTopicVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTestSendTopicError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/notification/test/send/topic",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationTestSendTopic = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTestSendTopicError,
      PostNotificationTestSendTopicVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTestSendTopicError,
    PostNotificationTestSendTopicVariables
  >({
    mutationFn: (variables: PostNotificationTestSendTopicVariables) =>
      fetchPostNotificationTestSendTopic(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type PostNotificationTestSendTopicFutureError =
  Fetcher.ErrorWrapper<undefined>;

export type PostNotificationTestSendTopicFutureVariables =
  HyperionContext["fetcherOptions"];

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const fetchPostNotificationTestSendTopicFuture = (
  variables: PostNotificationTestSendTopicFutureVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<
    undefined,
    PostNotificationTestSendTopicFutureError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/notification/test/send/topic/future",
    method: "post",
    ...variables,
    signal,
  });

/**
 * Send ourself a test notification.
 *
 * **Only admins can use this endpoint**
 */
export const usePostNotificationTestSendTopicFuture = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      PostNotificationTestSendTopicFutureError,
      PostNotificationTestSendTopicFutureVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useHyperionContext();
  return reactQuery.useMutation<
    undefined,
    PostNotificationTestSendTopicFutureError,
    PostNotificationTestSendTopicFutureVariables
  >({
    mutationFn: (variables: PostNotificationTestSendTopicFutureVariables) =>
      fetchPostNotificationTestSendTopicFuture(
        deepMerge(fetcherOptions, variables),
      ),
    ...options,
  });
};

export type GetGoogleApiOauth2callbackError = Fetcher.ErrorWrapper<undefined>;

export type GetGoogleApiOauth2callbackVariables =
  HyperionContext["fetcherOptions"];

export const fetchGetGoogleApiOauth2callback = (
  variables: GetGoogleApiOauth2callbackVariables,
  signal?: AbortSignal,
) =>
  hyperionFetch<void, GetGoogleApiOauth2callbackError, undefined, {}, {}, {}>({
    url: "/google-api/oauth2callback",
    method: "get",
    ...variables,
    signal,
  });

export function getGoogleApiOauth2CallbackQuery(
  variables: GetGoogleApiOauth2callbackVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<void>;
};

export function getGoogleApiOauth2CallbackQuery(
  variables: GetGoogleApiOauth2callbackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: ((options: QueryFnOptions) => Promise<void>) | reactQuery.SkipToken;
};

export function getGoogleApiOauth2CallbackQuery(
  variables: GetGoogleApiOauth2callbackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/google-api/oauth2callback",
      operationId: "getGoogleApiOauth2callback",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetGoogleApiOauth2callback(variables, signal),
  };
}

export const useSuspenseGetGoogleApiOauth2callback = <TData = void,>(
  variables: GetGoogleApiOauth2callbackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetGoogleApiOauth2callbackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useSuspenseQuery<
    void,
    GetGoogleApiOauth2callbackError,
    TData
  >({
    ...getGoogleApiOauth2CallbackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetGoogleApiOauth2callback = <TData = void,>(
  variables: GetGoogleApiOauth2callbackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<void, GetGoogleApiOauth2callbackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useHyperionContext(options);
  return reactQuery.useQuery<void, GetGoogleApiOauth2callbackError, TData>({
    ...getGoogleApiOauth2CallbackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/seed_library/species/";
      operationId: "getSeedLibrarySpecies";
      variables: GetSeedLibrarySpeciesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/seed_library/species/types";
      operationId: "getSeedLibrarySpeciesTypes";
      variables: GetSeedLibrarySpeciesTypesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/seed_library/plants/waiting";
      operationId: "getSeedLibraryPlantsWaiting";
      variables: GetSeedLibraryPlantsWaitingVariables | reactQuery.SkipToken;
    }
  | {
      path: "/seed_library/plants/users/me";
      operationId: "getSeedLibraryPlantsUsersMe";
      variables: GetSeedLibraryPlantsUsersMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/seed_library/plants/users/{userId}";
      operationId: "getSeedLibraryPlantsUsersUserId";
      variables:
        | GetSeedLibraryPlantsUsersUserIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/seed_library/plants/{plantId}";
      operationId: "getSeedLibraryPlantsPlantId";
      variables: GetSeedLibraryPlantsPlantIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/seed_library/information";
      operationId: "getSeedLibraryInformation";
      variables: GetSeedLibraryInformationVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/products";
      operationId: "getAmapProducts";
      variables: GetAmapProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/products/{productId}";
      operationId: "getAmapProductsProductId";
      variables: GetAmapProductsProductIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/deliveries";
      operationId: "getAmapDeliveries";
      variables: GetAmapDeliveriesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/deliveries/{deliveryId}/orders";
      operationId: "getAmapDeliveriesDeliveryIdOrders";
      variables:
        | GetAmapDeliveriesDeliveryIdOrdersVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/amap/orders/{orderId}";
      operationId: "getAmapOrdersOrderId";
      variables: GetAmapOrdersOrderIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/users/cash";
      operationId: "getAmapUsersCash";
      variables: GetAmapUsersCashVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/users/{userId}/cash";
      operationId: "getAmapUsersUserIdCash";
      variables: GetAmapUsersUserIdCashVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/users/{userId}/orders";
      operationId: "getAmapUsersUserIdOrders";
      variables: GetAmapUsersUserIdOrdersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/amap/information";
      operationId: "getAmapInformation";
      variables: GetAmapInformationVariables | reactQuery.SkipToken;
    }
  | {
      path: "/booking/managers";
      operationId: "getBookingManagers";
      variables: GetBookingManagersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/booking/managers/users/me";
      operationId: "getBookingManagersUsersMe";
      variables: GetBookingManagersUsersMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/booking/bookings/users/me/manage";
      operationId: "getBookingBookingsUsersMeManage";
      variables:
        | GetBookingBookingsUsersMeManageVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/booking/bookings/confirmed/users/me/manage";
      operationId: "getBookingBookingsConfirmedUsersMeManage";
      variables:
        | GetBookingBookingsConfirmedUsersMeManageVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/booking/bookings/confirmed";
      operationId: "getBookingBookingsConfirmed";
      variables: GetBookingBookingsConfirmedVariables | reactQuery.SkipToken;
    }
  | {
      path: "/booking/bookings/users/me";
      operationId: "getBookingBookingsUsersMe";
      variables: GetBookingBookingsUsersMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/booking/rooms";
      operationId: "getBookingRooms";
      variables: GetBookingRoomsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/sections";
      operationId: "getCampaignSections";
      variables: GetCampaignSectionsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/lists";
      operationId: "getCampaignLists";
      variables: GetCampaignListsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/voters";
      operationId: "getCampaignVoters";
      variables: GetCampaignVotersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/votes";
      operationId: "getCampaignVotes";
      variables: GetCampaignVotesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/results";
      operationId: "getCampaignResults";
      variables: GetCampaignResultsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/status";
      operationId: "getCampaignStatus";
      variables: GetCampaignStatusVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/stats/{sectionId}";
      operationId: "getCampaignStatsSectionId";
      variables: GetCampaignStatsSectionIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/campaign/lists/{listId}/logo";
      operationId: "getCampaignListsListIdLogo";
      variables: GetCampaignListsListIdLogoVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/";
      operationId: "getCdrUsers";
      variables: GetCdrUsersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/pending/";
      operationId: "getCdrUsersPending";
      variables: GetCdrUsersPendingVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/{userId}/";
      operationId: "getCdrUsersUserId";
      variables: GetCdrUsersUserIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/";
      operationId: "getCdrSellers";
      variables: GetCdrSellersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/me/sellers/";
      operationId: "getCdrUsersMeSellers";
      variables: GetCdrUsersMeSellersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/online/sellers/";
      operationId: "getCdrOnlineSellers";
      variables: GetCdrOnlineSellersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/results/";
      operationId: "getCdrSellersSellerIdResults";
      variables: GetCdrSellersSellerIdResultsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/online/products/";
      operationId: "getCdrOnlineProducts";
      variables: GetCdrOnlineProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/products/";
      operationId: "getCdrProducts";
      variables: GetCdrProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/";
      operationId: "getCdrSellersSellerIdProducts";
      variables: GetCdrSellersSellerIdProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/online/sellers/{sellerId}/products/";
      operationId: "getCdrOnlineSellersSellerIdProducts";
      variables:
        | GetCdrOnlineSellersSellerIdProductsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/documents/";
      operationId: "getCdrSellersSellerIdDocuments";
      variables: GetCdrSellersSellerIdDocumentsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/documents/";
      operationId: "getCdrDocuments";
      variables: GetCdrDocumentsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/{userId}/purchases/";
      operationId: "getCdrUsersUserIdPurchases";
      variables: GetCdrUsersUserIdPurchasesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/me/purchases/";
      operationId: "getCdrMePurchases";
      variables: GetCdrMePurchasesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/users/{userId}/purchases/";
      operationId: "getCdrSellersSellerIdUsersUserIdPurchases";
      variables:
        | GetCdrSellersSellerIdUsersUserIdPurchasesVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/{userId}/signatures/";
      operationId: "getCdrUsersUserIdSignatures";
      variables: GetCdrUsersUserIdSignaturesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/users/{userId}/signatures/";
      operationId: "getCdrSellersSellerIdUsersUserIdSignatures";
      variables:
        | GetCdrSellersSellerIdUsersUserIdSignaturesVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/curriculums/";
      operationId: "getCdrCurriculums";
      variables: GetCdrCurriculumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/{userId}/payments/";
      operationId: "getCdrUsersUserIdPayments";
      variables: GetCdrUsersUserIdPaymentsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/status/";
      operationId: "getCdrStatus";
      variables: GetCdrStatusVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/me/tickets/";
      operationId: "getCdrUsersMeTickets";
      variables: GetCdrUsersMeTicketsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/{userId}/tickets/";
      operationId: "getCdrUsersUserIdTickets";
      variables: GetCdrUsersUserIdTicketsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/users/me/tickets/{ticketId}/secret/";
      operationId: "getCdrUsersMeTicketsTicketIdSecret";
      variables:
        | GetCdrUsersMeTicketsTicketIdSecretVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/{secret}/";
      operationId: "getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecret";
      variables:
        | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdSecretVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/{productId}/tickets/{generatorId}/lists/{tag}/";
      operationId: "getCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTag";
      variables:
        | GetCdrSellersSellerIdProductsProductIdTicketsGeneratorIdListsTagVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/{productId}/tags/{generatorId}/";
      operationId: "getCdrSellersSellerIdProductsProductIdTagsGeneratorId";
      variables:
        | GetCdrSellersSellerIdProductsProductIdTagsGeneratorIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/{productId}/data/";
      operationId: "getCdrSellersSellerIdProductsProductIdData";
      variables:
        | GetCdrSellersSellerIdProductsProductIdDataVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cdr/sellers/{sellerId}/products/{productId}/users/{userId}/data/{fieldId}/";
      operationId: "getCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldId";
      variables:
        | GetCdrSellersSellerIdProductsProductIdUsersUserIdDataFieldIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cinema/themoviedb/{themoviedbId}";
      operationId: "getCinemaThemoviedbThemoviedbId";
      variables:
        | GetCinemaThemoviedbThemoviedbIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/cinema/sessions";
      operationId: "getCinemaSessions";
      variables: GetCinemaSessionsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/cinema/sessions/{sessionId}/poster";
      operationId: "getCinemaSessionsSessionIdPoster";
      variables:
        | GetCinemaSessionsSessionIdPosterVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/raffles";
      operationId: "getTombolaRaffles";
      variables: GetTombolaRafflesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/group/{groupId}/raffles";
      operationId: "getTombolaGroupGroupIdRaffles";
      variables: GetTombolaGroupGroupIdRafflesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/raffles/{raffleId}/stats";
      operationId: "getTombolaRafflesRaffleIdStats";
      variables: GetTombolaRafflesRaffleIdStatsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/raffles/{raffleId}/logo";
      operationId: "getTombolaRafflesRaffleIdLogo";
      variables: GetTombolaRafflesRaffleIdLogoVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/pack_tickets";
      operationId: "getTombolaPackTickets";
      variables: GetTombolaPackTicketsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/raffles/{raffleId}/pack_tickets";
      operationId: "getTombolaRafflesRaffleIdPackTickets";
      variables:
        | GetTombolaRafflesRaffleIdPackTicketsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/tickets";
      operationId: "getTombolaTickets";
      variables: GetTombolaTicketsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/users/{userId}/tickets";
      operationId: "getTombolaUsersUserIdTickets";
      variables: GetTombolaUsersUserIdTicketsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/raffles/{raffleId}/tickets";
      operationId: "getTombolaRafflesRaffleIdTickets";
      variables:
        | GetTombolaRafflesRaffleIdTicketsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/prizes";
      operationId: "getTombolaPrizes";
      variables: GetTombolaPrizesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/raffles/{raffleId}/prizes";
      operationId: "getTombolaRafflesRaffleIdPrizes";
      variables:
        | GetTombolaRafflesRaffleIdPrizesVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/prizes/{prizeId}/picture";
      operationId: "getTombolaPrizesPrizeIdPicture";
      variables: GetTombolaPrizesPrizeIdPictureVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/users/cash";
      operationId: "getTombolaUsersCash";
      variables: GetTombolaUsersCashVariables | reactQuery.SkipToken;
    }
  | {
      path: "/tombola/users/{userId}/cash";
      operationId: "getTombolaUsersUserIdCash";
      variables: GetTombolaUsersUserIdCashVariables | reactQuery.SkipToken;
    }
  | {
      path: "/recommendation/recommendations";
      operationId: "getRecommendationRecommendations";
      variables:
        | GetRecommendationRecommendationsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/recommendation/recommendations/{recommendationId}/picture";
      operationId: "getRecommendationRecommendationsRecommendationIdPicture";
      variables:
        | GetRecommendationRecommendationsRecommendationIdPictureVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/ph/{paperId}/pdf";
      operationId: "getPhPaperIdPdf";
      variables: GetPhPaperIdPdfVariables | reactQuery.SkipToken;
    }
  | {
      path: "/ph/";
      operationId: "getPh";
      variables: GetPhVariables | reactQuery.SkipToken;
    }
  | {
      path: "/ph/admin";
      operationId: "getPhAdmin";
      variables: GetPhAdminVariables | reactQuery.SkipToken;
    }
  | {
      path: "/ph/{paperId}/cover";
      operationId: "getPhPaperIdCover";
      variables: GetPhPaperIdCoverVariables | reactQuery.SkipToken;
    }
  | {
      path: "/loans/loaners/";
      operationId: "getLoansLoaners";
      variables: GetLoansLoanersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/loans/loaners/{loanerId}/loans";
      operationId: "getLoansLoanersLoanerIdLoans";
      variables: GetLoansLoanersLoanerIdLoansVariables | reactQuery.SkipToken;
    }
  | {
      path: "/loans/loaners/{loanerId}/items";
      operationId: "getLoansLoanersLoanerIdItems";
      variables: GetLoansLoanersLoanerIdItemsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/loans/users/me";
      operationId: "getLoansUsersMe";
      variables: GetLoansUsersMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/loans/users/me/loaners";
      operationId: "getLoansUsersMeLoaners";
      variables: GetLoansUsersMeLoanersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/flappybird/scores";
      operationId: "getFlappybirdScores";
      variables: GetFlappybirdScoresVariables | reactQuery.SkipToken;
    }
  | {
      path: "/flappybird/scores/me";
      operationId: "getFlappybirdScoresMe";
      variables: GetFlappybirdScoresMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/sports";
      operationId: "getCompetitionSports";
      variables: GetCompetitionSportsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/editions";
      operationId: "getCompetitionEditions";
      variables: GetCompetitionEditionsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/editions/active";
      operationId: "getCompetitionEditionsActive";
      variables: GetCompetitionEditionsActiveVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/users";
      operationId: "getCompetitionUsers";
      variables: GetCompetitionUsersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/users/me";
      operationId: "getCompetitionUsersMe";
      variables: GetCompetitionUsersMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/users/{userId}";
      operationId: "getCompetitionUsersUserId";
      variables: GetCompetitionUsersUserIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/groups/{group}";
      operationId: "getCompetitionGroupsGroup";
      variables: GetCompetitionGroupsGroupVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/users/me/groups";
      operationId: "getCompetitionUsersMeGroups";
      variables: GetCompetitionUsersMeGroupsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/users/{userId}/groups";
      operationId: "getCompetitionUsersUserIdGroups";
      variables:
        | GetCompetitionUsersUserIdGroupsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/schools";
      operationId: "getCompetitionSchools";
      variables: GetCompetitionSchoolsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/schools/{schoolId}";
      operationId: "getCompetitionSchoolsSchoolId";
      variables: GetCompetitionSchoolsSchoolIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/sports/{sportId}/quotas";
      operationId: "getCompetitionSportsSportIdQuotas";
      variables:
        | GetCompetitionSportsSportIdQuotasVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/schools/{schoolId}/quotas";
      operationId: "getCompetitionSchoolsSchoolIdQuotas";
      variables:
        | GetCompetitionSchoolsSchoolIdQuotasVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/teams/sports/{sportId}";
      operationId: "getCompetitionTeamsSportsSportId";
      variables:
        | GetCompetitionTeamsSportsSportIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/teams/sports/{sportId}/schools/{schoolId}";
      operationId: "getCompetitionTeamsSportsSportIdSchoolsSchoolId";
      variables:
        | GetCompetitionTeamsSportsSportIdSchoolsSchoolIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/participants/me";
      operationId: "getCompetitionParticipantsMe";
      variables: GetCompetitionParticipantsMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/participants/sports/{sportId}";
      operationId: "getCompetitionParticipantsSportsSportId";
      variables:
        | GetCompetitionParticipantsSportsSportIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/participants/schools/{schoolId}";
      operationId: "getCompetitionParticipantsSchoolsSchoolId";
      variables:
        | GetCompetitionParticipantsSchoolsSchoolIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/locations";
      operationId: "getCompetitionLocations";
      variables: GetCompetitionLocationsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/locations/{locationId}";
      operationId: "getCompetitionLocationsLocationId";
      variables:
        | GetCompetitionLocationsLocationIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/sports/{sportId}/matches";
      operationId: "getCompetitionSportsSportIdMatches";
      variables:
        | GetCompetitionSportsSportIdMatchesVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/schools/{schoolId}/matches";
      operationId: "getCompetitionSchoolsSchoolIdMatches";
      variables:
        | GetCompetitionSchoolsSchoolIdMatchesVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/podiums/global";
      operationId: "getCompetitionPodiumsGlobal";
      variables: GetCompetitionPodiumsGlobalVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/podiums/sport/{sportId}";
      operationId: "getCompetitionPodiumsSportSportId";
      variables:
        | GetCompetitionPodiumsSportSportIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/podiums/school/{schoolId}";
      operationId: "getCompetitionPodiumsSchoolSchoolId";
      variables:
        | GetCompetitionPodiumsSchoolSchoolIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/products";
      operationId: "getCompetitionProducts";
      variables: GetCompetitionProductsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/products/available";
      operationId: "getCompetitionProductsAvailable";
      variables:
        | GetCompetitionProductsAvailableVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/purchases/users/{userId}";
      operationId: "getCompetitionPurchasesUsersUserId";
      variables:
        | GetCompetitionPurchasesUsersUserIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/competition/purchases/me";
      operationId: "getCompetitionPurchasesMe";
      variables: GetCompetitionPurchasesMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/competition/users/{userId}/payments";
      operationId: "getCompetitionUsersUserIdPayments";
      variables:
        | GetCompetitionUsersUserIdPaymentsVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/advert/advertisers";
      operationId: "getAdvertAdvertisers";
      variables: GetAdvertAdvertisersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/advert/me/advertisers";
      operationId: "getAdvertMeAdvertisers";
      variables: GetAdvertMeAdvertisersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/advert/adverts";
      operationId: "getAdvertAdverts";
      variables: GetAdvertAdvertsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/advert/adverts/{advertId}";
      operationId: "getAdvertAdvertsAdvertId";
      variables: GetAdvertAdvertsAdvertIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/advert/adverts/{advertId}/picture";
      operationId: "getAdvertAdvertsAdvertIdPicture";
      variables:
        | GetAdvertAdvertsAdvertIdPictureVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/associations/";
      operationId: "getPhonebookAssociations";
      variables: GetPhonebookAssociationsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/roletags";
      operationId: "getPhonebookRoletags";
      variables: GetPhonebookRoletagsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/associations/kinds";
      operationId: "getPhonebookAssociationsKinds";
      variables: GetPhonebookAssociationsKindsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/associations/{associationId}/members/";
      operationId: "getPhonebookAssociationsAssociationIdMembers";
      variables:
        | GetPhonebookAssociationsAssociationIdMembersVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/associations/{associationId}/members/{mandateYear}";
      operationId: "getPhonebookAssociationsAssociationIdMembersMandateYear";
      variables:
        | GetPhonebookAssociationsAssociationIdMembersMandateYearVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/member/{userId}";
      operationId: "getPhonebookMemberUserId";
      variables: GetPhonebookMemberUserIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/phonebook/associations/{associationId}/picture";
      operationId: "getPhonebookAssociationsAssociationIdPicture";
      variables:
        | GetPhonebookAssociationsAssociationIdPictureVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/raid/participants/{participantId}";
      operationId: "getRaidParticipantsParticipantId";
      variables:
        | GetRaidParticipantsParticipantIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/raid/teams";
      operationId: "getRaidTeams";
      variables: GetRaidTeamsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raid/participants/{participantId}/team";
      operationId: "getRaidParticipantsParticipantIdTeam";
      variables:
        | GetRaidParticipantsParticipantIdTeamVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/raid/teams/{teamId}";
      operationId: "getRaidTeamsTeamId";
      variables: GetRaidTeamsTeamIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raid/document/{documentId}";
      operationId: "getRaidDocumentDocumentId";
      variables: GetRaidDocumentDocumentIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raid/information";
      operationId: "getRaidInformation";
      variables: GetRaidInformationVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raid/drive";
      operationId: "getRaidDrive";
      variables: GetRaidDriveVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raid/price";
      operationId: "getRaidPrice";
      variables: GetRaidPriceVariables | reactQuery.SkipToken;
    }
  | {
      path: "/raid/pay";
      operationId: "getRaidPay";
      variables: GetRaidPayVariables | reactQuery.SkipToken;
    }
  | {
      path: "/calendar/events/";
      operationId: "getCalendarEvents";
      variables: GetCalendarEventsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/calendar/events/confirmed";
      operationId: "getCalendarEventsConfirmed";
      variables: GetCalendarEventsConfirmedVariables | reactQuery.SkipToken;
    }
  | {
      path: "/calendar/events/user/{applicantId}";
      operationId: "getCalendarEventsUserApplicantId";
      variables:
        | GetCalendarEventsUserApplicantIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/calendar/events/{eventId}";
      operationId: "getCalendarEventsEventId";
      variables: GetCalendarEventsEventIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/calendar/events/{eventId}/applicant";
      operationId: "getCalendarEventsEventIdApplicant";
      variables:
        | GetCalendarEventsEventIdApplicantVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/calendar/ical";
      operationId: "getCalendarIcal";
      variables: GetCalendarIcalVariables | reactQuery.SkipToken;
    }
  | {
      path: "/schools/";
      operationId: "getSchools";
      variables: GetSchoolsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/schools/{schoolId}";
      operationId: "getSchoolsSchoolId";
      variables: GetSchoolsSchoolIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users";
      operationId: "getUsers";
      variables: GetUsersVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/count";
      operationId: "getUsersCount";
      variables: GetUsersCountVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/search";
      operationId: "getUsersSearch";
      variables: GetUsersSearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/account-types";
      operationId: "getUsersAccountTypes";
      variables: GetUsersAccountTypesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/me";
      operationId: "getUsersMe";
      variables: GetUsersMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/migrate-mail-confirm";
      operationId: "getUsersMigrateMailConfirm";
      variables: GetUsersMigrateMailConfirmVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/{userId}";
      operationId: "getUsersUserId";
      variables: GetUsersUserIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/me/profile-picture";
      operationId: "getUsersMeProfilePicture";
      variables: GetUsersMeProfilePictureVariables | reactQuery.SkipToken;
    }
  | {
      path: "/users/{userId}/profile-picture";
      operationId: "getUsersUserIdProfilePicture";
      variables: GetUsersUserIdProfilePictureVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/structures";
      operationId: "getMyeclpayStructures";
      variables: GetMyeclpayStructuresVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/structures/confirm-manager-transfer";
      operationId: "getMyeclpayStructuresConfirmManagerTransfer";
      variables:
        | GetMyeclpayStructuresConfirmManagerTransferVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/stores/{storeId}/history";
      operationId: "getMyeclpayStoresStoreIdHistory";
      variables:
        | GetMyeclpayStoresStoreIdHistoryVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/users/me/stores";
      operationId: "getMyeclpayUsersMeStores";
      variables: GetMyeclpayUsersMeStoresVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/stores/{storeId}/sellers";
      operationId: "getMyeclpayStoresStoreIdSellers";
      variables:
        | GetMyeclpayStoresStoreIdSellersVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/users/me/tos";
      operationId: "getMyeclpayUsersMeTos";
      variables: GetMyeclpayUsersMeTosVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/users/me/wallet/devices";
      operationId: "getMyeclpayUsersMeWalletDevices";
      variables:
        | GetMyeclpayUsersMeWalletDevicesVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/users/me/wallet/devices/{walletDeviceId}";
      operationId: "getMyeclpayUsersMeWalletDevicesWalletDeviceId";
      variables:
        | GetMyeclpayUsersMeWalletDevicesWalletDeviceIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/users/me/wallet";
      operationId: "getMyeclpayUsersMeWallet";
      variables: GetMyeclpayUsersMeWalletVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/devices/activate";
      operationId: "getMyeclpayDevicesActivate";
      variables: GetMyeclpayDevicesActivateVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/users/me/wallet/history";
      operationId: "getMyeclpayUsersMeWalletHistory";
      variables:
        | GetMyeclpayUsersMeWalletHistoryVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/transfer/redirect";
      operationId: "getMyeclpayTransferRedirect";
      variables: GetMyeclpayTransferRedirectVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay/integrity-check";
      operationId: "getMyeclpayIntegrityCheck";
      variables: GetMyeclpayIntegrityCheckVariables | reactQuery.SkipToken;
    }
  | {
      path: "/memberships/";
      operationId: "getMemberships";
      variables: GetMembershipsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/memberships/{associationMembershipId}/members";
      operationId: "getMembershipsAssociationMembershipIdMembers";
      variables:
        | GetMembershipsAssociationMembershipIdMembersVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/memberships/users/{userId}";
      operationId: "getMembershipsUsersUserId";
      variables: GetMembershipsUsersUserIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/memberships/users/{userId}/{associationMembershipId}";
      operationId: "getMembershipsUsersUserIdAssociationMembershipId";
      variables:
        | GetMembershipsUsersUserIdAssociationMembershipIdVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/groups/";
      operationId: "getGroups";
      variables: GetGroupsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/groups/{groupId}";
      operationId: "getGroupsGroupId";
      variables: GetGroupsGroupIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/information";
      operationId: "getInformation";
      variables: GetInformationVariables | reactQuery.SkipToken;
    }
  | {
      path: "/privacy";
      operationId: "getPrivacy";
      variables: GetPrivacyVariables | reactQuery.SkipToken;
    }
  | {
      path: "/terms-and-conditions";
      operationId: "getTermsAndConditions";
      variables: GetTermsAndConditionsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/myeclpay-terms-of-service";
      operationId: "getMyeclpayTermsOfService";
      variables: GetMyeclpayTermsOfServiceVariables | reactQuery.SkipToken;
    }
  | {
      path: "/support";
      operationId: "getSupport";
      variables: GetSupportVariables | reactQuery.SkipToken;
    }
  | {
      path: "/security.txt";
      operationId: "getSecurityTxt";
      variables: GetSecurityTxtVariables | reactQuery.SkipToken;
    }
  | {
      path: "/.well-known/security.txt";
      operationId: "getWellKnownSecurityTxt";
      variables: GetWellKnownSecurityTxtVariables | reactQuery.SkipToken;
    }
  | {
      path: "/robots.txt";
      operationId: "getRobotsTxt";
      variables: GetRobotsTxtVariables | reactQuery.SkipToken;
    }
  | {
      path: "/style/{file}.css";
      operationId: "getStyleFileCss";
      variables: GetStyleFileCssVariables | reactQuery.SkipToken;
    }
  | {
      path: "/favicon.ico";
      operationId: "getFaviconIco";
      variables: GetFaviconIcoVariables | reactQuery.SkipToken;
    }
  | {
      path: "/module-visibility/";
      operationId: "getModuleVisibility";
      variables: GetModuleVisibilityVariables | reactQuery.SkipToken;
    }
  | {
      path: "/module-visibility/me";
      operationId: "getModuleVisibilityMe";
      variables: GetModuleVisibilityMeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/auth/authorize";
      operationId: "getAuthAuthorize";
      variables: GetAuthAuthorizeVariables | reactQuery.SkipToken;
    }
  | {
      path: "/auth/userinfo";
      operationId: "getAuthUserinfo";
      variables: GetAuthUserinfoVariables | reactQuery.SkipToken;
    }
  | {
      path: "/oidc/authorization-flow/jwks_uri";
      operationId: "getOidcAuthorizationFlowJwksUri";
      variables:
        | GetOidcAuthorizationFlowJwksUriVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/.well-known/oauth-authorization-server";
      operationId: "getWellKnownOauthAuthorizationServer";
      variables:
        | GetWellKnownOauthAuthorizationServerVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/.well-known/openid-configuration";
      operationId: "getWellKnownOpenidConfiguration";
      variables:
        | GetWellKnownOpenidConfigurationVariables
        | reactQuery.SkipToken;
    }
  | {
      path: "/notification/devices";
      operationId: "getNotificationDevices";
      variables: GetNotificationDevicesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/notification/topics";
      operationId: "getNotificationTopics";
      variables: GetNotificationTopicsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/google-api/oauth2callback";
      operationId: "getGoogleApiOauth2callback";
      variables: GetGoogleApiOauth2callbackVariables | reactQuery.SkipToken;
    };
